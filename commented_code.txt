// image_mapping_utils.c
// Top
/**
 * @file image_mapping_utils.c
 * @brief Provides utility functions for mapping points from an observer's viewing plane
 * to a background source image plane, considering gravitational lensing in Schwarzschild spacetime.
 *
 * These functions (`image_map` and `image_map_radial`) implement the core logic for reverse
 * ray tracing. A light ray is initiated from the observer's position, directed towards a
 * specific point on a conceptual "window" plane (the observer's virtual screen). Its trajectory
 * is then traced backward in time (which corresponds to forward in affine parameter from the observer)
 * through the curved Schwarzschild spacetime. The primary goal is to determine where this ray
 * would have originated on a distant "source" plane, effectively mapping a point on the observer's
 * screen to its lensed origin in the background.
 *
 * This module is crucial for constructing gravitationally lensed images as seen by an observer.
 * The ray tracing is performed in a 2D projected plane due to the axial symmetry of the observer setup
 * (observer on the x-axis, Schwarzschild black hole at the origin) and the Schwarzschild metric itself.
 *
 * @see Schwarzschild_Lens_Paper.pdf Section 3.2 "Generating Images" for the geometric setup.
 * @dependencies trajectory_module.c (for `compute_trajectory_crossings_only`, the core geodesic integrator).
 */

#include "schwarzschild_tracer.h" // Includes common constants, structs like ImageMapResult, TrajectoryCrossings, gsl_vector, NAN, EPSILON_GENERAL, DEFAULT_T_END, M_PI.
// Standard C library includes like <math.h> (for sqrt, fabs, acos, fmax, fmin) are implicitly included via "schwarzschild_tracer.h".

// --- Image Mapping Functions ---

/**
 * @brief Calculates the apparent source plane coordinates (y_image) and window plane
 * coordinates (y_window) for a single light ray traced backwards from the observer.
 *
 * This function initiates a light ray from the `x_2_observer` position (on the x-axis)
 * and aims it towards a specific point (Y, Z) on the `x_1_window` plane. It then calls
 * the core geodesic integrator (`compute_trajectory_crossings_only`) to trace this ray
 * through the Schwarzschild spacetime. The function then extracts and returns the
 * y-coordinates (radial distances in the 2D integration plane) where the ray intersects
 * both the `x_1_window` plane and the `x_0_plane` (background source plane).
 *
 * The initial direction of the photon (defined by `psi_calc`) is derived such that
 * if spacetime were flat, the ray would pass through (Y,Z) on the window. This `psi_calc`
 * then determines the photon's relativistic impact parameter `b`.
 *
 * @param Y The Cartesian y-coordinate on the observer's virtual window plane (at `x_1_window`), in simulation units.
 *          Along with `Z`, this defines the initial offset from the x-axis for the ray's target.
 * @param Z The Cartesian z-coordinate on the observer's virtual window plane (at `x_1_window`), in simulation units.
 * @param x_0_plane The x-coordinate of the background source image plane (corresponding to `x_0` in Schwarzschild_Lens_Paper.pdf, Figure 1).
 * @param x_1_window The x-coordinate of the observer's virtual screen or "window" plane (corresponding to `x_1` in the paper).
 * @param x_2_observer The x-coordinate of the observer's position (corresponding to `x_2` in the paper). This is the ray's starting point.
 * @param a_scale A characteristic length scale or scaling factor, typically related to the semi-width
 *                of the observer's window or the field of view. It is used internally to set the
 *                `r_max_integration` for the geodesic tracer, ensuring the integration domain is
 *                sufficiently large for the given scene geometry. This parameter mirrors the 'a' parameter
 *                in the Python reference's `Image_map` function's internal calculations.
 * @return `ImageMapResult` A struct containing:
 *         - `miss`: An integer flag; 1 if the ray does not successfully intersect the `x_0_plane` (e.g., falls into the black hole, escapes to r_max, or hits x_stop prematurely). 0 if it successfully hits the `x_0_plane`.
 *         - `y_window`: The y-coordinate (radial distance in the 2D ray-tracing plane, `rho` in the paper's 2D context) where the ray actually intersects the `x_1_window` plane.
 *         - `y_image`: The y-coordinate (radial distance in the 2D ray-tracing plane) where the ray intersects the `x_0_plane` (source plane). This is the lensed mapping.
 *         - `error_code`: An integer; 0 for successful execution, non-zero for internal errors (e.g., memory allocation failure, problematic geometric inputs, or underlying trajectory computation errors).
 * @note This function assumes a Schwarzschild spacetime with a fixed mass M=1.0 (in geometric units) for these mapping calculations, consistent with the Python reference and test cases.
 * @note The initial photon direction `psi_calc` (corresponding to `\psi_0` in Schwarzschild_Lens_Paper.pdf) is derived from the observer's position, the window plane's location, and the (Y,Z) target point on the window. Specifically, `cos(-\psi_0) = \rho / \sqrt{\rho^2 + (x_2 - x_1)^2}` (derived from paper, Eq. (4) and Figure 2 discussion). The negative sign for `acos` aligns with the Python reference's convention for reverse tracing.
 * @see `compute_trajectory_crossings_only`
 */
ImageMapResult image_map(
    double Y, double Z, double x_0_plane, double x_1_window, double x_2_observer, double a_scale,
    bool force_log_this_ray_in_core // <<<< NEW PARAMETER for passing the logging flag
) {
    ImageMapResult im_result = { .miss = 1, .y_window = NAN, .y_image = NAN, .error_code = 0 };

    // The black hole mass M is fixed to M=1.0 (geometric units) for these specific mapping functions,
    // consistent with the Python reference implementation for simplicity in these mappings.
    double M_mapping = 1.0; 

    double observer_window_diff = x_2_observer - x_1_window;
    double a_prime;
    if (fabs(observer_window_diff) < EPSILON_GENERAL) {
        a_prime = a_scale;
    } else {
        a_prime = ((x_2_observer - x_0_plane) / observer_window_diff) * a_scale;
    }

    double r_max_integration = sqrt(2.0 * a_prime * a_prime + x_0_plane * x_0_plane);
    if (r_max_integration < (2.0 * M_mapping + 100.0)) {
        r_max_integration = (2.0 * M_mapping + 100.0);
    }
    if (r_max_integration < x_2_observer + 10.0) { 
         r_max_integration = x_2_observer + 10.0;
    }

    double rho_sq = Y * Y + Z * Z;
    // double r_rho_debug = sqrt(rho_sq); // Kept for your existing debug print below

    double observer_to_window_dist_sq_on_plane = observer_window_diff * observer_window_diff + rho_sq;

    if (observer_to_window_dist_sq_on_plane <= EPSILON_GENERAL) { 
        im_result.error_code = 1; 
        return im_result;
    }

    double arg_acos_numerator = sqrt(rho_sq); // rho, always non-negative
    double arg_acos_denominator = sqrt(observer_to_window_dist_sq_on_plane);
    double arg_acos_val;

    if (arg_acos_denominator < EPSILON_GENERAL * 1e-3) { // If denominator is extremely small
        if (arg_acos_numerator < EPSILON_GENERAL * 1e-3) { // And numerator is also extremely small (Y=0, Z=0, observer at window)
            arg_acos_val = 0.0; // Ray is along the x-axis, so rho/hypotenuse effectively -> 0 for angle with radial
                                // acos(0) = PI/2. So psi_calc = -PI/2 (radially inward from observer)
        } else {
            // Numerator is non-zero, denominator is zero. This implies observer_window_diff is also zero.
            // This case should be caught by the observer_to_window_dist_sq_on_plane <= EPSILON_GENERAL check.
            // If it ever gets here, it's a division by zero potential.
            // However, the prior check should make this branch unlikely.
            // For safety, if denominator is ~0 and numerator isn't, arg_acos would be large.
            // fmax/fmin will clamp it.
            arg_acos_val = arg_acos_numerator / arg_acos_denominator; // Could be Inf/large
        }
    } else {
        arg_acos_val = arg_acos_numerator / arg_acos_denominator;
    }
    
    arg_acos_val = fmax(-1.0, fmin(1.0, arg_acos_val));
    double psi_calc = -acos(arg_acos_val); 

    gsl_vector *x_targets_map = gsl_vector_alloc(2);
    if (!x_targets_map) {
        im_result.error_code = -1; 
        return im_result;
    }
    gsl_vector_set(x_targets_map, 0, x_0_plane);  
    gsl_vector_set(x_targets_map, 1, x_1_window); 

    double x_stop_map = x_0_plane - 1.0; 
    bool x_stop_active_for_this_call = true; 

    // <<<< MODIFIED CALL: Pass the force_log_this_ray_in_core flag >>>>
    TrajectoryCrossings *crossings = compute_trajectory_crossings_only(
        x_2_observer, 0.0, M_mapping, psi_calc, r_max_integration,
        x_stop_map, x_stop_active_for_this_call, 
        x_targets_map, DEFAULT_T_END,
        force_log_this_ray_in_core // Pass the flag
    );

    gsl_vector_free(x_targets_map); 

    if (!crossings) {
        im_result.error_code = -1; 
        return im_result;
    }
    if (crossings->error_code != 0) {
        im_result.error_code = crossings->error_code; 
        free_trajectory_crossings(crossings); 
        return im_result;
    }

    if (crossings->num_x_targets == 2 && 
        crossings->crossings_y_at_x_targets && 
        crossings->crossings_y_at_x_targets[0] && crossings->crossings_y_at_x_targets[0]->size > 0 && 
        crossings->crossings_y_at_x_targets[1] && crossings->crossings_y_at_x_targets[1]->size > 0) { 
        
        im_result.y_image = gsl_vector_get(crossings->crossings_y_at_x_targets[0], 0); 
        im_result.y_window = gsl_vector_get(crossings->crossings_y_at_x_targets[1], 0); 
        im_result.miss = 0; 
    } else {
        im_result.miss = 1; 
    }

    // Your existing debug print for r_rho ~ 0.31 (uses r_rho_debug which is sqrt(Y*Y+Z*Z))
    double r_rho_for_debug = sqrt(Y*Y + Z*Z); // Calculate it if needed for the condition
    if (fabs(r_rho_for_debug - 0.31) < 0.001 && fabs(Z) < EPSILON_GENERAL) {
        fprintf(stderr, "C_IMG_MAP_DEBUG (Y~%.2f, Z~%.2f => r_rho~0.31): FINAL ImageMapResult: miss=%d, y_window=%.17e, y_image=%.17e, error_code=%d\n",
                Y, Z, im_result.miss, im_result.y_window, im_result.y_image, im_result.error_code);
     }

    free_trajectory_crossings(crossings); 
    return im_result;
}

/**
 * @brief A specialized version of `image_map` for rays originating with Z=0 (i.e., purely in the Y-X plane initially).
 *
 * This function simplifies the input to a single radial distance `r_rho` on the observer's
 * window plane (effectively setting `Y = r_rho` and `Z = 0.0`). It acts as a convenience
 * wrapper for axially symmetric scenarios often encountered in lensing problems, where
 * the initial ray's offset from the x-axis (`rho`) is the primary variable, and Z-components
 * are symmetric.
 * The input `r_rho` corresponds to `\rho` as defined in Eq. (9) of Schwarzschild_Lens_Paper.pdf.
 *
 * @param r_rho The radial distance `\rho` on the observer's window plane from the x-axis.
 *              This is equivalent to the Y-coordinate if Z is assumed to be 0. Units are in simulation units.
 * @param x_0_plane The x-coordinate of the background source image plane.
 * @param x_1_window The x-coordinate of the observer's virtual window plane.
 * @param x_2_observer The x-coordinate of the observer.
 * @param a_scale_factor A scaling factor, playing the same role as `a_scale` in `image_map`,
 *                       used in calculating `r_max_integration`.
 * @return `ImageMapResult` A struct containing hit status and mapped y-coordinates, identical
 *         to the return value of `image_map`.
 * @see image_map
 */

// In image_mapping_utils.c

ImageMapResult image_map_radial(
    double r_rho, double x_0_plane, double x_1_window, double x_2_observer, double a_scale_factor) {
    
    ImageMapResult im_result_early_exit = { .miss = 1, .y_window = NAN, .y_image = NAN, .error_code = 1 };
    double M_mapping = 1.0; 
    double observer_window_diff = x_2_observer - x_1_window;
    double a_prime;

    if (fabs(observer_window_diff) < EPSILON_GENERAL) {
        a_prime = a_scale_factor;
    } else {
        a_prime = ((x_2_observer - x_0_plane) / observer_window_diff) * a_scale_factor;
    }

    double r_max_integration = sqrt(2.0 * a_prime * a_prime + x_0_plane * x_0_plane);
    if (r_max_integration < (2.0 * M_mapping + 100.0)) {
        r_max_integration = (2.0 * M_mapping + 100.0);
    }
    if (r_max_integration < x_2_observer + 10.0) { 
         r_max_integration = x_2_observer + 10.0;
    }

    double rho_sq = r_rho * r_rho; // Since Z=0 for image_map_radial, Y is r_rho
    double observer_to_window_dist_sq_on_plane = observer_window_diff * observer_window_diff + rho_sq;

    if (observer_to_window_dist_sq_on_plane <= EPSILON_GENERAL) { 
        return im_result_early_exit;
    }

    double arg_acos_numerator = r_rho; // Assuming r_rho >= 0
    double arg_acos_denominator = sqrt(observer_to_window_dist_sq_on_plane);
    double arg_acos_val;

    if (arg_acos_denominator < EPSILON_GENERAL * 1e-3) {
        if (fabs(arg_acos_numerator) < EPSILON_GENERAL * 1e-3) { // r_rho is also zero
            arg_acos_val = 0.0; // Results in psi_calc = -acos(0) = -PI/2 (ray along x-axis)
        } else { 
            // This case (denominator near zero, numerator non-zero) should ideally be caught by the
            // observer_to_window_dist_sq_on_plane check. If not, fmax/fmin will clamp.
            arg_acos_val = arg_acos_numerator / arg_acos_denominator;
        }
    } else {
        arg_acos_val = arg_acos_numerator / arg_acos_denominator;
    }
    
    arg_acos_val = fmax(-1.0, fmin(1.0, arg_acos_val)); 
    double psi_calc = -acos(arg_acos_val); 

    // ++++ NEW LOGIC BLOCK START ++++
    bool should_log_this_ray_in_core = false; 
    
    const double C_FIRST_HIT_R_RHO_TARGET_FOR_LOGGING = 2.99999999999999989e-01; 
    const double TARGET_X0_FOR_LOGGING = -10.0;
    const double TARGET_X1_FOR_LOGGING = 19.0;
    const double TARGET_X2_FOR_LOGGING = 20.0;
    // Also check a_scale_factor if it's part of defining the unique target ray scenario
    // For now, assuming the x_planes and r_rho are primary identifiers from Results_Radial calls
    
    if (fabs(r_rho - C_FIRST_HIT_R_RHO_TARGET_FOR_LOGGING) < 1e-12 &&
        fabs(x_0_plane - TARGET_X0_FOR_LOGGING) < EPSILON_GENERAL &&
        fabs(x_1_window - TARGET_X1_FOR_LOGGING) < EPSILON_GENERAL &&
        fabs(x_2_observer - TARGET_X2_FOR_LOGGING) < EPSILON_GENERAL) {
        
        fprintf(stderr, "C_IMG_MAP_RADIAL_FLAG_SET (r_rho~%.2e): r_rho_input=%.17e, psi_calc=%.17e. Detailed logging in core ENABLED for this call.\n", 
                r_rho, r_rho, psi_calc);
        should_log_this_ray_in_core = true; 
    }
    // ++++ NEW LOGIC BLOCK END ++++
    
    // <<<< MODIFIED CALL to image_map >>>>
    // Pass r_rho as Y, 0.0 as Z, and the determined logging flag
    return image_map(r_rho, 0.0, x_0_plane, x_1_window, x_2_observer, a_scale_factor, should_log_this_ray_in_core);
}

#ifdef UNIT_TEST_IMAGE_MAPPING_UTILS
// This block contains a self-contained unit test for `image_mapping_utils.c`.
// It requires `trajectory_module.c` to be linked for `compute_trajectory_crossings_only`
// and relies on definitions provided in `schwarzschild_tracer.h`.

/**
 * @brief Main function for unit testing `image_mapping_utils.c`.
 *
 * This function performs a series of unit tests on the `image_map` and `image_map_radial`
 * functions. It covers:
 * 1.  A purely radial shot (Y=0, Z=0) to verify near-zero deflections, as expected for a ray starting on the optical axis.
 * 2.  A Cartesian shot with specific parameters that are known to produce distinct lensed results,
 *     verifying numerical accuracy against a reference outcome (e.g., from integration tests).
 * 3.  An edge case where the observer starts inside the event horizon (`r <= 2M`),
 *     testing error handling and termination conditions for such unphysical initial states.
 *
 * To compile and run this unit test (assuming a Makefile setup that includes `trajectory_module.o`):
 * `make test_image_mapping_utils`
 *
 * @return 0 on successful completion of all test cases (individual pass/fail printed to console).
 */
int main() {
    printf("--- Unit Test for image_mapping_utils ---\n");
    // Disable GSL's default error handler to prevent program termination on GSL errors.
    // This allows custom error checking and ensures the entire test suite runs even if
    // an underlying GSL operation encounters a non-fatal error.
    gsl_set_error_handler_off();

    // Test Case 1: Radial shot (Y=0, Z=0 or r_rho=0).
    // A ray launched directly along the observer's line of sight (x-axis).
    // Due to the axial symmetry of the setup and the Schwarzschild metric, this ray should
    // ideally remain on the x-axis, meaning `y_window` and `y_image` should be very close to 0.0.
    double x0_test1 = 3.0;     // Source plane x-coordinate (e.g., in front of BH).
    double x1_test1 = 10.0;    // Window plane x-coordinate.
    double x2_test1 = 20.0;    // Observer position x-coordinate.
    double a_scale_test1 = 1.0; // Scaling factor for `r_max_integration`.
    printf("Test 1: image_map_radial (r_rho=0)...\n");
    // Call to image_map_radial's signature is UNCHANGED from the outside for the unit test.
    // It internally decides if 'force_log_this_ray_in_core' should be true or false
    // when it calls image_map. For these unit test parameters, it will be false.
    ImageMapResult res_radial = image_map_radial(0.0, x0_test1, x1_test1, x2_test1, a_scale_test1);
    if (res_radial.error_code == 0 && !res_radial.miss) {
        printf("  HIT: y_window=%.6e, y_image=%.6e\n", res_radial.y_window, res_radial.y_image);
        // Check if results are near zero, within a small tolerance.
        if (fabs(res_radial.y_window) < 1e-6 && fabs(res_radial.y_image) < 1e-6) {
            printf("  Test 1 PASSED.\n");
        } else {
            printf("  Test 1 FAILED: Expected y_window and y_image near 0 for radial shot.\n");
        }
    } else {
        printf("  Test 1 FAILED: Miss or error_code %d.\n", res_radial.error_code);
    }

    // Test Case 2: Cartesian shot with specific parameters.
    // These parameters are chosen to match a known working scenario from integration tests (e.g., `main_test.c`),
    // providing a regression check and verifying consistency in lensing calculations.
    double x0_test2 = -10.0;   // Source plane far behind the black hole.
    double x1_test2 = 19.0;    // Window plane closer to the observer.
    double x2_test2 = 20.0;    // Observer position.
    double Y_test2 = 0.5;      // Y-offset on the observer's window plane.
    double Z_test2 = 0.0;      // Z-coordinate set to 0.0 to keep the ray in the X-Y plane (simpler visualization).
    double a_scale_test2 = 1.0; // Scaling factor.
    printf("Test 2: image_map (Y=0.5, Z=0)...\n");
    // <<<< MODIFIED CALL to image_map: Added 'false' for the new boolean flag >>>>
    ImageMapResult res_cart = image_map(Y_test2, Z_test2, x0_test2, x1_test2, x2_test2, a_scale_test2, false);
     if (res_cart.error_code == 0 && !res_cart.miss) {
        printf("  HIT: y_window=%.4f, y_image=%.4f\n", res_cart.y_window, res_cart.y_image);
        if (fabs(res_cart.y_window - 0.5264) < 1e-3 && fabs(res_cart.y_image - 7.8063) < 1e-3) {
             printf("  Test 2 PASSED (matches expected values).\n");
        } else {
             printf("  Test 2 FAILED: Values deviate from expected (y_w_exp=0.5264, y_i_exp=7.8063).\n");
        }
    } else {
        printf("  Test 2 FAILED: Miss or error_code %d.\n", res_cart.error_code);
    }

    // Test Case 3: Observer starting inside the event horizon (r_observer <= 2M).
    printf("Test 3: image_map (observer at x=1.0, M=1.0)...\n");
    // <<<< MODIFIED CALL to image_map: Added 'false' for the new boolean flag >>>>
    ImageMapResult res_inside = image_map(0.0, 0.0, -10.0, 5.0, 1.0, 1.0, false);
    if (res_inside.miss == 1 && res_inside.error_code == 0) { // Error code can also be non-zero if geom error
        printf("  Test 3 PASSED (correctly reported as MISS or underlying error caught by trajectory func).\n");
    } else if (res_inside.error_code == 1) { // Specific geometric error code from image_map
         printf("  Test 3 PASSED (correctly reported as geometric error_code %d).\n", res_inside.error_code);
    }
    else {
        printf("  Test 3 FAILED: Expected miss or error for observer inside horizon (miss=%d, error_code=%d).\n", res_inside.miss, res_inside.error_code);
    }

    printf("--- Unit Test for image_mapping_utils Finished ---\n");
    return 0;
}
#endif // UNIT_TEST_IMAGE_MAPPING_UTILS

// image_mapping_utils.c
// Bottom

// Top
// Start of main_rhs_test.c

#include "schwarzschild_tracer.h" // Ensures ODEParams and schwarzschild_geodesic_eqs are available
#include <stdio.h>



static int schwarzschild_geodesic_eqs(double K, const double y_state[], double f_derivs[], void *params_ptr) {
    (void)K; // `K` is not explicitly used in these autonomous ODEs.
    ODEParams *params = (ODEParams *)params_ptr;
    double M = params->M;           // Black hole mass.
    double b = params->b;           // Photon's impact parameter.
    int sign_val = *(params->sign_dr_dk); // Current sign of `dr/dK` (+1 for outward, -1 for inward).
    double r = y_state[0];          // Current radial coordinate of the photon.

    // If the photon reaches or crosses the event horizon (`2M`), plus a small tolerance,
    // set derivatives to zero to effectively stop its motion and prevent numerical issues.
    // This models photon capture.
    if (r <= (2.0 * M + EVENT_DETECTION_TOLERANCE * 0.01)) { 
        f_derivs[0] = 0.0; // `dr/dK = 0` (no more radial motion).
        f_derivs[1] = 0.0; // `dphi/dK = 0` (no more angular motion if captured).
        return GSL_SUCCESS;
    }
    // Calculate the metric term `(1 - 2M/r)`, which becomes zero at the event horizon.
    double metric_term = (1.0 - 2.0 * M / r);
    // Clamp `metric_term` to `0.0` if it's slightly negative due to floating-point precision
    // when `r` is very close to `2M` from the outside (where it should be `0`).
    if (metric_term < 0 && r > 2.0 * M) { metric_term = 0.0; }

    // Calculate the `(b/r)^2` term.
    double term_b_r_sq = (b / r) * (b / r) ;
    // Calculate `fr_val`, which is `R(r)` or `(dr/dK)^2`, according to Eq. (5) of Schwarzschild_Lens_Paper.pdf.
    // `R(r) = 1 - (1 - 2M/r) * (b^2/r^2)`.
    double fr_val = 1.0 - metric_term * term_b_r_sq;

    // Clamp `fr_val` to `0.0` if it's slightly negative due to floating-point precision when
    // `r` is very close to a radial turning point (`R(r) = 0`). This prevents `sqrt` of negative.
    if (fr_val < 0) { fr_val = 0.0; }

    // Calculate `dr/dK = \sigma * \sqrt{R(r)}`, where `\sigma` is `sign_val`.
    f_derivs[0] = sign_val * sqrt(fr_val); 

    // Calculate `dphi/dK = b / r^2` (Eq. (7) of Schwarzschild_Lens_Paper.pdf).
    if (r < EPSILON_GENERAL) { // Defensive check to avoid division by zero if `r` is extremely small or zero.
        f_derivs[1] = 0.0; 
    }
    else { 
        f_derivs[1] = b / (r * r); 
    }
    return GSL_SUCCESS;
}

int main() {
    ODEParams params;
    int sign_dr_dk_val;
    double y_state[2];
    double f_derivs[2];

    // Test Case 1: Initial state for r_rho=0.3
    params.M = 1.0;
    params.b = 6.05782532815382613e+00; // Python's b_calc
    sign_dr_dk_val = -1;               // Python's initial sign
    params.sign_dr_dk = &sign_dr_dk_val;
    y_state[0] = 20.0;                 // r_0
    y_state[1] = 0.0;                  // phi_0

    schwarzschild_geodesic_eqs(0.0, y_state, f_derivs, &params);
    printf("C Test Case 1 (r_rho=0.3 initial):\n");
    printf("  dr/dK: %.17e\n", f_derivs[0]);
    printf("  dphi/dK: %.17e\n", f_derivs[1]);

    // Test Case 2: A point near a turning point (hypothetical)
    // For psi = -1.279..., b = 6.057...
    // R(r) = 1 - (1-2/r)*b^2/r^2. Turning point is R(r)=0.
    // If r=4.52533748 (from Python's fr_zero event for r_rho=0.3)
    // Let's test slightly away from it, assuming sign flips.
    params.M = 1.0;
    params.b = 6.05782532815382613e+00;
    sign_dr_dk_val = 1; // Say, moving outward after turning
    params.sign_dr_dk = &sign_dr_dk_val;
    y_state[0] = 4.52533748 + 1e-5; // r slightly after turning point
    y_state[1] = 2.09564856;       // phi at turning point (from Python debug)
    
    schwarzschild_geodesic_eqs(21.24196959, y_state, f_derivs, &params); // K at turning point
    printf("C Test Case 2 (near turning point for r_rho=0.3):\n");
    printf("  r: %.17e, phi: %.17e\n", y_state[0], y_state[1]);
    printf("  dr/dK: %.17e\n", f_derivs[0]);
    printf("  dphi/dK: %.17e\n", f_derivs[1]);

    return 0;
}

// End of main_rhs_test.c
//Bottom

// main_test.c (for generating the lensed rainbow image)
#include "schwarzschild_tracer.h" // Your main header
#include <stdio.h>
#include <stdlib.h>
#include <string.h> // For strcmp if you add command-line parsing later

int main(int argc, char *argv[]) {
    gsl_set_error_handler_off(); // Good practice

    // --- Parameters for results_radial (Photon Data Generation) ---
    // These should be chosen to adequately sample the space for good rendering.
    // The R_max_sample_gen should relate to how large your lensing features are expected to be
    // on the observer's window, given your source_logical_width_map.
    double x0_gen = -10.0;           // Source plane X-coordinate
    double x1_gen = 19.0;            // Observer's window plane X-coordinate
    double x2_gen = 20.0;            // Observer's position X-coordinate
    
    // R_max_sample_gen: This is the max radius on the observer's window that results_radial samples.
    // It needs to be large enough to capture rays that will map to the edges of your
    // source_logical_width_map after lensing. This might require some experimentation
    // or a more sophisticated calculation based on expected magnification.
    // Let's start with a reasonable value; you might need to adjust this.
    // If your source_logical_width_map is 25, and it's far away, the lensed region on your
    // window might still be relatively small, or quite large if strongly lensed.
    // A value like 2.0 to 5.0 might be a starting point for R_max_sample_gen.
    // If using Mode A for map_photons, map_photons will auto-crop, but good data is still needed.
    double R_max_sample_gen = 1.0;      // Max radial distance to sample on observer's window by results_radial
    int    n_param_gen = 300;           // Number of radial divisions for sampling (higher for better quality)
    size_t chunk_size_gen = 2000000;    // Number of PhotonMapDataPoints per .bin chunk file

    fprintf(stderr, "C_IMAGE_GEN: Generating photon mapping data via results_radial (expecting .bin files)...\n");
    fprintf(stderr, "C_IMAGE_GEN: Parameters for results_radial: x0=%.1f, x1=%.1f, x2=%.1f, R_max_sample=%.1f, n=%d, chunk_size=%zu\n",
           x0_gen, x1_gen, x2_gen, R_max_sample_gen, n_param_gen, chunk_size_gen);

    char **generated_chunk_files = NULL;
    int num_generated_chunks = 0;
    
    // This call to results_radial MUST save .bin files to disk
    // AND fill generated_chunk_files with their names, and num_generated_chunks with the count.
    generated_chunk_files = results_radial(
        x0_gen, x1_gen, x2_gen, 
        R_max_sample_gen, n_param_gen, 
        chunk_size_gen, &num_generated_chunks 
    );

    if (num_generated_chunks > 0 && generated_chunk_files != NULL && generated_chunk_files[0] != NULL) {
        fprintf(stderr, "C_IMAGE_GEN: Successfully generated %d photon data chunk file(s).\n", num_generated_chunks);
        fprintf(stderr, "C_IMAGE_GEN: First chunk file: %s\n", generated_chunk_files[0]);
        
        // --- Parameters for map_photons (Image Rendering) ---
        const char* source_image_path_map = "rainbow.ppm"; // YOUR FILENAME
        const char* output_image_path_map = "c_lensed_rainbow.ppm";
        double source_logical_width_map = 25.0;    // YOUR SPECIFIED LOGICAL WIDTH
        int target_output_pixel_width_map = 512;   // Example output pixel width (can be adjusted)
        
        // For Mode A (Full View), observer_window_bounds is NULL.
        // map_photons will determine the bounds from the photon data.
        const double *observer_window_bounds_map = NULL; 
        RGBColor default_color_map = {0, 0, 0}; // Black background for unhit pixels

        // Check if the source rainbow image exists before attempting to map
        FILE *fp_check_rainbow = fopen(source_image_path_map, "rb"); // "rb" for binary read check
        if (fp_check_rainbow == NULL) {
            fprintf(stderr, "C_IMAGE_GEN ERROR: Source image '%s' not found! Cannot run map_photons.\n", source_image_path_map);
            // Clean up generated chunk files before exiting if source image is missing
            if (generated_chunk_files) {
                free_string_array(generated_chunk_files, num_generated_chunks);
            }
            return 1; // Indicate error
        }
        fclose(fp_check_rainbow);

        fprintf(stderr, "C_IMAGE_GEN: Calling map_photons to render lensed image...\n");
        fprintf(stderr, "C_IMAGE_GEN:   Source Image: %s\n", source_image_path_map);
        fprintf(stderr, "C_IMAGE_GEN:   Output Image: %s\n", output_image_path_map);
        fprintf(stderr, "C_IMAGE_GEN:   Source Logical Width: %.2f\n", source_logical_width_map);
        fprintf(stderr, "C_IMAGE_GEN:   Target Output Pixel Width: %d\n", target_output_pixel_width_map);
        fprintf(stderr, "C_IMAGE_GEN:   Observer Window Mode: %s\n", observer_window_bounds_map == NULL ? "Mode A (Full View)" : "Mode B (Specified Bounds)");
        
        int map_status = map_photons(
            source_image_path_map,
            NULL, // image_source_data_param (loading from path, not pre-loaded struct)
            generated_chunk_files,
            num_generated_chunks, // Pass the actual count
            output_image_path_map,
            source_logical_width_map,
            target_output_pixel_width_map,
            observer_window_bounds_map,
            default_color_map
        );

        if (map_status == 0) {
            fprintf(stderr, "C_IMAGE_GEN: map_photons successful. Output image: %s\n", output_image_path_map);
        } else {
            fprintf(stderr, "C_IMAGE_GEN: map_photons FAILED with status: %d\n", map_status);
        }
        
    } else {
        fprintf(stderr, "C_IMAGE_GEN: No photon data chunk files were generated by results_radial, or file list was empty. Skipping map_photons.\n");
        if (generated_chunk_files == NULL && num_generated_chunks > 0) {
             fprintf(stderr, "C_IMAGE_GEN: Warning - num_generated_chunks is %d but generated_chunk_files is NULL.\n", num_generated_chunks);
        }
         if (generated_chunk_files != NULL && num_generated_chunks > 0 && generated_chunk_files[0] == NULL) {
             fprintf(stderr, "C_IMAGE_GEN: Warning - num_generated_chunks is %d but first element of generated_chunk_files is NULL.\n", num_generated_chunks);
        }
    }

    // Cleanup generated chunk files list
    if (generated_chunk_files) {
        // Ensure free_string_array correctly handles the number of elements.
        // If results_radial sets num_generated_chunks correctly, use it.
        // If results_radial relies on NULL termination, ensure the last element is NULL
        // and pass -1 or the actual count to free_string_array.
        // Assuming results_radial correctly sets num_generated_chunks and the list is not necessarily NULL terminated by results_radial itself.
        free_string_array(generated_chunk_files, num_generated_chunks);
    }

    fprintf(stderr, "C_IMAGE_GEN: main_test.c (image generation mode) finished.\n");
    return 0;
}

// Top
// main_trajectory_debug.c
// (Purpose: Run a single, specific trajectory and two PSI-perturbed versions,
//  relying on printf statements within trajectory_module.c to output key data)

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include "schwarzschild_tracer.h"

// Helper function (signature unchanged, but how it's called will change)
void run_and_print_trajectory_info(
    const char* label,
    double r_0_obs, double phi_0_photon, double M_bh_val, double psi_photon, // psi_photon will be varied
    double r_max_calc, double x_stop_val_calc, const gsl_vector* x_targets_calc,
    int num_interp_pts_calc,
    double* out_y_image) {

    printf("\\n--- Running Trajectory: %s ---\\n", label);
    fprintf(stderr, "C_MAIN_TRAJ_DEBUG (%s): r0=%.2f, phi0=%.17e, M=%.2f, psi=%.17e\\n",
            label, r_0_obs, phi_0_photon, M_bh_val, psi_photon); // Log the psi being used
    fprintf(stderr, "C_MAIN_TRAJ_DEBUG (%s): r_max=%.17e, x_stop=%.2f (active=1), num_interp_pts=%d\\n",
            label, r_max_calc, x_stop_val_calc, num_interp_pts_calc);
    fflush(stderr);

    printf("PHOTON_RUN_START LABEL %s PHI0_PHOTON %.17e PSI_PHOTON %.17e\\n", label, phi_0_photon, psi_photon);
    fflush(stdout);

    PhotonTrajectory *traj = compute_trajectory(
        r_0_obs,
        phi_0_photon, // Kept constant for this test
        M_bh_val,
        psi_photon,   // PSI is being varied
        r_max_calc,
        x_stop_val_calc,
        true,
        x_targets_calc,
        DEFAULT_T_END,
        num_interp_pts_calc
    );

    if (out_y_image) {
        *out_y_image = NAN;
    }

    if (!traj) {
        fprintf(stderr, "C_MAIN_TRAJ_DEBUG (%s): compute_trajectory returned NULL.\\n", label);
        return;
    }
    if (traj->error_code != 0) {
        fprintf(stderr, "C_MAIN_TRAJ_DEBUG (%s): compute_trajectory error_code: %d\\n", label, traj->error_code);
    }
    if (traj->K == NULL || traj->K->size == 0) {
        fprintf(stderr, "C_MAIN_TRAJ_DEBUG (%s): Trajectory K vector is NULL or empty (error_code %d).\\n", label, traj->error_code);
    }

    if (x_targets_calc && traj->crossings_y_at_x_targets) {
        if (traj->num_x_targets == x_targets_calc->size) {
            if (traj->num_x_targets >= 1 && traj->crossings_y_at_x_targets[0] && traj->crossings_y_at_x_targets[0]->size > 0) {
                double y_img_val = gsl_vector_get(traj->crossings_y_at_x_targets[0], 0);
                fprintf(stderr, "C_MAIN_TRAJ_DEBUG (%s) (from struct): Crossing x0 (Source Plane, x=%.2f), y_image = %.17e\\n",
                        label, gsl_vector_get(x_targets_calc, 0), y_img_val);
                if (out_y_image) {
                    *out_y_image = y_img_val;
                }
            } else {
                fprintf(stderr, "C_MAIN_TRAJ_DEBUG (%s) (from struct): No y_image at x0 for this run.\\n", label);
            }
            if (traj->num_x_targets >= 2 && traj->crossings_y_at_x_targets[1] && traj->crossings_y_at_x_targets[1]->size > 0) {
                fprintf(stderr, "C_MAIN_TRAJ_DEBUG (%s) (from struct): Crossing x1 (Window Plane, x=%.2f), y_window = %.17e\\n",
                        label, gsl_vector_get(x_targets_calc, 1), gsl_vector_get(traj->crossings_y_at_x_targets[1], 0));
            } else {
                 fprintf(stderr, "C_MAIN_TRAJ_DEBUG (%s) (from struct): No y_window at x1 for this run.\\n", label);
            }
        }
    }
    fflush(stderr);
    printf("PHOTON_RUN_END LABEL %s\\n", label);
    fflush(stdout);
    free_photon_trajectory(traj);
}

int main(int argc, char *argv[]) {
    (void)argc;
    (void)argv;
    gsl_set_error_handler_off();

    double x0_plane = -10.0;
    double x1_window = 19.0;
    double x2_observer = 20.0;
    double M_bh = 1.0;

    // --- Base psi and perturbation ---
    double psi_base = -1.27933953231702957e+00; // The psi for r_rho ~ 0.3
    double epsilon_psi_perturb = 1.0e-13; // Perturbation factor

    // Perturb psi by multiplying by (1 +/- epsilon)
    // If psi_base is very close to 0, this might not be the best way to perturb.
    // However, for psi ~ -1.27, multiplying is fine.
    // If psi_base could be 0, you might want: psi_base +/- epsilon_psi_perturb (absolute change)
    double psi_plus_eps, psi_minus_eps;

    if (fabs(psi_base) < 1e-15) { // If psi_base is essentially zero
        psi_plus_eps  = psi_base + epsilon_psi_perturb; // Add absolute epsilon
        psi_minus_eps = psi_base - epsilon_psi_perturb; // Subtract absolute epsilon
         fprintf(stderr, "C_MAIN_TRAJ_DEBUG: psi_base is near zero, perturbing by adding/subtracting epsilon_psi_perturb.\n");
    } else {
        psi_plus_eps  = psi_base * (1.0 + epsilon_psi_perturb); // Relative perturbation
        psi_minus_eps = psi_base * (1.0 - epsilon_psi_perturb); // Relative perturbation
    }
    
    double common_phi_0 = 0.0; // Initial phi_0 is kept constant for this test

    fprintf(stderr, "C_MAIN_TRAJ_DEBUG: Executing PSI perturbation test.\\n");
    fprintf(stderr, "C_MAIN_TRAJ_DEBUG: Base psi: %.17e\\n", psi_base);
    fprintf(stderr, "C_MAIN_TRAJ_DEBUG: Perturbed psi (+eps): %.17e\\n", psi_plus_eps);
    fprintf(stderr, "C_MAIN_TRAJ_DEBUG: Perturbed psi (-eps): %.17e\\n", psi_minus_eps);
    fprintf(stderr, "C_MAIN_TRAJ_DEBUG: Common phi_0: %.17e\\n", common_phi_0);

    double r_max_traj;
    double a_scale_param_for_map = 1.0 * (x2_observer - x1_window);
    if (fabs(a_scale_param_for_map) < EPSILON_GENERAL) a_scale_param_for_map = 1.0;
    double observer_window_diff_calc = x2_observer - x1_window;
    double a_prime_traj;
    if (fabs(observer_window_diff_calc) < EPSILON_GENERAL) a_prime_traj = a_scale_param_for_map;
    else a_prime_traj = ((x2_observer - x0_plane) / observer_window_diff_calc) * a_scale_param_for_map;
    r_max_traj = sqrt(2.0 * a_prime_traj * a_prime_traj + x0_plane * x0_plane);
    if (r_max_traj < (2.0 * M_bh + 100.0)) r_max_traj = (2.0 * M_bh + 100.0);
    if (r_max_traj < x2_observer + 10.0) r_max_traj = x2_observer + 10.0;
    fprintf(stderr, "C_MAIN_TRAJ_DEBUG: Common r_max_traj = %.17e\\n", r_max_traj);

    double x_stop_val_traj = x0_plane - 1.0;

    gsl_vector *x_targets_traj = gsl_vector_alloc(2);
    if (!x_targets_traj) { perror("C_MAIN_TRAJ_DEBUG: Failed to allocate x_targets_traj"); return 1; }
    gsl_vector_set(x_targets_traj, 0, x0_plane);
    gsl_vector_set(x_targets_traj, 1, x1_window);

    int num_interp_points_traj = 500;

    double y_image_base, y_image_plus, y_image_minus;

    run_and_print_trajectory_info("BasePsiPhoton",
                                  x2_observer, common_phi_0, M_bh, psi_base, // Use psi_base
                                  r_max_traj, x_stop_val_traj, x_targets_traj,
                                  num_interp_points_traj, &y_image_base);

    run_and_print_trajectory_info("PlusEpsilonPsiPhoton",
                                  x2_observer, common_phi_0, M_bh, psi_plus_eps, // Use psi_plus_eps
                                  r_max_traj, x_stop_val_traj, x_targets_traj,
                                  num_interp_points_traj, &y_image_plus);

    run_and_print_trajectory_info("MinusEpsilonPsiPhoton",
                                  x2_observer, common_phi_0, M_bh, psi_minus_eps, // Use psi_minus_eps
                                  r_max_traj, x_stop_val_traj, x_targets_traj,
                                  num_interp_points_traj, &y_image_minus);

    printf("\\n--- Y_Image (Background Plane) PSI Perturbation Comparison ---\\n");
    fprintf(stderr, "PSI Perturbation Test y_image results (from struct data):\n");
    fprintf(stderr, "  y_image (Base Psi=%.2e):      %.17e\n", psi_base, y_image_base);
    fprintf(stderr, "  y_image (Psi +eps=%.2e):   %.17e\n", psi_plus_eps, y_image_plus);
    fprintf(stderr, "  y_image (Psi -eps=%.2e):  %.17e\n", psi_minus_eps, y_image_minus);

    if (!isnan(y_image_base) && !isnan(y_image_plus)) {
        double diff_plus = fabs(y_image_plus - y_image_base);
        fprintf(stderr, "  |y_image_plus_psi - y_image_base_psi|:      %.17e\n", diff_plus);
    } else {
        fprintf(stderr, "  Cannot calculate diff for y_image_plus_psi (NaN involved).\n");
    }
    if (!isnan(y_image_base) && !isnan(y_image_minus)) {
        double diff_minus = fabs(y_image_minus - y_image_base);
        fprintf(stderr, "  |y_image_minus_psi - y_image_base_psi|:     %.17e\n", diff_minus);
    } else {
        fprintf(stderr, "  Cannot calculate diff for y_image_minus_psi (NaN involved).\n");
    }
    fflush(stderr);

    gsl_vector_free(x_targets_traj);
    fprintf(stderr, "C_MAIN_TRAJ_DEBUG: Finished PSI perturbation test execution.\\n");
    printf("C_MAIN_FINISHED\\n");
    fflush(stdout);
    return 0;
}

// End of main_trajectory_debug.c
// Bottom

// photon_chunk_io.c
// Top
/**
 * @file photon_chunk_io.c
 * @brief Implements functions for saving and loading photon mapping data in binary chunks.
 *
 * This module provides utilities to serialize (`save_photon_data_chunk`) and deserialize
 * (`load_photon_data_chunk`) collections of `PhotonMapDataPoint` structures to/from binary files.
 * This chunk-based approach is crucial for managing potentially very large datasets generated
 * by ray tracing (e.g., by `results_generation.c`), allowing them to be processed and stored
 * efficiently in smaller, manageable files for use by `photon_rendering.c`.
 *
 * The binary file format is a simple header-data structure:
 * 1. A `uint32_t` integer indicating the number of `PhotonMapDataPoint` structures that follow.
 * 2. An array of `PhotonMapDataPoint` structures, written directly as raw binary data.
 *
 * @dependencies schwarzschild_tracer.h (for `PhotonMapDataPoint` struct and common includes like `stdio.h`, `stdlib.h`, `stdint.h`).
 */

#define _POSIX_C_SOURCE 200809L // Defines features from POSIX.1-2008 standard (e.g., `strdup` if used, or for general library compatibility).
#include "schwarzschild_tracer.h" // Includes `PhotonMapDataPoint` struct, `stdio.h`, `stdlib.h`, `stdint.h`, etc.

// --- Chunk I/O (Binary) ---

/**
 * @brief Saves an array of `PhotonMapDataPoint` structures to a binary file.
 *
 * The output file format is:
 * - A `uint32_t` representing the count of data points in this chunk.
 * - Followed by the raw binary data of `num_points` `PhotonMapDataPoint` structures.
 *
 * @param filename The path to the output binary file to be created or overwritten.
 * @param data A pointer to the array of `PhotonMapDataPoint` structures to be saved.
 *             This can be `NULL` if `num_points` is 0 (for saving an empty chunk).
 * @param num_points The number of `PhotonMapDataPoint` structures present in the `data` array.
 * @return `int` 0 on success.
 * @return -1 on a general file I/O error (e.g., `fopen`, `fwrite`, `fclose` failure). `perror` is called for detailed error messages.
 * @return -2 if `num_points` exceeds the maximum value representable by `uint32_t` (UINT32_MAX), indicating an overflow in the file format.
 * @return -3 if `num_points` is greater than 0 but `data` is a `NULL` pointer (invalid argument).
 * @note This function ensures data integrity by checking for `num_points` overflow and `NULL` data pointers when data is expected.
 */
int save_photon_data_chunk(const char *filename, const PhotonMapDataPoint* data, size_t num_points) {
    FILE *fp = fopen(filename, "wb"); // Open the file in binary write mode.
    if (!fp) {
        perror("save_photon_data_chunk: fopen failed"); // Report file opening error.
        return -1;
    }

    // Check if `num_points` exceeds the `uint32_t` maximum, as this is the format for the count in the file.
    if (num_points > UINT32_MAX) {
        fprintf(stderr, "save_photon_data_chunk: num_points (%zu) exceeds uint32_t max (%u). Aborting save.\n", num_points, UINT32_MAX);
        fclose(fp); // Close the file before returning.
        return -2; // Indicate overflow error.
    }
    uint32_t num_points_u32 = (uint32_t)num_points; // Cast to `uint32_t` for writing.

    // Write the count of data points to the file.
    if (fwrite(&num_points_u32, sizeof(uint32_t), 1, fp) != 1) {
        perror("save_photon_data_chunk: fwrite num_points failed");
        fclose(fp);
        return -1;
    }

    // If there are data points to write, write them to the file.
    if (num_points > 0) { 
        if (!data) { // Critical safety check: if `num_points` > 0, `data` should not be `NULL`.
            fprintf(stderr, "save_photon_data_chunk: num_points > 0 but data is NULL. Invalid argument.\n");
            fclose(fp);
            return -3; // Indicate invalid argument.
        }
        // Write the array of `PhotonMapDataPoint` structures.
        if (fwrite(data, sizeof(PhotonMapDataPoint), num_points, fp) != num_points) {
            perror("save_photon_data_chunk: fwrite data points failed or incomplete write");
            fclose(fp);
            return -1;
        }
    }

    // Close the file. A non-zero return value from `fclose` indicates an error (e.g., flush failure).
    if (fclose(fp) != 0) {
        perror("save_photon_data_chunk: fclose failed");
        return -1; 
    }
    return 0; // Success.
}

/**
 * @brief Loads `PhotonMapDataPoint` structures from a binary file.
 *
 * This function expects the file to have been previously saved by `save_photon_data_chunk`
 * and adhere to its specific binary format (uint32_t count followed by data).
 * Memory for the loaded data points is dynamically allocated by this function.
 *
 * @param filename The path to the input binary file to read from.
 * @param num_points_read An output parameter: a pointer to a `size_t` variable where the number of
 *                        `PhotonMapDataPoint` structures successfully read from the file
 *                        will be stored. It's initialized to 0 on failure or if the
 *                        file contains 0 points. This must not be a `NULL` pointer.
 * @return `PhotonMapDataPoint*` A pointer to a dynamically allocated array containing the read
 *                             `PhotonMapDataPoint` structures.
 *                             Returns `NULL` if the file indicates 0 points, or if any error occurs
 *                             (e.g., file not found, read error, memory allocation failure).
 *                             The caller is responsible for `free()`ing the returned array.
 * @note `perror` is called for system errors. If `fopen` fails (e.g., file not found), `perror` is called.
 */
PhotonMapDataPoint* load_photon_data_chunk(const char *filename, size_t *num_points_read) {
    if (!num_points_read) { // Validate the essential output parameter.
        fprintf(stderr, "load_photon_data_chunk: num_points_read pointer is NULL. Cannot store read count.\n");
        return NULL; 
    }
    *num_points_read = 0; // Initialize count to 0 in case of early exit or error.

    FILE *fp = fopen(filename, "rb"); // Open the file in binary read mode.
    if (!fp) {
        perror("load_photon_data_chunk: fopen failed"); // Report file opening error.
        return NULL;
    }

    uint32_t num_points_file; // Variable to store the count read from the file header.
    // Read the number of points from the file header.
    if (fread(&num_points_file, sizeof(uint32_t), 1, fp) != 1) {
        // Check for specific EOF condition vs. general read error.
        if (feof(fp)) {
             fprintf(stderr, "load_photon_data_chunk: Premature EOF reading num_points from %s. File might be too short or corrupted.\n", filename);
        } else {
            perror("load_photon_data_chunk: fread num_points failed");
        }
        fclose(fp); // Close the file on error.
        return NULL;
    }

    *num_points_read = (size_t)num_points_file; // Convert the `uint32_t` count to `size_t`.

    // If the file indicates 0 data points, return NULL as per function contract for empty chunks.
    if (*num_points_read == 0) {
        fclose(fp);
        return NULL; 
    }

    // Allocate memory for the data points based on the count read from the file.
    PhotonMapDataPoint *data = malloc(*num_points_read * sizeof(PhotonMapDataPoint));
    if (!data) {
        perror("load_photon_data_chunk: malloc failed for photon data"); // Report memory allocation failure.
        fclose(fp);
        *num_points_read = 0; // Reset count on allocation failure.
        return NULL;
    }

    // Read the actual array of `PhotonMapDataPoint` structures.
    if (fread(data, sizeof(PhotonMapDataPoint), *num_points_read, fp) != *num_points_read) {
        perror("load_photon_data_chunk: fread data points failed or short read"); // Report read error or incomplete read.
        free(data); // Free allocated memory on read failure.
        fclose(fp);
        *num_points_read = 0; // Reset count on read failure.
        return NULL;
    }

    // Close the file. A non-zero return value indicates an error (e.g., flush failure).
    if (fclose(fp) != 0) {
        perror("load_photon_data_chunk: fclose failed");
        // Data was successfully read, so we don't NULLify it here, but log the `fclose` error.
    }
    return data; // Return pointer to the loaded data (success).
}

/**
 * @brief Reads a binary photon data chunk from `filepath` and prints its raw content to stdout.
 *
 * This function is used to stream binary data out of a potentially sandboxed C program
 * directly to its standard output. It assumes the file at `filepath` exists and
 * was previously created by `save_photon_data_chunk` (though in the current strategy,
 * we're temporarily replacing file saving with direct stdout writing).
 *
 * @param filepath The path to the binary photon data chunk file to read. In the new
 *                 streaming strategy, this filepath parameter will become a dummy,
 *                 as the data will be generated in memory and immediately printed.
 *                 However, for the specific `--stream-photon-data` flag in `main_test.c`,
 *                 this function *would* try to read a file from the disk.
 * @param data A pointer to the array of `PhotonMapDataPoint` structures in memory.
 *             This is the actual data to be printed, bypassing disk read.
 * @param num_points The number of `PhotonMapDataPoint` structures in the `data` array.
 * @return `int` 0 on success, -1 on error.
 */
int print_photon_data_chunk_to_stdout_from_memory(const PhotonMapDataPoint* data, size_t num_points) {
    // Write the count of data points to stdout (same format as file header)
    if (num_points > UINT32_MAX) {
        fprintf(stderr, "print_photon_data_chunk_to_stdout_from_memory: num_points (%zu) exceeds uint32_t max (%u). Aborting stream.\n", num_points, UINT32_MAX);
        return -2; // Indicate overflow error.
    }
    uint32_t num_points_u32 = (uint32_t)num_points; // Cast to `uint32_t` for writing.

    if (fwrite(&num_points_u32, sizeof(uint32_t), 1, stdout) != 1) {
        perror("print_photon_data_chunk_to_stdout_from_memory: fwrite num_points to stdout failed");
        return -1;
    }

    // If there are data points to write, write them to stdout.
    if (num_points > 0) { 
        if (!data) { // Critical safety check: if `num_points` > 0, `data` should not be `NULL`.
            fprintf(stderr, "print_photon_data_chunk_to_stdout_from_memory: num_points > 0 but data is NULL. Invalid argument.\n");
            return -3; // Indicate invalid argument.
        }
        // Write the array of `PhotonMapDataPoint` structures to stdout.
        if (fwrite(data, sizeof(PhotonMapDataPoint), num_points, stdout) != num_points) {
            perror("print_photon_data_chunk_to_stdout_from_memory: fwrite data points to stdout failed or incomplete write");
            return -1;
        }
    }
    fflush(stdout); // CRUCIAL: Ensure all data is flushed immediately for Python to receive it.
    return 0; // Success.
}



#ifdef UNIT_TEST_CHUNK_IO
// This block contains a self-contained unit test for `photon_chunk_io.c`.
// It includes a helper function for comparing `PhotonMapDataPoint` structures.

#include <math.h> // For `fabs` in comparison helper.

/**
 * @brief Helper function to compare two `PhotonMapDataPoint` structures for approximate equality.
 *
 * This function is used in unit tests to verify that loaded data matches original data,
 * accounting for potential floating-point precision differences.
 *
 * @param p1 Pointer to the first `PhotonMapDataPoint`.
 * @param p2 Pointer to the second `PhotonMapDataPoint`.
 * @param tol The floating-point tolerance for comparison.
 * @return `int` 1 if all corresponding fields are within the specified tolerance, 0 otherwise.
 */
static int test_compare_photons(const PhotonMapDataPoint* p1, const PhotonMapDataPoint* p2, double tol) {
    return (fabs(p1->y_window_cart_x - p2->y_window_cart_x) < tol &&
            fabs(p1->y_window_cart_y - p2->y_window_cart_y) < tol &&
            fabs(p1->y_image_cart_x - p2->y_image_cart_x) < tol &&
            fabs(p1->y_image_cart_y - p2->y_image_cart_y) < tol);
}

/**
 * @brief Main function for unit testing `photon_chunk_io.c`.
 *
 * This function thoroughly tests the `save_photon_data_chunk` and `load_photon_data_chunk`
 * functions through various scenarios:
 * 1.  Saving and loading an array with multiple data points, verifying data integrity.
 * 2.  Saving and loading an empty array (0 points), ensuring proper handling of empty chunks.
 * 3.  Attempting to load a non-existent file, confirming robust error handling for file opening.
 * Temporary files are created and then deleted to keep the test environment clean.
 *
 * To compile and run this unit test (assuming Makefile setup):
 * `make test_photon_chunk_io`
 *
 * @return `int` 0 on successful completion of all test cases (individual pass/fail printed to console).
 */
int main() {
    printf("--- Unit Test for photon_chunk_io ---\n");
    const char* test_file = "test_chunk_io_temp.bin"; // Temporary file used for testing I/O.
    PhotonMapDataPoint *loaded_data;
    size_t num_loaded;

    // Test 1: Save and load an array of 3 `PhotonMapDataPoint`s.
    PhotonMapDataPoint original_data[3] = {
        {1.0, 2.0, 3.0, 4.0},        // Sample point 1: (win_x, win_y, img_x, img_y)
        {-1.0, -2.0, -3.0, -4.0},    // Sample point 2
        {0.5, -0.5, 10.5, -10.5}     // Sample point 3
    };
    printf("Test 1: Saving 3 points...\n");
    if (save_photon_data_chunk(test_file, original_data, 3) != 0) {
        printf("Test 1 FAILED: save_photon_data_chunk encountered an error.\n"); return 1;
    }
    loaded_data = load_photon_data_chunk(test_file, &num_loaded);
    if (!loaded_data || num_loaded != 3) { // This is the condition for failure
        printf("Test 1 FAILED: load_photon_data_chunk returned unexpected count (%zu) or NULL pointer (%p).\n", num_loaded, (void*)loaded_data);
        if(loaded_data) { // Guard the free operation
            free(loaded_data);
        }
        remove(test_file); // This will now be executed if the outer if is true
        return 1;          // This will now be executed if the outer if is true
    }
    // Verify that the loaded data matches the original data within a small tolerance.
    int match = 1;
    for(size_t i=0; i<3; ++i) if(!test_compare_photons(&original_data[i], &loaded_data[i], 1e-9)) match=0;
    if(match) printf("Test 1 PASSED: Data saved and loaded successfully.\n"); else printf("Test 1 FAILED: Data mismatch after save/load.\n");
    free(loaded_data);   // Free dynamically allocated memory.
    remove(test_file); // Remove the temporary test file.

    // Test 2: Save and load an empty array (0 points).
    printf("Test 2: Saving 0 points...\n");
    if (save_photon_data_chunk(test_file, NULL, 0) != 0) { // Pass `NULL` for data when `num_points` is 0.
        printf("Test 2 FAILED: save_photon_data_chunk (0 points) encountered an error.\n"); return 1;
    }
    loaded_data = load_photon_data_chunk(test_file, &num_loaded);
    // For 0 points, `load_photon_data_chunk` should return `NULL` for data and `num_loaded` should be 0.
    if (loaded_data == NULL && num_loaded == 0) {
        printf("Test 2 PASSED: Empty chunk handling is correct.\n");
    } else {
        printf("Test 2 FAILED: load_photon_data_chunk (0 points) returned unexpected count (%zu) or non-NULL pointer (%p).\n", num_loaded, (void*)loaded_data);
        if(loaded_data) free(loaded_data); // Clean up if memory was unexpectedly allocated.
    }
    remove(test_file); // Remove the temporary test file.
    
    // Test 3: Attempt to load a non-existent file.
    printf("Test 3: Loading non-existent file...\n");
    loaded_data = load_photon_data_chunk("non_existent_chunk.bin", &num_loaded);
    // `load_photon_data_chunk` should return `NULL` for data and `num_loaded` should be 0.
    if (loaded_data == NULL && num_loaded == 0) {
         printf("Test 3 PASSED: Non-existent file handling is correct.\n");
    } else {
         printf("Test 3 FAILED: load non-existent file did not return NULL/0 (count %zu, ptr %p).\n", num_loaded, (void*)loaded_data);
        if(loaded_data) free(loaded_data); // Clean up if memory was unexpectedly allocated.
    }

    printf("--- Unit Test for photon_chunk_io Finished ---\n");
    return 0;
}
#endif // UNIT_TEST_CHUNK_IO

// photon_chunk_io.c
// Bottom

// photon_rendering.c
// Top
/**
 * @file photon_rendering.c
 * @brief Implements the main photon mapping and image rendering function (`map_photons`).
 *
 * This module is responsible for synthesizing a gravitationally lensed image from a source image
 * using pre-calculated photon trajectory data. It acts as the final visualization step in the
 * ray tracing pipeline, transforming abstract photon paths into observable imagery.
 *
 * The `map_photons` function processes `PhotonMapDataPoint` structures (which map coordinates
 * on the observer's viewing plane to coordinates on a source image plane) and then samples
 * colors from a provided source image to construct the lensed output image.
 *
 * It supports two main rendering modes:
 * -   **Mode A ("Full View"):** If `observer_window_bounds` is `NULL`, the function automatically
 *     determines the extent of the lensed features on the observer's window by scanning all
 *     photon data. The output image's field of view is then adjusted to encompass this full
 *     view, maintaining the aspect ratio of the source image to prevent distortion. This is ideal
 *     for showcasing the entire lensing effect.
 * -   **Mode B ("Windowed View"):** If `observer_window_bounds` is provided, it explicitly defines
 *     a specific rectangular region on the observer's window to render. The output image dimensions
 *     are scaled to fit this defined window, preserving its aspect ratio. This is useful for zooming
 *     into specific features like Einstein rings.
 *
 * The rendering process involves:
 * 1.  Loading and validating the source image.
 * 2.  Determining the logical and pixel dimensions of the output (lensed) image based on the chosen mode.
 * 3.  Iterating through all provided photon data chunks.
 * 4.  For each photon data point:
 *     a.  Filtering points that miss the logical bounds of the source image or the observer's rendering window.
 *     b.  Mapping the photon's source plane intersection (`y_image_cart_x/y`) to a pixel in the source image.
 *     c.  Mapping the photon's observer window intersection (`y_window_cart_x/y`) to a pixel in the output image.
 *     d.  Accumulating the color from the source pixel into the corresponding output pixel's buffer.
 * 5.  Averaging accumulated colors for each output pixel (for anti-aliasing/super-sampling effect).
 * 6.  Filling unhit pixels with a `default_color_param`.
 * 7.  Saving the final lensed image as a PPM file.
 *
 * This process is a direct application of the reverse ray tracing concept described in
 * Schwarzschild_Lens_Paper.pdf, Section 3.2 "Generating Images".
 *
 * @dependencies schwarzschild_tracer.h (for core structures like `PPMImage`, `RGBColor`, `PhotonMapDataPoint`, `EPSILON_GENERAL`)
 * @dependencies ppm_image_io.c (for `load_ppm_image`, `save_ppm_image`, `free_ppm_image`)
 * @dependencies photon_chunk_io.c (for `load_photon_data_chunk`)
 */

#define _POSIX_C_SOURCE 200809L // Ensures POSIX-compliant features, like `strdup` if used, or for general compatibility.
#include "schwarzschild_tracer.h"
// Standard C and GSL headers are already included via `schwarzschild_tracer.h`.

/**
 * @brief Renders a gravitationally lensed image from a source image using pre-calculated photon trajectory data.
 *
 * This function takes a source PPM image and an array of binary photon data chunk files (typically produced by
 * `results_cartesian` or `results_radial`). Each `PhotonMapDataPoint` within these chunks describes a mapping
 * from a coordinate on the observer's "window" plane (local sky) to a corresponding coordinate on the distant
 * background source image plane. The function iterates through these mappings, samples colors from the source image
 * based on where the ray originated, and accumulates them onto a target output image, thereby simulating the
 * gravitational lensing effect.
 *
 * The function supports two main rendering modes, determined by the `observer_window_bounds` parameter:
 * -   **Mode A ("Full View"):** If `observer_window_bounds` is `NULL`, the function first scans
 *     all available photon data. It dynamically determines the minimum and maximum extent of `y_window_cart_x`
 *     and `y_window_cart_y` for photons that successfully hit the source image. The output image
 *     is then scaled to encompass this full lensed view, while preserving the original source
 *     image's aspect ratio to avoid distortion.
 * -   **Mode B ("Windowed View"):** If `observer_window_bounds` is provided, it defines a specific
 *     rectangular region `{y0_min, y0_max, z0_min, z0_max}` on the observer's window to render.
 *     The output image's pixel dimensions are determined by `target_output_pixel_width` and
 *     the aspect ratio of this explicitly defined window.
 *
 * Pixels in the output image that receive multiple photon hits from the source image will have
 * their colors averaged (a form of super-sampling for anti-aliasing). Pixels not hit by any
 * photons are set to `default_color_param`. The mapping of logical coordinates to pixel indices
 * for both source and destination images is handled internally, ensuring correct image reconstruction.
 *
 * @param image_source_path Path to the source PPM image file (input). Can be `NULL` if
 *                          `image_source_data_param` is provided (i.e., image is already loaded).
 * @param image_source_data_param Pointer to an already loaded `PPMImage` struct representing
 *                                the source image (input). Can be `NULL` if `image_source_path` is provided.
 * @param photon_chunk_files An array of strings, where each string is a path to a binary
 *                           photon data chunk file (`.bin`). These files contain `PhotonMapDataPoint` structures.
 * @param num_chunk_files_param The number of chunk files in `photon_chunk_files`. If -1,
 *                              the array is assumed to be `NULL`-terminated.
 * @param save_path Path where the final rendered PPM image will be saved (input). If `NULL`
 *                  or an empty string, the image is processed but not saved to disk.
 * @param source_logical_width_input The logical width of the source image in the simulation's
 *                                   coordinate system (input). The source image is assumed to be
 *                                   centered at (0,0) in its logical (`y_image_cart_x`, `y_image_cart_y`) plane.
 *                                   The logical height is derived from this width and the source image's
 *                                   pixel aspect ratio. Photons landing outside this logical area on the source plane are ignored.
 * @param target_output_pixel_width The desired pixel width of the output lensed image (input).
 *                                  The height of the output image is determined based on the
 *                                  aspect ratio of the rendering window (which depends on the mode).
 * @param observer_window_bounds If `NULL`, enables Mode A ("Full View"). If not `NULL`, it must
 *                               point to a `double[4]` array `{y0_min, y0_max, z0_min, z0_max}`
 *                               defining the logical bounds of the observer's window to render (Mode B). (Input)
 * @param default_color_param The `RGBColor` to use for pixels in the output image that are not
 *                            hit by any photons mapping from the source. (Input)
 * @return `int` 0 on success (image processed, and saved if `save_path` was valid).
 * @return -1 on critical error (e.g., input validation failure, memory allocation failure,
 *            failure to load/save images).
 * @note The function assumes that `y_window_cart_x` / `y_image_cart_x` (from `PhotonMapDataPoint`)
 *       correspond to the horizontal direction of the image (Y-axis), and `y_window_cart_y` / `y_image_cart_y`
 *       correspond to the vertical direction (Z-axis). For the output image, `y_window_cart_y` (logical Z-axis)
 *       values are mapped such that logical `MIN_z` maps to the image top (row 0), and logical `MAX_z`
 *       maps to the image bottom (last row). This aligns with standard image coordinate systems.
 */
int map_photons(
    const char *image_source_path, PPMImage *image_source_data_param,
    char **photon_chunk_files, int num_chunk_files_param,
    const char *save_path,
    double source_logical_width_input,
    int target_output_pixel_width,
    const double *observer_window_bounds, // If NULL, Mode A, else Mode B
    RGBColor default_color_param) {

    // --- Initialization of local variables and buffers ---
    int mapped_h = 1, mapped_w = 1; // Pixel dimensions of the output (lensed) image. Initialized to 1 to avoid zero-size issues.
    // Logical coordinate bounds of the area on the observer's window that will be rendered.
    // These define the coordinate system for mapping photon `y_window_cart_x/y` to output pixels.
    double dest_map_bound_min_y = 0.0, dest_map_bound_max_y = 0.0; // Y-bounds (horizontal).
    double dest_map_bound_min_z = 0.0, dest_map_bound_max_z = 0.0; // Z-bounds (vertical).

    PPMImage *source_image_loaded = NULL;     // Pointer for the source image if it needs to be loaded from a file.
    const PPMImage *source_image_to_use = NULL; // Pointer to the `PPMImage` struct that will actually be used as the source.
    unsigned char *mapped_image_pixels = NULL;  // Raw pixel data for the output lensed image (RGB bytes).
    // Buffers for accumulating color values (`double` for precision) for averaging, and count of hits per pixel.
    double *sum_r_array = NULL, *sum_g_array = NULL, *sum_b_array = NULL;
    int64_t *count_array_pixels = NULL; // `int64_t` is used for counts to prevent overflow with many photons.
    int final_status = -1; // Overall function status. Default to error until successful completion.

    // --- 1. Validate Inputs & Load Source Image ---
    if (target_output_pixel_width <= 0) {
        fprintf(stderr, "map_photons: target_output_pixel_width must be positive (%d given).\n", target_output_pixel_width);
        goto cleanup_map_photons_early; // Jump to centralized cleanup on error.
    }
    if (source_logical_width_input <= EPSILON_GENERAL) {
        fprintf(stderr, "map_photons: source_logical_width_input must be positive (%.6e given).\n", source_logical_width_input);
        goto cleanup_map_photons_early;
    }

    // Determine which source image to use: `image_source_data_param` (pre-loaded) or `image_source_path` (load from file).
    if (image_source_data_param) {
        source_image_to_use = image_source_data_param;
    } else if (image_source_path) {
        source_image_loaded = load_ppm_image(image_source_path); // Attempt to load from path.
        if (!source_image_loaded) {
            fprintf(stderr, "map_photons: Failed to load source image from '%s'.\n", image_source_path);
            goto cleanup_map_photons_early;
        }
        source_image_to_use = source_image_loaded;
    } else {
        fprintf(stderr, "map_photons: No source image provided (neither path nor pre-loaded data).\n"); goto cleanup_map_photons_early;
    }
    // Validate the properties of the selected source image.
    if (!source_image_to_use || source_image_to_use->width <= 0 || source_image_to_use->height <= 0 || source_image_to_use->channels != 3) {
        fprintf(stderr, "map_photons: Invalid source image properties (width=%d, height=%d, channels=%d).\n",
                source_image_to_use ? source_image_to_use->width : 0,
                source_image_to_use ? source_image_to_use->height : 0,
                source_image_to_use ? source_image_to_use->channels : 0);
        goto cleanup_map_photons_early;
    }
    int orig_h = source_image_to_use->height; int orig_w = source_image_to_use->width;
    double source_pixel_aspect = (orig_h > 0) ? ((double)orig_w / orig_h) : 1.0; // Calculate source image's aspect ratio (width/height).
    printf("map_photons: Source image '%s' loaded (%dx%d pixels, aspect ratio: %.3f).\n",
           image_source_path ? image_source_path : "from pre-loaded data", orig_w, orig_h, source_pixel_aspect);

    // --- Determine `num_chunks_to_process` EARLY ---
    // This allows for early handling of cases where no photon data is provided.
    int num_chunks_to_process = 0;
    if (photon_chunk_files) {
        if (num_chunk_files_param >= 0) { // If the count is explicitly provided (e.g., from `results_generation`).
            num_chunks_to_process = num_chunk_files_param;
        } else { // If count is -1, assume `photon_chunk_files` is a `NULL`-terminated array.
            for (num_chunks_to_process = 0; photon_chunk_files[num_chunks_to_process] != NULL; ++num_chunks_to_process);
        }
    }
    printf("map_photons: Number of photon chunk files to process: %d.\n", num_chunks_to_process);

    // --- 2. Define Source Logical Area to Sample From (common to both modes) ---
    // The source image is assumed to be centered at (0,0) in its logical (`y_image_cart_x`, `y_image_cart_y`) plane.
    // Its logical height is derived from the input `source_logical_width_input` and the source image's pixel aspect ratio.
    // Photons landing outside these logical bounds on the source plane are considered misses for coloring.
    double source_logical_height_calculated;
    if (source_pixel_aspect > EPSILON_GENERAL) { // Avoid division by zero if source image has problematic aspect.
        source_logical_height_calculated = source_logical_width_input / source_pixel_aspect;
    } else {
        fprintf(stderr, "map_photons: Warning - source image aspect ratio invalid (orig_h=0). Setting source logical height equal to width.\n");
        source_logical_height_calculated = source_logical_width_input;
    }
    source_logical_height_calculated = fmax(source_logical_height_calculated, EPSILON_GENERAL); // Ensure positive height.

    // Half-extents for the source logical mapping.
    double source_map_bound_y1_extent = source_logical_width_input / 2.0;  // Half-width on the Y1-axis.
    double source_map_bound_z1_extent = source_logical_height_calculated / 2.0; // Half-height on the Z1-axis.
    // Denominators for normalizing logical coordinates (`y1_f`, `z1_f`) to the [0,1] range for pixel lookup.
    double source_denom_y1 = fmax(source_logical_width_input, EPSILON_GENERAL);    
    double source_denom_z1 = fmax(source_logical_height_calculated, EPSILON_GENERAL); 
    printf("Source logical sampling area: y1 in [%.3f, %.3f], z1 in [%.3f, %.3f].\n",
           -source_map_bound_y1_extent, source_map_bound_y1_extent,
           -source_map_bound_z1_extent, source_map_bound_z1_extent);

    // --- 3. Determine Mode and Output Pixel/Logical Dimensions ---
    mapped_w = target_output_pixel_width; // The output image width is always as specified by the user.

    if (observer_window_bounds == NULL) { // MODE A: "Full View of Source Hits"
        printf("Operating in Mode A: Full View of Source Hits.\n");
        // For rendering, `y_window_cart_y` (logical Z-axis) maps to the vertical image axis.
        // Standard image coordinates: row 0 is top, increasing downwards.
        // Thus, logical `MIN_z` maps to image top, logical `MAX_z` maps to image bottom.
        printf("  Z-axis rendering convention: Logical MIN_z maps to image top, logical MAX_z to image bottom.\n");

        // In Mode A, the output image's pixel height is determined by maintaining the source image's aspect ratio.
        if (source_pixel_aspect > EPSILON_GENERAL) {
            mapped_h = (int)round((double)mapped_w / source_pixel_aspect);
        } else {
            mapped_h = mapped_w; // Fallback if aspect ratio is zero or ill-defined (e.g., 1-pixel high source image).
        }
        if (mapped_h <= 0) mapped_h = 1; // Ensure height is at least 1 pixel.
        printf("  Output pixel dimensions (WxH): %d x %d (aspect ratio matches source: %.3f).\n", mapped_w, mapped_h, source_pixel_aspect);

        // Scan all photon chunks to find the minimum and maximum `y_window_cart_x` (y0) and `y_window_cart_y` (z0)
        // coordinates on the observer's window for photons that successfully hit the source logical area.
        double min_y0_scan = DBL_MAX, max_y0_scan = -DBL_MAX; // Initialized to extreme values.
        double min_z0_scan = DBL_MAX, max_z0_scan = -DBL_MAX;
        bool found_photons_for_mode_a = false; // Flag to track if any relevant photons were found.

        if (num_chunks_to_process > 0) {
            printf("  Scanning photon chunks for Mode A destination bounds...\n");
            for (int ci_scan = 0; ci_scan < num_chunks_to_process; ++ci_scan) {
                size_t num_pts_scan;
                PhotonMapDataPoint* chunk_scan = load_photon_data_chunk(photon_chunk_files[ci_scan], &num_pts_scan);
                if (chunk_scan && num_pts_scan > 0) {
                    for (size_t k = 0; k < num_pts_scan; ++k) {
                        // Skip if the photon's `y_image` coordinates fall outside the source's logical area.
                        if (fabs(chunk_scan[k].y_image_cart_x) > source_map_bound_y1_extent + EPSILON_GENERAL ||
                            fabs(chunk_scan[k].y_image_cart_y) > source_map_bound_z1_extent + EPSILON_GENERAL) {
                            continue; 
                        }
                        // Skip if `y_window` coordinates are NaN (can happen if ray tracing failed for this point).
                        if (gsl_isnan(chunk_scan[k].y_window_cart_x) || gsl_isnan(chunk_scan[k].y_window_cart_y)) continue;

                        found_photons_for_mode_a = true; // At least one relevant photon found.
                        // Update the minimum and maximum `y_window` (y0) and `z_window` (z0) coordinates.
                        if (chunk_scan[k].y_window_cart_x < min_y0_scan) min_y0_scan = chunk_scan[k].y_window_cart_x;
                        if (chunk_scan[k].y_window_cart_x > max_y0_scan) max_y0_scan = chunk_scan[k].y_window_cart_x;
                        if (chunk_scan[k].y_window_cart_y < min_z0_scan) min_z0_scan = chunk_scan[k].y_window_cart_y;
                        if (chunk_scan[k].y_window_cart_y > max_z0_scan) max_z0_scan = chunk_scan[k].y_window_cart_y;
                    }
                }
                free(chunk_scan); // Free the chunk data after scanning.
            }
        }

        if (!found_photons_for_mode_a) {
            printf("  Warning: No photons found hitting the source area for Mode A. Output will be background color. Using default window bounds.\n");
            // If no relevant photons were found, set a default output window to prevent division by zero or NaN issues.
            dest_map_bound_min_y = -1.0; dest_map_bound_max_y = 1.0;
            dest_map_bound_min_z = -1.0; dest_map_bound_max_z = 1.0;
        } else {
            // Calculate the aspect ratio of the scanned photon window.
            double scanned_logical_width = fmax(max_y0_scan - min_y0_scan, EPSILON_GENERAL);
            double scanned_logical_height = fmax(max_z0_scan - min_z0_scan, EPSILON_GENERAL);
            double scanned_aspect = (scanned_logical_height > EPSILON_GENERAL) ? (scanned_logical_width / scanned_logical_height) : 1.0;
            printf("  Mode A: Scanned photon window extents: y0=[%.3f, %.3f], z0=[%.3f, %.3f] (Aspect: %.3f).\n",
                   min_y0_scan, max_y0_scan, min_z0_scan, max_z0_scan, scanned_aspect);

            // Adjust the destination mapping bounds (`dest_map_bound_min/max_y/z`) to match the source image's aspect ratio.
            // This ensures that the lensed content is not stretched or squashed in the output image.
            if (scanned_aspect > source_pixel_aspect) { 
                // If the scanned area is wider than the source aspect ratio, expand the height of the output window.
                double scanned_z_center = (min_z0_scan + max_z0_scan) / 2.0;
                double new_logical_height = scanned_logical_width / source_pixel_aspect;
                dest_map_bound_min_y = min_y0_scan;
                dest_map_bound_max_y = max_y0_scan;
                dest_map_bound_min_z = scanned_z_center - new_logical_height / 2.0;
                dest_map_bound_max_z = scanned_z_center + new_logical_height / 2.0;
            } else { 
                // If the scanned area is taller (or has equal aspect) than the source aspect ratio, expand the width of the output window.
                double scanned_y_center = (min_y0_scan + max_y0_scan) / 2.0;
                double new_logical_width = scanned_logical_height * source_pixel_aspect;
                dest_map_bound_min_z = min_z0_scan;
                dest_map_bound_max_z = max_z0_scan;
                dest_map_bound_min_y = scanned_y_center - new_logical_width / 2.0;
                dest_map_bound_max_y = scanned_y_center + new_logical_width / 2.0;
            }
        }
        printf("  Mode A: Final logical window to render: y0=[%.3f, %.3f], z0=[%.3f, %.3f] (Aspect: %.3f).\n",
               dest_map_bound_min_y, dest_map_bound_max_y, dest_map_bound_min_z, dest_map_bound_max_z,
               ( (dest_map_bound_max_z - dest_map_bound_min_z) > EPSILON_GENERAL ? 
                 (dest_map_bound_max_y - dest_map_bound_min_y) / (dest_map_bound_max_z - dest_map_bound_min_z) : 0.0 ) );

    } else { // MODE B: "Windowed View of Source Hits"
        printf("Operating in Mode B: Windowed View of Source Hits.\n");
        printf("  Z-axis rendering convention: Logical MIN_z maps to image top, logical MAX_z to image bottom.\n");

        // Use the user-provided observer window bounds directly.
        dest_map_bound_min_y = observer_window_bounds[0];
        dest_map_bound_max_y = observer_window_bounds[1];
        dest_map_bound_min_z = observer_window_bounds[2];
        dest_map_bound_max_z = observer_window_bounds[3];

        // Validate the provided window bounds.
        if (dest_map_bound_min_y >= dest_map_bound_max_y || dest_map_bound_min_z >= dest_map_bound_max_z) {
            fprintf(stderr, "map_photons: Invalid observer_window_bounds (minimum must be less than maximum for y0 or z0).\n");
            goto cleanup_map_photons_early; 
        }

        // Calculate the aspect ratio of the user-defined observer window.
        double window_logical_width = dest_map_bound_max_y - dest_map_bound_min_y;
        double window_logical_height = dest_map_bound_max_z - dest_map_bound_min_z;
        double observer_window_aspect = (window_logical_height > EPSILON_GENERAL) ? (window_logical_width / window_logical_height) : 1.0;

        // The output image's pixel height is determined by maintaining the aspect ratio of the user-defined window.
        if (observer_window_aspect > EPSILON_GENERAL) {
            mapped_h = (int)round((double)mapped_w / observer_window_aspect);
        } else {
            mapped_h = mapped_w; // Fallback for problematic aspect ratios.
        }
        if (mapped_h <= 0) mapped_h = 1; // Ensure height is at least 1 pixel.
        printf("  Output pixel dimensions (WxH): %d x %d (aspect ratio matches observer window: %.3f).\n", mapped_w, mapped_h, observer_window_aspect);
        printf("  User-defined observer window (logical): y0 in [%.3f, %.3f], z0 in [%.3f, %.3f].\n",
               dest_map_bound_min_y, dest_map_bound_max_y, dest_map_bound_min_z, dest_map_bound_max_z);
    }

    // --- 4. Allocate Buffers & Handle Empty Chunk List ---
    size_t num_output_pixels = (size_t)mapped_h * mapped_w;
    // Allocate memory for the final pixel data of the lensed image (3 bytes per pixel for RGB).
    mapped_image_pixels = malloc(num_output_pixels * 3 * sizeof(unsigned char)); 
    // Allocate and zero-initialize accumulation buffers for color sums and hit counts.
    // `calloc` ensures memory is zeroed, which is essential for accumulation.
    sum_r_array = calloc(num_output_pixels, sizeof(double));
    sum_g_array = calloc(num_output_pixels, sizeof(double));
    sum_b_array = calloc(num_output_pixels, sizeof(double));
    count_array_pixels = calloc(num_output_pixels, sizeof(int64_t)); // Using `int64_t` for `count_array_pixels` to prevent overflow with many hits.
    // Check for successful allocation of all necessary buffers.
    if (!mapped_image_pixels || !sum_r_array || !sum_g_array || !sum_b_array || !count_array_pixels) {
        fprintf(stderr, "map_photons: Failed to allocate image buffers (e.g., mapped_image_pixels, sum_r_array, etc.). Out of memory?\n"); goto cleanup_map_photons;
    }
    // Initialize the output image with the default background color. This ensures pixels
    // that receive no photon hits are correctly colored.
    for (size_t i = 0; i < num_output_pixels; ++i) {
        mapped_image_pixels[i*3 + 0] = default_color_param.r;
        mapped_image_pixels[i*3 + 1] = default_color_param.g;
        mapped_image_pixels[i*3 + 2] = default_color_param.b;
    }

    // If no photon chunk files are provided, the function can still create an output image
    // filled only with the background color. In this case, skip the main processing loop.
    if (num_chunks_to_process == 0 && save_path && strlen(save_path) > 0) {
        printf("map_photons: No photon chunk files provided. Saving default background image as output.\n");
        PPMImage temp_out_img = {mapped_image_pixels, mapped_w, mapped_h, 3};
        if (save_ppm_image(save_path, &temp_out_img) == 0) final_status = 0; // Success for this case.
        goto cleanup_map_photons; // Skip main processing loop.
    }
    
    // Denominators for normalizing destination (observer window) logical coordinates
    // (`y0_f`, `z0_f`) to the [0,1] range for pixel lookup.
    double dest_denom_y0 = fmax(dest_map_bound_max_y - dest_map_bound_min_y, EPSILON_GENERAL);
    double dest_denom_z0 = fmax(dest_map_bound_max_z - dest_map_bound_min_z, EPSILON_GENERAL);

    // --- 5. Loop Through Chunks for Actual Pixel Processing & Accumulation ---
    printf("Processing photon data for rendering across %d chunks...\n", num_chunks_to_process);
    for (int ci = 0; ci < num_chunks_to_process; ++ci) {
        // Provide progress indication to the user.
        if ((ci + 1) % 10 == 0 || ci == 0 || ci == num_chunks_to_process - 1 || num_chunks_to_process < 10) {
             printf("\r  Processing chunk %d/%d: %s...", ci + 1, num_chunks_to_process, photon_chunk_files[ci]); fflush(stdout);
        }
        size_t num_pts_in_chunk;
        PhotonMapDataPoint* chunk_data = load_photon_data_chunk(photon_chunk_files[ci], &num_pts_in_chunk);
        if (!chunk_data || num_pts_in_chunk == 0) { // Skip if chunk is empty or failed to load.
            free(chunk_data); // `load_photon_data_chunk` returns NULL if 0 points, safe to call `free(NULL)`.
            continue; 
        }

        for (size_t k_photon = 0; k_photon < num_pts_in_chunk; ++k_photon) {
            // Extract photon coordinates from the current data point.
            // `y0_f`, `z0_f` are coordinates on the observer's window plane (destination).
            // `y1_f`, `z1_f` are coordinates on the source image plane (source).
            double y0_f = chunk_data[k_photon].y_window_cart_x; double z0_f = chunk_data[k_photon].y_window_cart_y;
            double y1_f = chunk_data[k_photon].y_image_cart_x;  double z1_f = chunk_data[k_photon].y_image_cart_y;

            // Skip this photon if any of its coordinates are NaN (e.g., if ray tracing failed for this point).
            if (gsl_isnan(y0_f) || gsl_isnan(z0_f) || gsl_isnan(y1_f) || gsl_isnan(z1_f)) { continue; }

            // Filter 1: Check if the photon hits the defined logical area of the source image.
            // `fabs()` is used because source image is centered at (0,0), so extent is symmetric.
            if (fabs(y1_f) > source_map_bound_y1_extent + EPSILON_GENERAL ||
                fabs(z1_f) > source_map_bound_z1_extent + EPSILON_GENERAL) {
                continue; // Photon missed the source image's logical bounds.
            }
            // Filter 2: Check if the photon falls within the logical bounds of the observer's window being rendered.
            if (y0_f < dest_map_bound_min_y - EPSILON_GENERAL || y0_f > dest_map_bound_max_y + EPSILON_GENERAL ||
                z0_f < dest_map_bound_min_z - EPSILON_GENERAL || z0_f > dest_map_bound_max_z + EPSILON_GENERAL) {
                continue; // Photon is outside the current rendering view on the observer's window.
            }

            // --- Map source logical coordinates (`y1_f`, `z1_f`) to source image pixel indices (`src_col_idx`, `src_row_idx`) ---
            // Normalization: `(value - min_bound) / (max_bound - min_bound)`.
            // Here, `min_bound` is `-source_map_bound_y1_extent`, `max_bound` is `+source_map_bound_y1_extent`,
            // so `(y1_f + source_map_bound_y1_extent) / (2 * source_map_bound_y1_extent)`.
            // `source_denom_y1` and `source_denom_z1` already represent `2 * extent`.
            int src_col_idx = (int)round(((y1_f + source_map_bound_y1_extent) / source_denom_y1) * (orig_w - 1));
            // `z1_f` maps to the row index. The `(z1_f + extent)` makes `z1_f` range from 0 to `2*extent`.
            // This maps logical `MIN_z` (e.g., `-extent`) to pixel row 0 (top) and logical `MAX_z` (e.g., `+extent`) to pixel row `orig_h-1` (bottom).
            int src_row_idx = (int)round(((z1_f + source_map_bound_z1_extent) / source_denom_z1) * (orig_h - 1));
            // Clamp `src_col_idx` and `src_row_idx` to valid pixel ranges [0, width-1] and [0, height-1].
            src_col_idx = (src_col_idx < 0) ? 0 : (src_col_idx >= orig_w ? orig_w - 1 : src_col_idx);
            src_row_idx = (src_row_idx < 0) ? 0 : (src_row_idx >= orig_h ? orig_h - 1 : src_row_idx);

            // --- Map logical observer window coordinates (`y0_f`, `z0_f`) to destination image pixel indices (`dest_col_idx`, `dest_row_idx`) ---
            // Normalization: `(value - dest_map_bound_min) / (dest_map_bound_max - dest_map_bound_min)`.
            int dest_col_idx = (int)round(((y0_f - dest_map_bound_min_y) / dest_denom_y0) * (mapped_w - 1));
            // For `z0_f` (logical Z on observer window): mapping convention from problem description:
            // "Logical MIN_z maps to image top, logical MAX_z to image bottom."
            // If image rows are 0 (top) to `mapped_h-1` (bottom):
            // - When `z0_f = dest_map_bound_min_z`, `(z0_f - dest_map_bound_min_z)` is 0 -> row 0 (top).
            // - When `z0_f = dest_map_bound_max_z`, `(z0_f - dest_map_bound_min_z)` is `dest_denom_z0` -> row `mapped_h-1` (bottom). This matches the convention.
            int dest_row_idx = (int)round(((z0_f - dest_map_bound_min_z) / dest_denom_z0) * (mapped_h - 1)); 

            // Skip if destination pixel is outside the output image bounds (should ideally not happen if filtering logic is correct).
            if (dest_col_idx < 0 || dest_col_idx >= mapped_w || dest_row_idx < 0 || dest_row_idx >= mapped_h) { continue; }

            // Calculate flat array offsets for accessing pixel data in 1D arrays.
            size_t dest_pixel_offset = (size_t)dest_row_idx * mapped_w + dest_col_idx; // Offset for pixel in the output image (for sums).
            size_t src_pixel_offset  = (size_t)src_row_idx * orig_w * 3 + src_col_idx * 3; // Offset for pixel in the source image (3 channels per pixel).
            
            // Accumulate RGB color values from the source pixel into the destination pixel's sum buffers.
            sum_r_array[dest_pixel_offset] += source_image_to_use->data[src_pixel_offset + 0]; // Red channel.
            sum_g_array[dest_pixel_offset] += source_image_to_use->data[src_pixel_offset + 1]; // Green channel.
            sum_b_array[dest_pixel_offset] += source_image_to_use->data[src_pixel_offset + 2]; // Blue channel.
            count_array_pixels[dest_pixel_offset]++; // Increment the hit count for this destination pixel.
        }
        free(chunk_data); // Free the memory allocated for the current chunk's data after processing.
    }
    printf("\nPhoton processing complete.\n");

    // --- 6. Finalize Image by Averaging Accumulated Colors ---
    // Iterate through all pixels in the output image.
    for (size_t i_pix = 0; i_pix < num_output_pixels; ++i_pix) {
        if (count_array_pixels[i_pix] > 0) { // If this pixel was hit by one or more photons.
            // Calculate the average color for each channel (R, G, B).
            // `fmax(0, fmin(255, round(...)))` clamps the averaged value to the valid 0-255 range for `unsigned char`.
            mapped_image_pixels[i_pix*3 + 0] = (unsigned char)fmax(0, fmin(255, round(sum_r_array[i_pix] / count_array_pixels[i_pix])));
            mapped_image_pixels[i_pix*3 + 1] = (unsigned char)fmax(0, fmin(255, round(sum_g_array[i_pix] / count_array_pixels[i_pix])));
            mapped_image_pixels[i_pix*3 + 2] = (unsigned char)fmax(0, fmin(255, round(sum_b_array[i_pix] / count_array_pixels[i_pix])));
        }
        // If `count_array_pixels[i_pix]` is 0, the pixel retains the `default_color_param`
        // that it was initialized with at the beginning of the function.
    }

    // --- 7. Save and Cleanup ---
    PPMImage final_img = {mapped_image_pixels, mapped_w, mapped_h, 3}; // Create a temporary `PPMImage` struct for saving.
    if (save_path && strlen(save_path) > 0) { // Check if a valid `save_path` is provided.
        if (save_ppm_image(save_path, &final_img) == 0) {
            final_status = 0; // Function completed successfully, including saving.
            printf("Successfully saved lensed image to '%s'.\n", save_path);
        } else {
            fprintf(stderr, "map_photons: Failed to save final image to '%s'.\n", save_path);
            // `final_status` remains -1, indicating an error in saving.
        }
    } else {
        printf("map_photons: Warning - no save_path provided or path is empty. Image was processed but not saved.\n");
        final_status = 0; // Processing was successful, just no save was attempted.
    }

// Centralized cleanup labels for dynamically allocated memory.
cleanup_map_photons: 
    // Free the pixel data and accumulation buffers for the mapped image.
    if(mapped_image_pixels) { free(mapped_image_pixels); mapped_image_pixels = NULL;}
    if(sum_r_array) { free(sum_r_array); sum_r_array = NULL;}
    if(sum_g_array) { free(sum_g_array); sum_g_array = NULL;}
    if(sum_b_array) { free(sum_b_array); sum_b_array = NULL;}
    if(count_array_pixels) { free(count_array_pixels); count_array_pixels = NULL;}
cleanup_map_photons_early: // Label for errors occurring before the main buffer allocations.
    // Free the source image only if it was loaded by this function (`source_image_loaded` is non-NULL).
    if(source_image_loaded) { free_ppm_image(source_image_loaded); source_image_loaded = NULL;}
    return final_status;
}


#ifdef UNIT_TEST_PHOTON_RENDERING
// For a proper unit test of `map_photons`, comprehensive scenarios would ideally include:
// 1. Mocked or pre-generated dummy photon chunk files with known, simplified data.
// 2. A known small source image.
// 3. Pre-calculated expected output image pixel data for a given set of parameters.
// The `main_test.c` file provides better, more extensive integration testing.
// This unit test primarily serves as a basic smoke test to ensure the function runs
// without crashing and produces output files, rather than verifying pixel-level accuracy.

/**
 * @brief Forward declaration for `create_dummy_ppm`.
 *
 * This helper function (typically defined elsewhere, e.g., in `main_test.c` or
 * a common test utility file) creates a simple dummy PPM image.
 * It's declared here to allow compilation of this unit test if it's standalone.
 * The actual definition for `create_dummy_ppm` might be provided below this `#ifdef`.
 */
PPMImage* create_dummy_ppm(int width, int height);

/**
 * @brief Main function for unit testing `photon_rendering.c` (smoke test for `map_photons`).
 *
 * This function performs a basic smoke test on the `map_photons` function to ensure
 * it executes without critical errors and generates output files. It covers both
 * Mode A (Full View) and Mode B (Windowed View) of `map_photons`.
 *
 * The test pipeline includes:
 * 1. Creating a small, procedurally generated dummy source PPM image in memory.
 * 2. Creating a temporary binary photon data chunk file with a few simple mapping points.
 * 3. Calling `map_photons` with these dummy inputs for both modes.
 * 4. Cleaning up all temporary files created during the test.
 *
 * To compile and run this unit test (assuming Makefile setup that links necessary I/O modules):
 * `make test_photon_rendering`
 * (This compilation usually links against `main_test.o` which provides `create_dummy_ppm`,
 * or a local definition of `create_dummy_ppm` is used if compiled as a standalone unit test.)
 *
 * @return `int` 0 if the smoke tests complete successfully (program does not crash, output files are attempted).
 *         Non-zero indicates a critical setup failure (e.g., failed to create dummy image/file).
 */
int main() {
    printf("--- Unit Test for photon_rendering (map_photons smoke test) ---\n");
    // Disable GSL's default error handler for robust testing.
    gsl_set_error_handler_off();

    // 1. Create a dummy source image for the test.
    PPMImage* dummy_source = create_dummy_ppm(64, 64); 
    if (!dummy_source) {
        printf("Failed to create dummy source for map_photons test. Exiting.\n");
        return 1;
    }
    // 2. Create a dummy photon chunk file with a few known data points.
    const char* dummy_chunk_file = "test_map_photons_chunk.bin";
    PhotonMapDataPoint pdata[2];
    // Sample data: {y_window_cart_x, y_window_cart_y, y_image_cart_x, y_image_cart_y}
    pdata[0] = (PhotonMapDataPoint){0.1, 0.1, 0.5, 0.5}; // Photon from window (0.1,0.1) hits source (0.5,0.5).
    pdata[1] = (PhotonMapDataPoint){-0.1, -0.1, -0.5, -0.5}; // Photon from window (-0.1,-0.1) hits source (-0.5,-0.5).
    if (save_photon_data_chunk(dummy_chunk_file, pdata, 2) != 0) {
        printf("Failed to save dummy chunk for map_photons test. Exiting.\n");
        free_ppm_image(dummy_source);
        return 1;
    }
    char* chunk_list[] = {(char*)dummy_chunk_file, NULL}; // `NULL`-terminated list of chunk files.

    RGBColor bg = {10,20,30}; // A distinct background color for the output image.
    const char* out_file_A = "test_map_photons_ModeA.ppm"; // Output filename for Mode A.
    const char* out_file_B = "test_map_photons_ModeB.ppm"; // Output filename for Mode B.
    double obs_window_B[4] = {-0.2, 0.2, -0.2, 0.2}; // Observer window bounds for Mode B: `{y_min, y_max, z_min, z_max}`.

    printf("Testing map_photons Mode A (Full View)...\n");
    int statusA = map_photons(NULL, dummy_source, chunk_list, 1, /* `num_chunk_files` is 1 for this test */
                              out_file_A,
                              1.0, // `source_logical_width_input`: e.g., source image covers -0.5 to 0.5 logical y-range.
                              100, // `target_output_pixel_width`: desired width of output image.
                              NULL, // `observer_window_bounds`: `NULL` triggers Mode A.
                              bg);
    if (statusA == 0) printf("Mode A smoke test PASSED (file '%s' potentially created).\n", out_file_A);
    else printf("Mode A smoke test FAILED (status %d). Check console for errors.\n", statusA);

    printf("Testing map_photons Mode B (Windowed View)...\n");
    int statusB = map_photons(NULL, dummy_source, chunk_list, 1, /* `num_chunk_files` is 1 for this test */
                              out_file_B,
                              1.0, // `source_logical_width_input`.
                              100, // `target_output_pixel_width`.
                              obs_window_B, // `observer_window_bounds`: explicitly defines window for Mode B.
                              bg);
    if (statusB == 0) printf("Mode B smoke test PASSED (file '%s' potentially created).\n", out_file_B);
    else printf("Mode B smoke test FAILED (status %d). Check console for errors.\n", statusB);

    // Cleanup: Free allocated memory and remove temporary test files.
    free_ppm_image(dummy_source);
    remove(dummy_chunk_file);
    remove(out_file_A); 
    remove(out_file_B);

    printf("--- Unit Test for photon_rendering Finished ---\n");
    return 0;
}

// Local helper function definition for `create_dummy_ppm` if this file is compiled standalone
// as a unit test (i.e., not linked with `main_test.o` which provides a more complete version).
#ifndef UNIT_TEST_MAIN_FILE // Guard to prevent redefinition if `main_test.c` (or similar) is providing this function.
/**
 * @brief Creates a simplified dummy PPMImage, mainly for standalone unit testing of `photon_rendering.c`.
 *
 * Fills pixel data with zeros (resulting in a black image).
 * This is a minimal implementation to satisfy compilation requirements for local unit tests.
 *
 * @param width Desired image width in pixels.
 * @param height Desired image height in pixels.
 * @return `PPMImage*` Pointer to the newly created `PPMImage` structure, or `NULL` on failure.
 */
PPMImage* create_dummy_ppm(int width, int height) {
    PPMImage* img = malloc(sizeof(PPMImage));
    if (!img) return NULL;
    img->width = width; img->height = height; img->channels = 3; // RGB channels.
    if (width > 0 && height > 0) {
        // Use `calloc` to allocate and zero-initialize pixel data (resulting in a black image).
        img->data = calloc((size_t)width * height * img->channels, sizeof(unsigned char));
        if (!img->data) { free(img); return NULL;}
    } else {
        img->data = NULL; // Valid for 0-dimension images.
    }
    return img;
}
#endif // UNIT_TEST_MAIN_FILE

#endif // UNIT_TEST_PHOTON_RENDERING


// photon_rendering.c
// Bottom

// ppm_image_io.c
// Top
/**
 * @file ppm_image_io.c
 * @brief Provides functions for loading and saving PPM (Portable Pixmap) images in P6 (binary RGB) format.
 *
 * This module is responsible for handling basic image file I/O operations, enabling the program
 * to read source images (e.g., textures or backgrounds for lensing simulations) and write out
 * the final rendered lensed images. It specifically supports the P6 binary format, which stores
 * raw RGB pixel data efficiently. The functions also include logic to robustly parse PPM headers,
 * including skipping comments and arbitrary whitespace.
 *
 * @dependencies schwarzschild_tracer.h (for `PPMImage`, `RGBColor` structs, and standard headers like `stdio.h`, `stdlib.h`, `string.h`, `ctype.h`).
 */

#define _POSIX_C_SOURCE 200809L // Ensures POSIX-compliant features, if any are indirectly used (e.g., `strdup` by `string.h` or for future compatibility).
#include "schwarzschild_tracer.h" // Includes `PPMImage`, `RGBColor`, `stdio.h`, `stdlib.h`, `string.h`, `ctype.h`.

// --- PPM Image I/O (Basic P6 support) ---

/**
 * @brief Skips whitespace and comment lines in a PPM file stream.
 *
 * PPM comments start with '#' and extend to the end of the line.
 * This function is used internally by `load_ppm_image` to parse the PPM header robustly.
 * It recursively calls itself to handle multiple consecutive comment lines or
 * blocks of whitespace, ensuring the file pointer is correctly positioned for the next data field.
 *
 * @param fp A pointer to the `FILE` stream of the PPM file, opened for reading.
 *           The file pointer will be advanced past any skipped whitespace or comments.
 */
static void skip_ppm_comments_and_whitespace(FILE *fp) {
    int ch;
    // Skip leading whitespace characters (spaces, tabs, newlines, carriage returns, etc.).
    while ((ch = fgetc(fp)) != EOF && isspace(ch)) {
        // Keep reading.
    }
    // If the character read is a comment marker ('#').
    if (ch == '#') {
        // Skip all characters until the end of the line or EOF.
        while ((ch = fgetc(fp)) != EOF && ch != '\n' && ch != '\r') {
            // Keep reading comment characters.
        }
        // After skipping a comment line, there might be more whitespace or another comment,
        // so recursively call to handle these.
        skip_ppm_comments_and_whitespace(fp);
    } else if (ch != EOF) {
        // If the character read was not whitespace and not '#', it's part of the actual
        // PPM header data (e.g., part of width, height, or max_val).
        // Put it back into the stream so it can be read by the main parser (`fscanf`).
        ungetc(ch, fp);
    }
}

/**
 * @brief Loads a PPM image from a file in P6 (binary RGB) format.
 *
 * This function parses the PPM header (magic number "P6", width, height, max color value),
 * validates its content (e.g., max color value must be 255), allocates memory for the pixel data,
 * and then reads the raw binary pixel data.
 *
 * @param filename The path to the PPM file to load.
 * @return `PPMImage*` A pointer to a dynamically allocated `PPMImage` structure containing
 *                   the loaded image data. Returns `NULL` on any error (e.g., file not found,
 *                   invalid PPM format, unexpected header values, memory allocation failure,
 *                   or read errors).
 *                   The caller is responsible for freeing the returned `PPMImage` structure
 *                   using `free_ppm_image`.
 * @note `perror` is called on system-level errors (`fopen`, `fread`, `fclose`) to provide more details.
 * @note Handles images with zero or negative dimensions by setting `image->data` to `NULL`, which is a valid representation.
 */
PPMImage* load_ppm_image(const char *filename) {
    FILE *fp = fopen(filename, "rb"); // Open the file in binary read mode.
    if (!fp) {
        perror("load_ppm_image: fopen failed"); // Report file opening error.
        return NULL;
    }

    char magic[3]; // Buffer for "P6" and null terminator.
    // Read and check the magic number. It must be "P6" for binary RGB PPM.
    if (fgets(magic, sizeof(magic), fp) == NULL || strncmp(magic, "P6", 2) != 0) {
        fprintf(stderr, "load_ppm_image: Not a P6 PPM file or read error (magic: '%s').\n", magic);
        fclose(fp); // Close file on format error.
        return NULL;
    }

    PPMImage *image = calloc(1, sizeof(PPMImage)); // Allocate and zero-initialize the `PPMImage` struct.
    if (!image) {
        perror("load_ppm_image: calloc PPMImage failed"); // Report allocation error.
        fclose(fp);
        return NULL;
    }

    // Parse width from the header, skipping any comments or whitespace before it.
    skip_ppm_comments_and_whitespace(fp);
    if (fscanf(fp, "%d", &image->width) != 1) {
        fprintf(stderr, "load_ppm_image: Failed to read image width from header.\n");
        goto read_error_ppm_load; // Jump to centralized cleanup on error.
    }
    // Parse height.
    skip_ppm_comments_and_whitespace(fp);
    if (fscanf(fp, "%d", &image->height) != 1) {
        fprintf(stderr, "load_ppm_image: Failed to read image height from header.\n");
        goto read_error_ppm_load;
    }
    // Parse maximum color value. For standard P6 format, this must be 255.
    skip_ppm_comments_and_whitespace(fp);
    int max_val;
    if (fscanf(fp, "%d", &max_val) != 1 || max_val != 255) {
        fprintf(stderr, "load_ppm_image: PPM max color value not 255 or read error (read_val: %d). Only 255 is supported.\n", max_val);
        goto read_error_ppm_load;
    }

    // After `max_val`, there must be a single whitespace character (typically a newline)
    // before the raw pixel data begins. `fgetc` reads this character.
    int ch_after_maxval = fgetc(fp);
    if (!isspace(ch_after_maxval)) {
        fprintf(stderr, "load_ppm_image: Expected whitespace after max color value, but got '%c' (ASCII: %d).\n", ch_after_maxval, ch_after_maxval);
        goto read_error_ppm_load;
    }

    // Validate image dimensions. Dimensions must be positive for pixel data to exist.
    // However, handling cases like 0xN or Nx0 images means `data_size` will be 0.
    if (image->width <= 0 || image->height <= 0) {
        fprintf(stderr, "load_ppm_image: Invalid image dimensions read from header: %dx%d. Dimensions must be positive.\n", image->width, image->height);
        // Do not jump to error cleanup if dimensions are 0 (as `data` will be NULL).
        // Instead, proceed and `image->data` will be set to NULL below.
    }

    image->channels = 3; // P6 PPM always has 3 channels (RGB).
    size_t data_size = (size_t)image->width * image->height * image->channels;

    if (data_size == 0) { // If dimensions are 0 (e.g., 0x10 image), no pixel data is expected.
        image->data = NULL; // Explicitly set `data` to `NULL`.
    } else {
        image->data = malloc(data_size); // Allocate memory for the raw pixel data.
        if (!image->data) {
            perror("load_ppm_image: malloc for pixel data failed"); // Report allocation error.
            goto read_error_ppm_load;
        }
        // Read the raw pixel data from the file.
        if (fread(image->data, sizeof(unsigned char), data_size, fp) != data_size) {
            perror("load_ppm_image: fread for pixel data failed or short read"); // Report read error or incomplete read.
            free(image->data); image->data = NULL; // Free partially allocated/read data on error.
            goto read_error_ppm_load;
        }
    }

    // Close the file. `fclose` can fail (e.g., disk full, write buffer flush error).
    if (fclose(fp) != 0) {
        perror("load_ppm_image: fclose failed");
        // Continue, as data was read successfully, but log the error.
    }
    return image; // Successfully loaded and returned the `PPMImage` struct.

// Centralized error handling label: frees allocated memory and returns `NULL`.
read_error_ppm_load: 
    if (fp) { fclose(fp); } // Ensure file is closed if it was opened.
    free_ppm_image(image); // `free_ppm_image` safely handles `NULL` image or `NULL` `image->data`.
    return NULL;
}

/**
 * @brief Saves a `PPMImage` structure to a file in P6 (binary RGB) format.
 *
 * This function writes the PPM header and then the raw binary pixel data from the
 * `PPMImage` structure to the specified file. It validates the input `PPMImage`
 * to ensure it's suitable for saving (e.g., 3 channels).
 *
 * @param filename The path to the output PPM file. The file will be created or overwritten if it exists.
 * @param image A pointer to the `PPMImage` structure to be saved.
 *              The `image` must have valid dimensions (`width`, `height` >= 0) and
 *              `channels` must be 3. If `width` or `height` is 0, `image->data` should be `NULL`.
 * @return `int` 0 on success.
 * @return -1 on error (e.g., invalid input image data, file opening failure,
 *            write errors, or `fclose` failure).
 * @note `perror` is called on system-level errors (`fopen`, `fwrite`, `fclose`).
 */
int save_ppm_image(const char *filename, const PPMImage *image) {
    // Validate input `PPMImage` structure.
    // Check for NULL image, negative dimensions, or incorrect channel count (must be 3 for P6).
    // The conditional `!(image && (image->width == 0 || image->height == 0) && image->data == NULL)`
    // allows for valid empty images (0xN or Nx0 with NULL data).
    if (!image || image->width < 0 || image->height < 0 || image->channels != 3) {
        if (!(image && (image->width == 0 || image->height == 0) && image->channels == 3 && image->data == NULL)) {
             fprintf(stderr, "save_ppm_image: Invalid image data provided (NULL image, negative dims, or channels not 3).\n");
             return -1;
        }
    }
    // Further consistency check: if dimensions are non-zero, data must not be NULL.
    if ((image->width > 0 && image->height > 0) && image->data == NULL) {
        fprintf(stderr, "save_ppm_image: Non-zero dimensions (%dx%d) but NULL pixel data.\n", image->width, image->height);
        return -1;
    }
    // Consistency check: if dimensions are zero, data must be NULL.
    if ((image->width == 0 || image->height == 0) && image->data != NULL) {
        fprintf(stderr, "save_ppm_image: Zero dimensions (%dx%d) but non-NULL pixel data. Data should be NULL for empty image.\n", image->width, image->height);
        return -1;
    }


    FILE *fp = fopen(filename, "wb"); // Open the file in binary write mode.
    if (!fp) {
        perror("save_ppm_image: fopen failed"); // Report file opening error.
        return -1;
    }

    // Write the PPM header: "P6\n<width> <height>\n255\n".
    // `fprintf` returns the number of characters written, or a negative value on error.
    if (fprintf(fp, "P6\n%d %d\n255\n", image->width, image->height) < 0) {
        perror("save_ppm_image: fprintf header failed"); // Report write error for header.
        fclose(fp); // Close the file.
        return -1;
    }

    // Write the raw pixel data, but only if the image has positive dimensions and valid data.
    if (image->width > 0 && image->height > 0 && image->data) {
        size_t data_size = (size_t)image->width * image->height * image->channels;
        if (fwrite(image->data, sizeof(unsigned char), data_size, fp) != data_size) {
            perror("save_ppm_image: fwrite pixel data failed"); // Report write error for pixel data.
            fclose(fp);
            return -1;
        }
    }
    // If width or height is 0, `data_size` will be 0, and no data is written, which is correct for an empty PPM.

    // Close the file. `fclose` can fail, and it's important to check this for writes.
    if (fclose(fp) != 0) {
        perror("save_ppm_image: fclose failed");
        return -1; // Indicate error even if data write seemed successful.
    }
    return 0; // Success.
}

/**
 * @brief Frees the memory allocated for a `PPMImage` structure.
 *
 * This function safely deallocates the `data` buffer (containing pixel data) if it
 * was allocated, and then frees the `PPMImage` structure itself.
 *
 * @param image Pointer to the `PPMImage` structure to be freed.
 *              If `NULL`, the function performs no action, preventing crashes.
 */
void free_ppm_image(PPMImage *image) {
    if (!image) { return; } // Safe to call with `NULL` pointer.
    if(image->data) { 
        free(image->data); // Free the pixel data buffer.
        image->data = NULL; // Good practice to `NULL` the pointer after freeing its memory.
    }
    free(image); // Free the `PPMImage` struct itself.
}


#ifdef UNIT_TEST_PPM_IO
/**
 * @brief Helper function to create a dummy `PPMImage` for testing purposes.
 *
 * This function allocates a `PPMImage` structure and fills its `data` buffer
 * with a simple, predictable pattern for testing `save_ppm_image` and `load_ppm_image`.
 *
 * @param width The desired width of the dummy image in pixels.
 * @param height The desired height of the dummy image in pixels.
 * @param val A base unsigned char value used to generate pixel data (some variation is added).
 * @return `PPMImage*` A pointer to the newly created `PPMImage` struct, or `NULL` on failure
 *                   (e.g., memory allocation error).
 */
static PPMImage* test_create_dummy_ppm(int width, int height, unsigned char val) {
    PPMImage* img = malloc(sizeof(PPMImage));
    if (!img) return NULL; // Check malloc for struct.
    img->width = width; img->height = height; img->channels = 3; // Standard RGB.
    if (width == 0 || height == 0) { // Handle zero-dimension images gracefully.
        img->data = NULL; // No pixel data for 0-dimension images.
        return img;
    }
    size_t data_size = (size_t)width * height * 3; // Calculate total size for RGB data.
    img->data = malloc(data_size);
    if (!img->data && data_size > 0) { // Check malloc for data if a non-zero size was requested.
        free(img);
        return NULL;
    }
    // Fill with a simple pattern: `val` plus a small offset based on index (for some variation).
    for(size_t i=0; i < data_size; ++i) img->data[i] = (unsigned char)(val + (i % 50)); 
    return img;
}

/**
 * @brief Helper function to compare two `PPMImage` structures for equality.
 *
 * This function checks if two `PPMImage` structures have the same dimensions,
 * channel count, and byte-for-byte identical pixel data.
 *
 * @param img1 Pointer to the first `PPMImage`.
 * @param img2 Pointer to the second `PPMImage`.
 * @return `int` 1 if the images are identical, 0 otherwise.
 */
static int test_compare_ppm(const PPMImage* img1, const PPMImage* img2) {
    if (!img1 && !img2) return 1; // Both `NULL` is considered the same for testing.
    if (!img1 || !img2) return 0; // One `NULL`, one not is different.
    // Compare dimensions and channel count.
    if (img1->width != img2->width || img1->height != img2->height || img1->channels != img2->channels) return 0;
    // Check if `data` pointers are both `NULL` or both non-`NULL`.
    if ((img1->data == NULL) != (img2->data == NULL)) return 0;
    if (img1->data) { // If `data` is not `NULL` (implies `img2->data` is also not `NULL` and dimensions > 0).
        // Compare the raw pixel data byte-for-byte.
        return memcmp(img1->data, img2->data, (size_t)img1->width * img1->height * img1->channels) == 0;
    }
    return 1; // Both have `NULL` data, and dimensions matched (e.g., for 0xN images), so they are equal.
}

/**
 * @brief Main function for unit testing `ppm_image_io.c`.
 *
 * This function rigorously tests the `save_ppm_image` and `load_ppm_image` functions
 * by performing various scenarios:
 * 1.  Saving a small, valid image and then loading it back, verifying byte-for-byte data integrity.
 * 2.  Saving an image with zero width (0xN dimensions) and loading it back,
 *     ensuring proper handling of such edge cases.
 * Temporary files are created and removed to keep the test environment clean.
 *
 * To compile and run this unit test (assuming Makefile setup):
 * `make test_ppm_image_io`
 *
 * @return `int` 0 if all tests pass successfully, 1 if any test fails.
 */
int main() {
    printf("--- Unit Test for ppm_image_io ---\n");
    const char* test_file = "test_ppm_io_temp.ppm"; // Temporary file used for I/O testing.
    PPMImage *img_orig, *img_loaded;

    // Test 1: Save and load a small, valid image (5x3 pixels).
    img_orig = test_create_dummy_ppm(5, 3, 100); // Create a 5x3 dummy image.
    if (!img_orig) { printf("Test 1 FAILED: Dummy image creation failed.\n"); return 1;}
    printf("Test 1: Saving 5x3 image...\n");
    if (save_ppm_image(test_file, img_orig) != 0) {
        printf("Test 1 FAILED: save_ppm_image encountered an error.\n");
        free_ppm_image(img_orig); return 1;
    }
    img_loaded = load_ppm_image(test_file); // Load the saved image back.
    if (!img_loaded) {
        printf("Test 1 FAILED: load_ppm_image returned NULL.\n");
        free_ppm_image(img_orig); remove(test_file); return 1; // Clean up and exit.
    }
    // Compare the original image with the loaded image.
    if (test_compare_ppm(img_orig, img_loaded)) {
        printf("Test 1 PASSED: Image saved and loaded successfully.\n");
    } else {
        printf("Test 1 FAILED: Images differ after save/load operation.\n");
    }
    free_ppm_image(img_orig);   // Free original image memory.
    free_ppm_image(img_loaded); // Free loaded image memory.
    remove(test_file); // Remove the temporary test file.

    // Test 2: Save and load an image with zero width (e.g., 0x10 pixels).
    img_orig = test_create_dummy_ppm(0, 10, 0); // Create a 0-width dummy image.
    if (!img_orig) { printf("Test 2 FAILED: Dummy image creation for 0-width failed.\n"); return 1;}
    printf("Test 2: Saving 0x10 image...\n");
    if (save_ppm_image(test_file, img_orig) != 0) {
        printf("Test 2 FAILED: save_ppm_image (0-width) encountered an error.\n");
        free_ppm_image(img_orig); return 1;
    }
    img_loaded = load_ppm_image(test_file); // Load the 0-width image back.
     if (!img_loaded) {
        printf("Test 2 FAILED: load_ppm_image (0-width) returned NULL.\n");
        free_ppm_image(img_orig); remove(test_file); return 1;
    }
    // Verify that the loaded image correctly represents a 0-width image (width=0, height=10, data=NULL).
    if (img_loaded->width == 0 && img_loaded->height == 10 && img_loaded->data == NULL) {
        printf("Test 2 PASSED: 0-width image handling is correct.\n");
    } else {
        printf("Test 2 FAILED: 0-width image loaded incorrectly (w:%d,h:%d,data:%p).\n", img_loaded->width, img_loaded->height, (void*)img_loaded->data);
    }
    free_ppm_image(img_orig);
    free_ppm_image(img_loaded);
    remove(test_file); // Remove the temporary test file.

    printf("--- Unit Test for ppm_image_io Finished ---\n");
    return 0;
}
#endif // UNIT_TEST_PPM_IO

// ppm_image_io.c
// Bottom


// schwarzschild_tracer.h
// Top

#ifndef SCHWARZSCHILD_TRACER_H
#define SCHWARZSCHILD_TRACER_H
/**
 * @file schwarzschild_tracer.h
 * @brief Main header file for the Schwarzschild Ray Tracer library.
 *
 * This header defines common constants, data structures, and public function
 * declarations used across all modules of the Schwarzschild Ray Tracer project.
 * It serves as the central interface for interacting with the library's
 * functionalities, including geodesic integration, image mapping, and photon rendering.
 *
 * @note This file is crucial for ensuring type consistency and access to shared
 *       parameters and utility functions throughout the codebase.
 */

// Standard C Headers (that are generally useful for this library)
#include <sys/stat.h> // For mkdir
#include <sys/types.h> // For mode_t (often implied by sys/stat.h)
#include <errno.h>    // For checking errno
#include <stdio.h>   // For standard I/O operations (e.g., printf, fprintf, FILE operations).
#include <stdlib.h>  // For general utilities (e.g., malloc, free, exit).
#include <string.h>  // For string manipulation functions (e.g., memcpy, strlen, strncmp).
#include <math.h>    // For mathematical functions (e.g., sqrt, cos, sin, fmod, fabs, acos, fmax, fmin).
#include <time.h>    // For time-related functions (e.g., time for performance measurement).
#include <stdint.h>  // For fixed-width integer types (e.g., uint32_t for binary file headers).
#include <stdbool.h> // For the boolean type `bool` and values `true`/`false`.
#include <ctype.h>   // For character classification functions (e.g., isspace).
#include <float.h>   // For floating-point limits (e.g., DBL_MAX, DBL_EPSILON, DBL_MIN).

// GSL Headers
#include <gsl/gsl_odeiv2.h> // For GNU Scientific Library's Ordinary Differential Equation (ODE) solver routines.
#include <gsl/gsl_vector.h> // For GSL vector operations (dynamic arrays of doubles).
#include <gsl/gsl_matrix.h> // Kept if any public interface uses it, otherwise can be removed. Not directly used in core modules.
#include <gsl/gsl_spline.h> // For GSL spline interpolation (e.g., for smooth trajectory reconstruction).
#include <gsl/gsl_roots.h>  // For GSL root-finding algorithms (e.g., for event detection).
#include <gsl/gsl_errno.h>  // For GSL error handling functions and macros.
#include <gsl/gsl_sys.h>    // For GSL system-specific functions (e.g., gsl_isnan for NaN checks).

// --- Constants ---
#ifndef M_PI // Guard for M_PI, as math.h might define it with _USE_MATH_DEFINES on some systems
#define M_PI 3.14159265358979323846 /**< @brief Mathematical constant Pi. */
#endif
#define MAX_EVENT_TYPES_CORE 100 /**< @brief Maximum number of distinct event functions that can be registered with the core ODE integrator. Used for static array sizing. */
#define MAX_K_PER_GSL_SUPER_STEP 1e-3 /**< @brief The maximum affine parameter step size for a single GSL ODE driver `gsl_odeiv2_driver_apply` call. This value effectively sets the largest integration step. */
#define DEFAULT_T_END 1e6 /**< @brief Default maximum affine parameter (`\kappa`) value for geodesic integration. This acts as a fallback termination condition. */
#define DEFAULT_NUM_INTERP_POINTS 1000 /**< @brief Default number of interpolated points for a full photon trajectory output. Controls the resolution of the returned trajectory data. */
#define DEFAULT_CHUNK_SIZE_PHOTONS 1000000 /**< @brief Default number of `PhotonMapDataPoint`s to store in a single binary chunk file. Balances memory usage and I/O efficiency for large datasets. */
#define EPSILON_GENERAL 1e-9 /**< @brief A small floating-point tolerance used for general-purpose comparisons (e.g., near-zero checks, equality with tolerance). */
#define EVENT_DETECTION_TOLERANCE 1e-9 /**< @brief Numerical tolerance for event detection and root-finding algorithms. Critical for precision in identifying physical events like turning points. */
#define MAX_FILENAME_LEN 16384 /**< @brief Maximum length for dynamically generated filenames, including path and null terminator. */
#define INITIAL_RAW_POINTS_CAPACITY 256 /**< @brief Initial allocated capacity for GSL vectors storing raw (K, r, phi) points from ODE solver steps within a trajectory segment. */
#define INITIAL_SEGMENTS_CAPACITY 10 /**< @brief Initial allocated capacity for the list of `TrajectorySegmentDataInternal` structs. This list grows as the trajectory crosses turning points. */
#define INITIAL_CROSSING_POINTS_CAPACITY 8 /**< @brief Initial allocated capacity for GSL vectors storing y-coordinates of crossings at target planes. Used for dynamic allocation. */
#define INITIAL_SAVED_FILES_CAPACITY 10 /**< @brief Initial allocated capacity for the array of strings storing paths to generated chunk files. */
#define EPSILON_GENERAL 1e-9 /**< @brief A small floating-point tolerance used for general-purpose comparisons (e.g., near-zero checks, equality with tolerance). */

// --- Public Struct Definitions ---

/**
 * @brief Parameters for the Schwarzschild geodesic Ordinary Differential Equations (ODEs).
 *
 * This struct bundles the essential physical constants required by the ODE system
 * `schwarzschild_geodesic_eqs`. It allows these parameters to be passed conveniently
 * to the GSL ODE solver.
 */
typedef struct {
    double M;        /**< @brief Black hole mass (in geometric units). */
    double b;        /**< @brief Photon's impact parameter (dimensionless, a conserved quantity). */
    int *sign_dr_dk; /**< @brief Pointer to a mutable integer representing the sign of `dr/dK` (radial motion direction: +1 for outward, -1 for inward). This is dynamically flipped at turning points. */
} ODEParams;

/**
 * @brief Parameters for event functions within the geodesic integration.
 *
 * This struct provides context to various event detection functions (`get_event_val_fr_zero`,
 * `get_event_val_r_leq_2M`, `get_event_val_r_max`, `get_event_val_x_stop`, `get_event_val_x_target`).
 * It stores the specific thresholds or values these functions need to monitor for.
 */
typedef struct {
    double M;          /**< @brief Black hole mass. Used for horizon detection (`2M`). */
    double b;          /**< @brief Photon's impact parameter. Used for radial potential `R(r)` calculation. */
    double r_max_event; /**< @brief Radial distance at which an escape event is triggered. */
    double x_stop_event; /**< @brief Cartesian X-coordinate at which a general termination event is triggered. */
    double x_target_event; /**< @brief Cartesian X-coordinate for a specific target plane crossing event. */
    ODEParams *ode_p_event; /**< @brief Pointer to the `ODEParams` structure for the current integration. Provides access to `M` and `b` used in the ODEs for consistency. */
} EventFunctionParams;

/**
 * @brief Structure to store a complete photon trajectory and associated data.
 *
 * This struct serves as the primary output for the `compute_trajectory` function.
 * It contains dynamically allocated GSL vectors holding the interpolated trajectory
 * points (in terms of affine parameter, radial coordinate, azimuthal angle, and
 * Cartesian x/y coordinates). It also includes a mechanism to store y-coordinates
 * where the ray intersects specified target planes.
 */
typedef struct {
    gsl_vector *x; /**< @brief GSL vector of Cartesian x-coordinates for the interpolated trajectory. */
    gsl_vector *y; /**< @brief GSL vector of Cartesian y-coordinates for the interpolated trajectory. */
    gsl_vector *r; /**< @brief GSL vector of radial coordinates (r) for the interpolated trajectory. */
    gsl_vector *phi; /**< @brief GSL vector of unwrapped azimuthal angles (phi) for the interpolated trajectory. */
    gsl_vector *K; /**< @brief GSL vector of affine parameter (K) values for the interpolated trajectory. */
    gsl_vector **crossings_y_at_x_targets; /**< @brief Array of pointers to GSL vectors. Each `gsl_vector` stores the y-coordinates of crossings for a specific `x_target` plane. */
    size_t num_x_targets; /**< @brief Number of `x_target` planes for which crossings were recorded. Also the size of the `crossings_y_at_x_targets` array. */
    int error_code; /**< @brief Error code for the trajectory computation. 0 for success, negative for various failure modes. */
} PhotonTrajectory;

/**
 * @brief Structure to store only the y-coordinates of photon crossings at target planes.
 *
 * This struct serves as the output for the `compute_trajectory_crossings_only` function.
 * It is a lightweight alternative to `PhotonTrajectory` when only intersection data
 * with specific planes (e.g., observer window, source plane) is needed, without the
 * full trajectory history.
 */
typedef struct {
    gsl_vector **crossings_y_at_x_targets; /**< @brief Array of pointers to GSL vectors, where each `gsl_vector` holds the y-coordinates of crossings for a corresponding `x_target` plane. */
    size_t num_x_targets; /**< @brief Number of `x_target` planes defined, and thus the number of GSL vectors in the `crossings_y_at_x_targets` array. */
    int error_code; /**< @brief Error code for the crossing computation. 0 for success, negative for errors. */
} TrajectoryCrossings;

/**
 * @brief Result structure for the `image_map` and `image_map_radial` functions.
 *
 * This struct encapsulates the outcome of a single ray-tracing operation from the observer's
 * plane to the source plane. It indicates whether the ray successfully hit the target
 * source plane and provides the mapped y-coordinates on both the observer's window
 * and the source image plane.
 */
typedef struct {
    int miss;        /**< @brief Flag indicating if the ray missed the target source plane (1 if miss, 0 if hit). */
    double y_window; /**< @brief The y-coordinate (radial distance) where the ray effectively intersects the observer's virtual window plane. */
    double y_image;  /**< @brief The y-coordinate (radial distance) where the ray effectively intersects the background source image plane. This is the lensed mapping. */
    int error_code;  /**< @brief Error code for the mapping operation. 0 for successful execution, non-zero for internal errors. */
} ImageMapResult;

/**
 * @brief Data point structure for storing photon mapping results in binary chunks.
 *
 * This struct represents a single mapping from a point on the observer's 2D viewing plane
 * to a point on the 2D background source image plane. These points are typically generated
 * in large quantities by `results_generation.c` and saved as binary chunks.
 */
typedef struct {
    double y_window_cart_x; /**< @brief Cartesian x-coordinate (horizontal) on the observer's virtual window plane. */
    double y_window_cart_y; /**< @brief Cartesian y-coordinate (vertical/azimuthal) on the observer's virtual window plane. */
    double y_image_cart_x;  /**< @brief Cartesian x-coordinate (horizontal) on the background source image plane (lensed position). */
    double y_image_cart_y;  /**< @brief Cartesian y-coordinate (vertical/azimuthal) on the background source image plane (lensed position). */
} PhotonMapDataPoint;

/**
 * @brief Structure representing an RGB color.
 *
 * Defines a color using 8-bit unsigned integer components for Red, Green, and Blue.
 */
typedef struct {
    unsigned char r, g, b; /**< @brief Red, Green, and Blue color components, each ranging from 0 to 255. */
} RGBColor;

/**
 * @brief Structure representing a PPM (Portable Pixmap) image.
 *
 * Stores raw pixel data, image dimensions, and number of color channels.
 * Supports P6 (binary RGB) format, which uses 3 channels.
 */
typedef struct {
    unsigned char *data; /**< @brief Pointer to the raw pixel data (interleaved RGB bytes). The caller is responsible for freeing this memory. */
    int width;           /**< @brief Width of the image in pixels. */
    int height;          /**< @brief Height of the image in pixels. */
    int channels;        /**< @brief Number of color channels per pixel (expected to be 3 for RGB). */
} PPMImage;

/**
 * @brief Output structure for the `results_radial_light_ring` function.
 *
 * This struct bundles the filenames of generated photon data chunks and GSL vectors
 * containing information about radial sample points that resulted in photon hits or misses
 * on the source plane. This additional data is specific to light ring studies.
 */
typedef struct {
    char** saved_files_list;         /**< @brief Dynamically allocated array of strings (char*), where each string is the path to a created binary chunk file. This array is NULL-terminated. */
    gsl_vector* r_sample_misses;    /**< @brief GSL vector storing initial radial positions (`\rho`) on the observer's window that resulted in photons missing the source plane (e.g., falling into the BH). */
    gsl_vector* r_sample_hits;      /**< @brief GSL vector storing initial radial positions (`\rho`) on the observer's window that resulted in photons successfully hitting the source plane. */
    int num_files_created;          /**< @brief The actual count of file paths stored in `saved_files_list`. */
    int capacity_saved_files;       /**< @brief The current allocated capacity of the `saved_files_list` array. Managed internally. */
} ResultsRadialLightRingOutput;


// --- Public Function Declarations ---

// From trajectory_module.c
/**
 * @brief Normalizes an angle to the standard range `[0, 2\pi)`.
 *
 * This utility function maps an angle in radians to its equivalent value within the
 * `[0, 2\pi)` interval. It is essential for consistent angular representation,
 * especially after numerical integrations or trigonometric functions that might
 * produce angles outside this range.
 *
 * @param phi The input angle in radians.
 * @return `double` The normalized angle in radians, guaranteed to be within `[0, 2\pi)`.
 */
double normalize_phi(double phi);

/**
 * @brief Appends a double value to a dynamically managed GSL vector.
 *
 * This function provides a robust way to add elements to a GSL vector, handling
 * automatic memory reallocation (doubling capacity) when the vector's current
 * allocated space is exceeded. It ensures that the vector grows efficiently
 * without requiring manual memory management from the caller.
 *
 * @param vec_ptr Pointer to the `gsl_vector` pointer (`gsl_vector**`). This allows the function
 *                to allocate or reallocate the vector and update the caller's pointer. Must not be `NULL`.
 * @param value_param The `double` value to append to the vector.
 * @param current_capacity_ptr Pointer to a `size_t` variable that tracks the current
 *                             allocated physical capacity of `*vec_ptr`'s underlying data array.
 *                             This value is updated by the function if reallocation occurs. Must not be `NULL`.
 * @return `int` 0 on success.
 *             -1 on failure (e.g., initial allocation error, reallocation failure, or invalid input pointers).
 *             -2 if an internal state inconsistency is detected (should ideally not happen).
 */
int gsl_vector_dynamic_append(gsl_vector **vec_ptr, double value_param, size_t *current_capacity_ptr);

/**
 * @brief Computes a full photon trajectory in Schwarzschild spacetime.
 *
 * This function initiates a light ray from an observer's position (`r_0`, `phi_0`)
 * with a specified initial direction (`psi`) and traces its path through the curved
 * Schwarzschild spacetime. It numerically integrates the geodesic equations using
 * an adaptive ODE solver and returns the interpolated trajectory (K, r, phi, x, y)
 * over a specified number of points. It can also detect and record crossings at
 * arbitrary target x-planes.
 *
 * @param r_0 Initial radial coordinate of the photon (observer's position), in Schwarzschild radii (geometric units).
 * @param phi_0 Initial azimuthal angle of the photon (observer's initial angle), in radians.
 * @param M Black hole mass, used in the Schwarzschild metric (in geometric units).
 * @param psi Initial angle of the photon's 3-velocity relative to the radial direction at `r_0`, in radians. This defines the impact parameter `b`.
 * @param r_max Maximum radial distance the photon can reach before integration terminates (photon escapes).
 * @param x_stop_val Cartesian x-coordinate for an early termination plane.
 * @param x_stop_active Flag indicating if the `x_stop_val` termination condition is active (`true`) or ignored (`false`).
 * @param x_targets A GSL vector of `double` values, specifying Cartesian x-coordinates of planes where y-crossings should be recorded. Can be `NULL` if no specific crossings are needed.
 * @param t_end Maximum affine parameter (`\kappa`) value for integration. Serves as a fallback termination condition.
 * @param num_interp_points Desired number of interpolated points in the output trajectory. If 0, a default value is used.
 * @return `PhotonTrajectory*` A pointer to a dynamically allocated `PhotonTrajectory` struct containing the computed path and crossings. Returns `NULL` on critical allocation failure. The caller is responsible for freeing this struct using `free_photon_trajectory`.
 * @note The integration uses an adaptive step-size GSL ODE solver (`rkf45`) for accuracy.
 * @note This function handles radial turning points and various termination conditions (capture, escape, `x_stop`, `t_end`).
 */
PhotonTrajectory* compute_trajectory(
    double r_0, double phi_0, double M, double psi, double r_max,
    double x_stop_val, bool x_stop_active,
    const gsl_vector *x_targets,
    double t_end, int num_interp_points
);

/**
 * @brief Frees all dynamically allocated memory within a `PhotonTrajectory` struct.
 *
 * This function is the designated cleanup routine for `PhotonTrajectory` objects.
 * It deallocates all GSL vectors for K, r, phi, x, y, and any collected crossing data.
 * Finally, it frees the `PhotonTrajectory` struct itself.
 *
 * @param traj Pointer to the `PhotonTrajectory` struct to be freed. If `NULL`, the function performs no action.
 */
void free_photon_trajectory(PhotonTrajectory *traj);

/**
 * @brief Computes photon trajectory crossings at specified target x-planes without returning the full path.
 *
 * This is a specialized version of the trajectory computation function, optimized for
 * scenarios where only the intersection points (y-coordinates) with specific target
 * x-planes are required (e.g., for image mapping). It avoids the computational and
 * memory overhead of interpolating and returning the entire trajectory.
 *
 * @param r_0 Initial radial coordinate of the photon (observer's position).
 * @param phi_0 Initial azimuthal angle of the photon.
 * @param M Black hole mass.
 * @param psi Initial angle of the photon's 3-velocity relative to the radial direction.
 * @param r_max Maximum radial distance before termination.
 * @param x_stop_val Cartesian x-coordinate for an early termination plane.
 * @param x_stop_active Flag to activate the `x_stop_val` termination condition.
 * @param x_targets A GSL vector of `double` values, specifying Cartesian x-coordinates of planes where y-crossings should be recorded. This parameter is mandatory (must not be `NULL`).
 * @param t_end Maximum affine parameter value for integration.
 * @return `TrajectoryCrossings*` A pointer to a dynamically allocated `TrajectoryCrossings` struct containing only the recorded y-crossings. Returns `NULL` on critical allocation failure or if `x_targets` is `NULL`. The caller is responsible for freeing this struct using `free_trajectory_crossings`.
 * @note This function is particularly efficient for reverse ray tracing applications that only need the final lensed image coordinates.
 */
TrajectoryCrossings* compute_trajectory_crossings_only(
    double r_0, double phi_0, double M, double psi, double r_max,
    double x_stop_val, bool x_stop_active,
    const gsl_vector *x_targets, double t_end,
    bool force_log_this_ray_in_core // <<<< THIS MUST BE ADDED HERE
);
/**
 * @brief Frees all dynamically allocated memory within a `TrajectoryCrossings` struct.
 *
 * This function is the designated cleanup routine for `TrajectoryCrossings` objects.
 * It deallocates all GSL vectors holding y-crossing data and then the struct itself.
 *
 * @param crossings Pointer to the `TrajectoryCrossings` struct to be freed. If `NULL`, the function performs no action.
 */
void free_trajectory_crossings(TrajectoryCrossings *crossings);

// From image_mapping_utils.c
/**
 * @brief Maps a point from the observer's viewing plane to the background source image plane.
 *
 * This function performs a reverse ray tracing calculation for a single light ray.
 * It initiates a ray from the observer's position (`x_2_observer`) towards a specific point
 * (`Y`, `Z`) on the observer's virtual window plane (`x_1_window`). It then traces this ray
 * backward through Schwarzschild spacetime to determine where it originated on the distant
 * background source image plane (`x_0_plane`).
 *
 * @param Y The Cartesian y-coordinate on the observer's virtual window plane.
 * @param Z The Cartesian z-coordinate on the observer's virtual window plane.
 * @param x_0_plane The x-coordinate of the background source image plane.
 * @param x_1_window The x-coordinate of the observer's virtual screen or "window" plane.
 * @param x_2_observer The x-coordinate of the observer's position (ray's starting point).
 * @param a_scale A characteristic length scale used for determining the integration domain (`r_max_integration`).
 * @return `ImageMapResult` A struct containing `miss` status, `y_window` (radial distance on window), `y_image` (radial distance on source plane), and an `error_code`.
 * @note The calculation of the initial photon direction (`psi_calc`) and the subsequent impact parameter (`b`) are critical and derived to hit the target `(Y,Z)` on the window in flat space.
 * @see `compute_trajectory_crossings_only` for the underlying ray tracing.
 */
ImageMapResult image_map(
    double Y, double Z, double x_0_plane, double x_1_window, double x_2_observer, double a_scale,
    bool force_log_this_ray_in_core // <<<< ADD THIS NEW PARAMETER HERE
);
/**
 * @brief Specialized version of `image_map` for rays with Z=0 (purely radial offset).
 *
 * This function is a convenience wrapper around `image_map` for scenarios
 * where the initial ray's offset from the x-axis is purely radial (`r_rho`),
 * simplifying the input by assuming the z-coordinate is zero. It's often used
 * in axially symmetric lensing problems.
 *
 * @param r_rho The radial distance (`\rho`) on the observer's window plane from the x-axis.
 * @param x_0_plane The x-coordinate of the background source image plane.
 * @param x_1_window The x-coordinate of the observer's virtual window plane.
 * @param x_2_observer The x-coordinate of the observer's position.
 * @param a_scale_factor A scaling factor, used in calculating `r_max_integration`.
 * @return `ImageMapResult` A struct containing hit status and mapped y-coordinates, identical to `image_map`.
 * @see `image_map`
 */
ImageMapResult image_map_radial(
    double r_rho, double x_0_plane, double x_1_window, double x_2_observer, double a_scale_factor
);

// From results_generation.c
/**
 * @brief Generates photon mapping data by sampling rays on a Cartesian grid on the observer's window.
 *
 * This function simulates reverse ray tracing for a large number of rays, sampling them
 * on a square grid within the observer's window plane. It leverages 8-fold or 4-fold
 * symmetry (for points on axes or diagonals) to optimize computation by only tracing
 * rays in the first octant (0 <= Z <= Y <= `a_param`). The results (`PhotonMapDataPoint`s)
 * are collected and periodically saved to binary chunk files.
 *
 * @param x_0 The x-coordinate of the background source image plane.
 * @param x_1 The x-coordinate of the observer's "window" plane.
 * @param x_2 The x-coordinate of the observer's position.
 * @param a_param The half-width/height of the square sampling region on the observer's window.
 * @param n_param The number of discrete divisions along one axis of the sampling region in the first octant.
 * @param chunk_size_photons The maximum number of `PhotonMapDataPoint`s to accumulate before saving to a new binary chunk file. If 0, `DEFAULT_CHUNK_SIZE_PHOTONS` is used.
 * @param out_num_files_created Output parameter: a pointer to an integer where the total number of binary chunk files created will be stored.
 * @return `char**` An array of strings, where each string is the path to a created binary chunk file. The array is `NULL`-terminated. Returns `NULL` on critical failure. The caller is responsible for freeing this array and its contents using `free_string_array`.
 * @note The sampling strategy and symmetry considerations are based on Schwarzschild_Lens_Paper.pdf, Section 3.2.
 */
char** results_cartesian(
    double x_0, double x_1, double x_2, double a_param, int n_param,
    size_t chunk_size_photons, int* out_num_files_created
);

/**
 * @brief Generates photon mapping data by sampling rays in a radial pattern on the observer's window.
 *
 * This function samples light rays originating from concentric circles on the observer's
 * window plane. For each radial distance, `image_map_radial` is called, and then
 * multiple angular steps are taken around the circle to generate a dense set of points.
 * The results (`PhotonMapDataPoint`s) are collected and periodically saved to binary chunk files.
 * This method is efficient for axially symmetric lensing effects.
 *
 * @param x_0 The x-coordinate of the background source image plane.
 * @param x_1 The x-coordinate of the observer's "window" plane.
 * @param x_2 The x-coordinate of the observer's position.
 * @param R_max_sample The maximum radial distance on the observer's window plane to sample.
 * @param n_param The number of radial divisions for sampling `r_s_val` from 0 to `R_max_sample`.
 * @param chunk_size_photons The maximum number of `PhotonMapDataPoint`s per output binary file.
 * @param out_num_files_created Output parameter: a pointer to an integer storing the total number of created chunk files.
 * @return `char**` An array of strings, where each string is the path to a created binary chunk file. The array is `NULL`-terminated. Returns `NULL` on critical failure. The caller is responsible for freeing this array and its contents using `free_string_array`.
 * @note The dynamic angular sampling ensures consistent density with increasing radius.
 */
char** results_radial(
    double x_0, double x_1, double x_2, double R_max_sample, int n_param,
    size_t chunk_size_photons, int* out_num_files_created
);

/**
 * @brief Generates photon mapping data by densely sampling a narrow annular region (light ring segment).
 *
 * This specialized function focuses on high-resolution sampling within a very narrow
 * radial and angular region on the observer's window, specifically designed to capture
 * fine light ring features (e.g., Einstein rings near the photon sphere). It uses
 * predefined constants for the sampling range. It also records hit/miss statistics for analysis.
 *
 * @param x_0 The x-coordinate of the background source image plane.
 * @param x_1 The x-coordinate of the observer's "window" plane.
 * @param x_2 The x-coordinate of the observer's position.
 * @param n_param The number of radial divisions for sampling within the narrow light-ring annulus.
 * @param chunk_size_photons The maximum number of `PhotonMapDataPoint`s per output binary file.
 * @return `ResultsRadialLightRingOutput*` A pointer to a struct containing the list of created chunk files and hit/miss statistics. Returns `NULL` on critical failure. The caller is responsible for freeing this struct using `free_results_radial_light_ring_output`.
 * @note This function is designed to probe features related to Figure 9 of Schwarzschild_Lens_Paper.pdf.
 */
ResultsRadialLightRingOutput* results_radial_light_ring(
    double x_0, double x_1, double x_2, int n_param,
    size_t chunk_size_photons
);

/**
 * @brief Frees all memory allocated for a `ResultsRadialLightRingOutput` structure.
 *
 * This function deallocates the list of saved file paths (and the strings within it),
 * the GSL vectors for hit/miss samples, and the `ResultsRadialLightRingOutput` struct itself.
 *
 * @param output Pointer to the `ResultsRadialLightRingOutput` struct to be freed. If `NULL`, no action is performed.
 */
void free_results_radial_light_ring_output(ResultsRadialLightRingOutput* output);

/**
 * @brief Frees a dynamically allocated array of strings (`char**`).
 *
 * This utility function iterates through an array of string pointers, freeing each
 * individual string (assuming they were dynamically allocated, e.g., by `strdup`),
 * and then frees the array of pointers itself.
 *
 * @param arr The array of strings (`char**`) to be freed. If `NULL`, no action is performed.
 * @param count The number of actual string pointers in the array that need to be freed.
 */
void free_string_array(char** arr, int count); // General utility

// From photon_rendering.c
/**
 * @brief Renders a gravitationally lensed image from photon trajectory data.
 *
 * This function synthesizes a lensed image by processing pre-calculated photon
 * mapping data (from `PhotonMapDataPoint` chunks) and sampling colors from a source image.
 * It supports two modes: "Full View" (Mode A), where the output field of view is
 * automatically determined by photon hits, and "Windowed View" (Mode B), where a
 * specific observer window is explicitly defined. Pixels are super-sampled for
 * anti-aliasing.
 *
 * @param image_source_path Path to the source PPM image file (input). Can be `NULL` if `image_source_data_param` is provided.
 * @param image_source_data_param Pointer to an already loaded `PPMImage` struct (input). Can be `NULL` if `image_source_path` is provided.
 * @param photon_chunk_files An array of strings, each a path to a binary photon data chunk file.
 * @param num_chunk_files The number of chunk files in `photon_chunk_files`. If -1, the array is assumed `NULL`-terminated.
 * @param save_path Path where the final rendered PPM image will be saved. If `NULL` or empty, image is processed but not saved.
 * @param source_logical_width_input The logical width of the source image in simulation units.
 * @param target_output_pixel_width The desired pixel width of the output lensed image.
 * @param observer_window_bounds If `NULL`, Mode A (auto FOV) is used. If not `NULL`, a `double[4]` array `{y0_min, y0_max, z0_min, z0_max}` for Mode B (explicit window).
 * @param default_color The `RGBColor` to use for pixels not hit by any photons.
 * @return `int` 0 on success (image processed, saved if `save_path` valid). -1 on critical error.
 * @note The rendering process aligns with the reverse ray tracing concept in Schwarzschild_Lens_Paper.pdf, Section 3.2.
 */
int map_photons(
    const char *image_source_path,
    PPMImage *image_source_data_param,
    char **photon_chunk_files,
    int num_chunk_files_param,
    const char *save_path,
    double source_logical_width_input,
    int target_output_pixel_width,
    const double *observer_window_bounds,
    RGBColor default_color_param
);

// From photon_chunk_io.c
/**
 * @brief Saves an array of `PhotonMapDataPoint` structures to a binary file in chunks.
 * ... (existing comment for save_photon_data_chunk) ...
 */
int save_photon_data_chunk(const char *filename, const PhotonMapDataPoint* data, size_t num_points);

/**
 * @brief Loads `PhotonMapDataPoint` structures from a binary file previously saved by `save_photon_data_chunk`.
 * ... (existing comment for load_photon_data_chunk) ...
 */
PhotonMapDataPoint* load_photon_data_chunk(const char *filename, size_t *num_points_read);

/**
 * @brief Prints an array of `PhotonMapDataPoint` structures directly to standard output as raw binary.
 *
 * This function serializes the data directly from memory into `stdout` using the same binary
 * format as `save_photon_data_chunk` (uint32_t count followed by raw data). This is useful
 * for streaming data out of a process, especially from sandboxed environments where direct
 * file access might be restricted.
 *
 * @param data A pointer to the array of `PhotonMapDataPoint` structures in memory.
 * @param num_points The number of `PhotonMapDataPoint` structures in the `data` array.
 * @return `int` 0 on success, -1 on a general I/O error, -2 for overflow, -3 for null data pointer.
 */
int print_photon_data_chunk_to_stdout_from_memory(const PhotonMapDataPoint* data, size_t num_points);

// From ppm_image_io.c
/**
 * @brief Loads a PPM image from a file in P6 (binary RGB) format.
 *
 * This function parses the PPM header (magic number, width, height, max color value),
 * validates its content, allocates memory for pixel data, and reads the raw binary pixel data.
 * It handles comments and whitespace robustly in the header.
 *
 * @param filename The path to the PPM file to load.
 * @return `PPMImage*` A pointer to a dynamically allocated `PPMImage` struct containing the loaded image data. Returns `NULL` on any error (e.g., file not found, invalid format, memory allocation failure). The caller is responsible for freeing this struct using `free_ppm_image`.
 * @note Only P6 format with max color value 255 is supported.
 */
PPMImage* load_ppm_image(const char *filename);

/**
 * @brief Saves a `PPMImage` structure to a file in P6 (binary RGB) format.
 *
 * This function writes the PPM header and then the raw binary pixel data from the
 * `PPMImage` structure to the specified file. It performs basic validation on the
 * input `PPMImage` to ensure it's suitable for saving (e.g., 3 channels).
 *
 * @param filename The path to the output PPM file. The file will be created or overwritten.
 * @param image A pointer to the `PPMImage` structure to be saved. Must have valid dimensions and 3 channels.
 * @return `int` 0 on success. -1 on error (e.g., invalid input, file opening/writing failure).
 */
int save_ppm_image(const char *filename, const PPMImage *image);

/**
 * @brief Frees the memory allocated for a `PPMImage` structure.
 *
 * This function safely deallocates the `data` buffer (pixel data) if it was allocated,
 * and then frees the `PPMImage` structure itself.
 *
 * @param image Pointer to the `PPMImage` structure to be freed. If `NULL`, the function performs no action.
 */
void free_ppm_image(PPMImage *image);

#endif // SCHWARZSCHILD_TRACER_H

// schwarzschild_tracer.h
// Bottom

// trajectory_module.c
// Top

/**
 * @file trajectory_module.c
 * @brief Core module for computing photon trajectories in Schwarzschild spacetime.
 *
 * This module is central to the ray tracing pipeline. It implements the numerical integration
 * of photon geodesics in the equatorial plane (`\theta = \pi/2`) of a Schwarzschild black hole,
 * utilizing the GSL (GNU Scientific Library) ODE solver (`gsl_odeiv2_driver`) and its
 * associated root-finding utilities (`gsl_root_fsolver`) for precise event detection.
 *
 * Key functionalities provided:
 * -   **ODE System Definition:** Implements the right-hand sides of the first-order ODEs
 *     for `dr/d\kappa` and `d\phi/d\kappa`, as derived from the Schwarzschild metric (Eqs. 7 & 8
 *     from Schwarzschild_Lens_Paper.pdf, page 9). `\kappa` is the rescaled affine parameter.
 * -   **Event Detection:** Monitors for specific physical conditions (events) along the trajectory,
 *     such as:
 *     -   Radial turning points where the radial velocity vanishes (`R(r) = 0`, Eq. 5, page 8).
 *     -   Photon capture (reaching the event horizon, `r \le 2M`).
 *     -   Photon escape (reaching a predefined maximum radius, `r \ge r_{max}`).
 *     -   Crossing a general termination plane (`x_{stop}`).
 *     -   Crossing user-defined target planes (`x_{target}`) for image mapping.
 * -   **Trajectory Segmentation and Handling Turning Points:** When a turning point is detected,
 *     the integration is paused, the sign of `dr/d\kappa` is flipped, and the trajectory is
 *     slightly nudged to restart integration stably (as discussed in §3.1.3 of the paper). The
 *     trajectory is effectively broken into segments.
 * -   **Data Collection and Interpolation:**
 *     -   Can output a full, interpolated trajectory (K, r, phi, x, y) over a specified number of points.
 *     -   Can output only the y-coordinates of crossings at target x-planes.
 *
 * The central integration logic is encapsulated in the static function `integrate_photon_trajectory_core`.
 * Public API functions (`compute_trajectory` and `compute_trajectory_crossings_only`) serve as
 * convenient wrappers around this core function.
 */

#define _POSIX_C_SOURCE 200809L // Ensures POSIX-compliant features (e.g., `strdup` if used, for `fmod` in `math.h` if older standards conflicts, or general compatibility).
#include "schwarzschild_tracer.h" 
#include <float.h> // For `DBL_MAX`, `DBL_EPSILON`, `DBL_MIN` (essential for floating-point comparisons and initialization).
// Other standard C and GSL headers are included via `schwarzschild_tracer.h`.

// --- Helper Macros ---
/**
 * @def CHECK_GSL_ALLOC_VEC_CORE(ptr, func_name, item_name_str, err_var, err_val, cleanup_label)
 * @brief Macro to check for successful allocation of a GSL vector.
 *
 * If the allocation fails (ptr is NULL), an error message is printed to stderr,
 * a specified error variable is set, and a `goto` is performed to a cleanup label.
 * This ensures consistent error handling and resource cleanup within functions,
 * promoting robust memory management throughout the core integration logic.
 *
 * @param ptr The pointer to the GSL vector (e.g., `gsl_vector *`) that was just allocated.
 * @param func_name A string literal for the name of the calling function, used in error messages.
 * @param item_name_str A string literal describing what was being allocated (e.g., "K vector", "r_temp").
 * @param err_var The integer variable (e.g., `core_error_code`) to set with the error value on failure.
 * @param err_val The integer value to assign to `err_var` on allocation failure.
 * @param cleanup_label The `goto` label to jump to for centralized error cleanup.
 */




#define CHECK_GSL_ALLOC_VEC_CORE(ptr, func_name, item_name_str, err_var, err_val, cleanup_label) \
    if ((ptr) == NULL) { fprintf(stderr, "%s: GSL vector allocation failed for %s. Out of memory?\n", func_name, item_name_str); err_var = err_val; goto cleanup_label; }

/**
 * @def CHECK_ALLOC_GEN_CORE(ptr, func_name, type_name_str, err_var, err_val, cleanup_label)
 * @brief Macro to check for successful allocation of general memory (e.g., `malloc`, `calloc`).
 *
 * Similar to `CHECK_GSL_ALLOC_VEC_CORE`, but for non-GSL memory allocations.
 * Ensures an error message is printed to stderr, sets an error variable, and jumps
 * to a cleanup label on failure. This standardizes error handling for `malloc` and `calloc` calls
 * within the core integration functions.
 *
 * @param ptr The pointer to the allocated memory (e.g., `void *`) that was just allocated.
 * @param func_name A string literal for the name of the calling function, used in error messages.
 * @param type_name_str A string literal describing the allocated type (e.g., "struct array", "ODEParams").
 * @param err_var The integer variable to set with the error value on failure.
 * @param err_val The integer value to assign to `err_var` on allocation failure.
 * @param cleanup_label The `goto` label to jump to for centralized error cleanup.
 */
#define CHECK_ALLOC_GEN_CORE(ptr, func_name, type_name_str, err_var, err_val, cleanup_label) \
    if ((ptr) == NULL) { fprintf(stderr, "%s: Standard allocation failed for %s. Out of memory?\n", func_name, type_name_str); err_var = err_val; goto cleanup_label; }

// --- Internal Struct Definitions for this Compilation Unit ---

/**
 * @struct GslRootEventParams
 * @brief Parameters structure for the GSL root-finding wrapper used in event detection.
 *
 * This structure bundles together all necessary context for the `gsl_root_event_wrapper`
 * function. This wrapper function is used by GSL's 1D root solvers (e.g., `gsl_root_fsolver_brent`)
 * to find the precise affine parameter `K` at which an event function (e.g., `get_event_val_fr_zero`)
 * evaluates to zero. It allows for linear interpolation of the photon's state (`y_state`)
 * to the trial `K` value provided by the GSL solver, using the states from the beginning
 * and end of the current ODE integration step. This ensures high-precision event localization.
 */

typedef struct {
    EventFunctionParams *event_params_root;
    double K_prev_super_step;
    double y_state_at_K_prev_super_step[2];    // r, phi at K_prev
    double f_derivs_at_K_prev_super_step[2]; // dr/dK, dphi/dK at K_prev
    double K_curr_super_step;
    double y_state_at_K_curr_super_step[2];    // r, phi at K_curr
    double f_derivs_at_K_curr_super_step[2]; // dr/dK, dphi/dK at K_curr
    double (*get_event_val_func_root)(double, const double[], EventFunctionParams*);
} GslRootEventParams;


typedef struct {
    gsl_spline *spline;           // Pointer to the initialized GSL spline object
    gsl_interp_accel *accel;     // Pointer to the GSL accelerator for spline evaluation
    // We might still need original EventFunctionParams if the core event function get_event_val_fr_zero
    // needs to be called to generate points for the spline, or if the spline itself is of a more generic event function.
    // For R(r(K)), we generate R values first, then spline K vs R.
} SplineRootParams;

/**
 * @struct TrajectorySegmentDataInternal
 * @brief Internal structure to temporarily store a segment of a photon trajectory.
 *
 * A complete photon trajectory can be composed of multiple continuous segments, especially
 * when it encounters radial turning points (where the `dr/dK` sign flips). This structure
 * holds the raw (K, r, phi) data points computed by the ODE solver for one such continuous
 * segment of the trajectory. These segments are later concatenated and interpolated
 * to form the final `PhotonTrajectory` output if a full trajectory is requested.
 * This approach is essential for handling complex trajectories with multiple turning points.
 */
typedef struct {
    gsl_vector *K_pts;   ///< @brief GSL vector storing affine parameter `K` values for this segment.
    gsl_vector *r_pts;   ///< @brief GSL vector storing radial coordinate `r` values for this segment, corresponding to `K_pts`.
    gsl_vector *phi_pts; ///< @brief GSL vector storing azimuthal angle `phi` values (raw, possibly wrapped) for this segment.
} TrajectorySegmentDataInternal;





// --- Forward Declarations for static functions defined in this file ---

// Core ODE system and event value getters
static int schwarzschild_geodesic_eqs(double K, const double y_state[], double f_derivs[], void *params_ptr);
static double get_event_val_fr_zero(double K, const double y_state[], EventFunctionParams *params);
static double get_event_val_r_leq_2M(double K, const double y_state[], EventFunctionParams *params);
static double get_event_val_r_max(double K, const double y_state[], EventFunctionParams *params);
static double get_event_val_x_stop(double K, const double y_state[], EventFunctionParams *params);
static double get_event_val_x_target(double K, const double y_state[], EventFunctionParams *params);

// Interpolation and root-finding helpers
static double cubic_hermite_interp_component(double t, double t0, double y0, double m0, double t1, double y1, double m1);
static double gsl_root_event_wrapper(double K_test, void *params_ptr); // For Hermite-based root finding
static double gsl_root_spline_wrapper(double K_test, void *params);    // For Spline-based root finding

static int find_event_time_gsl( // Hermite-based event finder
    double K_start_interval, double y_start_interval[], 
    double K_end_interval, double y_end_interval[],     
    GslRootEventParams *the_root_params, 
    int crossing_direction,
    double *K_event_found_gsl, double y_event_found_gsl[]);

static int find_tp_event_time_with_spline( // Spline-based TP event finder
    double K_app_step_start,
    double y_app_step_start_state[],
    double K_app_step_end,
    gsl_odeiv2_system *sys_ptr, 
    EventFunctionParams *event_p_fr_zero,
    bool is_target_ray_debug_c_from_caller, 
    double *K_event_found_spline
);

// Vector utilities (if they are static and local to this file)
static int reallocate_gsl_vector_if_needed(
    gsl_vector **vec_ptr, size_t current_logical_element_count,
    size_t *current_physical_capacity_ptr, size_t initial_capacity_val);
// Note: gsl_vector_dynamic_append and normalize_phi are likely public (in .h)
// If unwrap_phi_values is static and only used here:
static void unwrap_phi_values(const gsl_vector* K_raw, const gsl_vector* phi_raw, gsl_vector* phi_unwrapped);

// The main static worker function
static int integrate_photon_trajectory_core(
    double r_0, double phi_0, double M_val, double psi, double r_max_val,
    double x_stop_val, bool x_stop_active_flag,
    const gsl_vector *x_targets_vec,
    double t_end_max_overall, 
    double rtol, double atol, 
    PhotonTrajectory *full_traj_output,   
    TrajectoryCrossings *crossings_output, 
    int num_interp_points_for_full_traj,
    bool force_detailed_log_this_ray
);
// +++ New Code End (Forward Declarations for ALL static functions in this file) ++++++



// --- Static Function Definitions (internal helpers) ---



static double gsl_root_spline_wrapper(double K_test, void *params) {
    SplineRootParams *spline_p = (SplineRootParams *)params;
    // Ensure K_test is within the spline's defined range to avoid GSL_EDOM
    // (though Brent should keep it within its initial bracket [K_min_spline_data, K_max_spline_data])
    if (K_test < spline_p->spline->x[0] - EPSILON_GENERAL || K_test > spline_p->spline->x[spline_p->spline->size - 1] + EPSILON_GENERAL) {
        // This case should ideally not be hit if Brent is working within its bracket.
        // If it is, returning a large value might help guide Brent back.
        // Or, one could clamp K_test to the spline range.
        fprintf(stderr, "Warning: gsl_root_spline_wrapper K_test=%.17e out of spline range [%.17e, %.17e]. Clamping.\n", 
                K_test, spline_p->spline->x[0], spline_p->spline->x[spline_p->spline->size - 1]);
        K_test = fmax(spline_p->spline->x[0], fmin(K_test, spline_p->spline->x[spline_p->spline->size - 1]));
    }
    return gsl_spline_eval(spline_p->spline, K_test, spline_p->accel);
}

// +++++++  New Code Start (Complete find_tp_event_time_with_spline function) ++++++
// Place this static function in trajectory_module.c
static int find_tp_event_time_with_spline(
    double K_app_step_start,                // Start K of the current application-level step
    double y_app_step_start_state[],        // State [r,phi] at K_app_step_start
    double K_app_step_end,                  // End K of the current application-level step
    gsl_odeiv2_system *sys_ptr,             // Pointer to the main GSL ODE system (passed from integrate_photon_trajectory_core)
    EventFunctionParams *event_p_fr_zero,   // Params for get_event_val_fr_zero (contains M, b, etc.)
    bool is_target_ray_debug_c_from_caller, // <<< ADDED PARAMETER FOR LOGGING CONTROL
    double *K_event_found_spline            // Output: K of TP found by spline method
    // Removed y_state_at_event_spline[] as output from here, state comes from re-integration to K_event_found_spline
) {
    const int NUM_SPLINE_POINTS = 200; 
    if (K_app_step_end <= K_app_step_start + EPSILON_GENERAL * 10.0) { // Adjusted tolerance for very small intervals
        if (is_target_ray_debug_c_from_caller) {
            fprintf(stderr, "find_tp_event_time_with_spline: Application step interval [%.17e, %.17e] too small for spline. Skipping.\n", K_app_step_start, K_app_step_end);
        }
        return 0; 
    }

    gsl_vector *K_spline_data = NULL; // Initialize to NULL
    gsl_vector *R_spline_data = NULL; // Initialize to NULL
    gsl_spline *spline_R_on_K = NULL;
    gsl_interp_accel *accel_R_on_K = NULL;
    gsl_odeiv2_driver *d_spline_sampler_driver = NULL; 

    int final_return_status = 0; 

    K_spline_data = gsl_vector_alloc(NUM_SPLINE_POINTS);
    R_spline_data = gsl_vector_alloc(NUM_SPLINE_POINTS);
    if (!K_spline_data || !R_spline_data) {
        fprintf(stderr, "find_tp_event_time_with_spline: Failed to alloc K/R data vectors for spline.\n");
        goto cleanup_spline_find; // Use goto for cleanup
    }

    const gsl_odeiv2_step_type *T_spline_sampler_stepper = gsl_odeiv2_step_rkf45;
    double h_spline_sampler_initial = (K_app_step_end - K_app_step_start) / (NUM_SPLINE_POINTS > 1 ? (NUM_SPLINE_POINTS -1) * 5.0 : 1.0); // Initial h for driver
    if (h_spline_sampler_initial < 1e-9) h_spline_sampler_initial = 1e-9;
    if (h_spline_sampler_initial == 0 && K_app_step_end > K_app_step_start) h_spline_sampler_initial = 1e-9 * (K_app_step_end - K_app_step_start);


    d_spline_sampler_driver = gsl_odeiv2_driver_alloc_y_new(sys_ptr, T_spline_sampler_stepper,
                                                            h_spline_sampler_initial,
                                                            1e-14, 1e-14); 

    if (!d_spline_sampler_driver) {
        fprintf(stderr, "find_tp_event_time_with_spline: Failed to alloc temp driver for spline sampling.\n");
        goto cleanup_spline_find;
    }

    double K_current_sample_for_spline;
    double y_current_sample_for_spline[2];

    for (int i = 0; i < NUM_SPLINE_POINTS; ++i) {
        double K_target_sample_pt;
        if (NUM_SPLINE_POINTS == 1) { 
             K_target_sample_pt = K_app_step_end; // Or K_app_step_start, but need at least 2 for cspline
        } else {
             K_target_sample_pt = K_app_step_start + ((double)i / (NUM_SPLINE_POINTS - 1)) * (K_app_step_end - K_app_step_start);
        }
        if (K_target_sample_pt > K_app_step_end) K_target_sample_pt = K_app_step_end; // Clamp to interval end
        if (i == 0) K_target_sample_pt = K_app_step_start; // Ensure first point is exactly start

        K_current_sample_for_spline = K_app_step_start; 
        memcpy(y_current_sample_for_spline, y_app_step_start_state, 2*sizeof(double)); 
        
        if (i == 0) { // First point is always the start of the application step
             // State is already y_app_step_start_state at K_app_step_start
        } else if ( K_target_sample_pt <= K_current_sample_for_spline + DBL_EPSILON * fabs(K_current_sample_for_spline) + DBL_MIN ) {
             // If target is effectively the same as current K (already K_app_step_start here if i>0)
             // this means we are trying to get multiple points at K_app_step_start, which is not useful.
             // Or if K_target_sample_pt is numerically equal to K_app_step_start from previous iterations due to small interval.
             // Just copy the data from point 0 for subsequent identical K values.
             if(i > 0) { // Should actually not happen if NUM_SPLINE_POINTS > 1 and interval > 0
                gsl_vector_set(K_spline_data, i, gsl_vector_get(K_spline_data, 0));
                gsl_vector_set(R_spline_data, i, gsl_vector_get(R_spline_data, 0));
                continue;
             }
        } else {
            gsl_odeiv2_driver_reset(d_spline_sampler_driver); // Reset for each new target point from start
            // d_spline_sampler_driver->h = h_spline_sampler_initial; // Optionally reset initial step for driver

            int status_sample = gsl_odeiv2_driver_apply(d_spline_sampler_driver, &K_current_sample_for_spline,
                                                        K_target_sample_pt, y_current_sample_for_spline);
            if (status_sample != GSL_SUCCESS) {
                fprintf(stderr, "find_tp_event_time_with_spline: Temp driver failed for spline point %d at K_target=%.17e (status %d: %s), K_reached=%.17e\n", 
                        i, K_target_sample_pt, status_sample, gsl_strerror(status_sample), K_current_sample_for_spline);
                goto cleanup_spline_find; 
            }
        }
        // K_current_sample_for_spline is now K_target_sample_pt (or where driver stopped)
        // y_current_sample_for_spline is state at K_current_sample_for_spline
        gsl_vector_set(K_spline_data, i, K_current_sample_for_spline); 
        gsl_vector_set(R_spline_data, i, get_event_val_fr_zero(K_current_sample_for_spline, y_current_sample_for_spline, event_p_fr_zero));
    }
    
    // Ensure K_spline_data is monotonic if GSL driver steps were very adaptive
    // For now, assume driver hits K_target_sample_pt closely enough for monotonicity.
    // A sort could be added here if needed, but reordering R_spline_data accordingly.

    accel_R_on_K = gsl_interp_accel_alloc();
    // Ensure at least 2 distinct points for cubic spline, otherwise use linear or fewer points
    if (NUM_SPLINE_POINTS < 2) { // Should be gsl_interp_type_min_size(gsl_interp_cspline) which is 2 for linear, 4 for cspline
         fprintf(stderr, "find_tp_event_time_with_spline: Not enough points (%d) for cspline. Need at least %zu.\n", NUM_SPLINE_POINTS, gsl_interp_type_min_size(gsl_interp_cspline));
         goto cleanup_spline_find;
    }
    spline_R_on_K = gsl_spline_alloc(gsl_interp_cspline, NUM_SPLINE_POINTS); 
    if (!accel_R_on_K || !spline_R_on_K) {
        fprintf(stderr, "find_tp_event_time_with_spline: Failed to alloc spline/accel.\n");
        goto cleanup_spline_find;
    }
    // Before gsl_spline_init, ensure K_spline_data is strictly increasing.
    // This might require sorting K_spline_data and R_spline_data together if driver steps were out of order
    // or produced identical K values. For now, assume K_target_sample generation and driver hitting it is okay.
    gsl_spline_init(spline_R_on_K, gsl_vector_const_ptr(K_spline_data,0), gsl_vector_const_ptr(R_spline_data,0), NUM_SPLINE_POINTS);

    gsl_root_fsolver *s_spline_root = gsl_root_fsolver_alloc(gsl_root_fsolver_brent);
    if (!s_spline_root) {
        fprintf(stderr, "find_tp_event_time_with_spline: Failed to alloc GSL root fsolver for spline.\n");
        goto cleanup_spline_find;
    }

    SplineRootParams spline_root_params_instance;
    spline_root_params_instance.spline = spline_R_on_K;
    spline_root_params_instance.accel = accel_R_on_K;

    gsl_function F_spline_root;
    F_spline_root.function = &gsl_root_spline_wrapper;
    F_spline_root.params = &spline_root_params_instance;

    // Use the actual first and last K from K_spline_data as bracket, as driver might not hit K_app_step_end exactly
    double K_spline_bracket_start = gsl_vector_get(K_spline_data, 0);
    double K_spline_bracket_end = gsl_vector_get(K_spline_data, NUM_SPLINE_POINTS - 1);

    double R_at_spline_bracket_start = gsl_vector_get(R_spline_data, 0); // Uses direct R value
    double R_at_spline_bracket_end = gsl_vector_get(R_spline_data, NUM_SPLINE_POINTS - 1); // Uses direct R value

    if (fabs(R_at_spline_bracket_start) < EVENT_DETECTION_TOLERANCE) {
        *K_event_found_spline = K_spline_bracket_start;
        final_return_status = 1;
    } else if (fabs(R_at_spline_bracket_end) < EVENT_DETECTION_TOLERANCE) {
        *K_event_found_spline = K_spline_bracket_end;
        final_return_status = 1;
    } else if (R_at_spline_bracket_start * R_at_spline_bracket_end < 0.0) { 
        gsl_root_fsolver_set(s_spline_root, &F_spline_root, K_spline_bracket_start, K_spline_bracket_end);
        int iter_spline = 0, max_iter_spline = 100;
        int status_spline_root_iter; // Renamed to avoid conflict with outer scope status_spline_root if any
        do {
            iter_spline++;
            status_spline_root_iter = gsl_root_fsolver_iterate(s_spline_root);
            *K_event_found_spline = gsl_root_fsolver_root(s_spline_root);
            double K_low_spline = gsl_root_fsolver_x_lower(s_spline_root);
            double K_high_spline = gsl_root_fsolver_x_upper(s_spline_root);
            status_spline_root_iter = gsl_root_test_interval(K_low_spline, K_high_spline, 0, 1e-15); 

            if (is_target_ray_debug_c_from_caller) { 
                 if (iter_spline <= 5 || iter_spline % 20 == 0 || status_spline_root_iter != GSL_CONTINUE) {
                     fprintf(stderr, "C_SPLINE_TP_FIND_ITER %d K_low=%.17e K_high=%.17e K_root_trial=%.17e F_at_root_trial=%.17e status=%s\n",
                            iter_spline, K_low_spline, K_high_spline, *K_event_found_spline,
                            gsl_spline_eval(spline_R_on_K, *K_event_found_spline, accel_R_on_K), gsl_strerror(status_spline_root_iter));
                     fflush(stderr);
                 }
            }
        } while (status_spline_root_iter == GSL_CONTINUE && iter_spline < max_iter_spline);

        if (status_spline_root_iter == GSL_SUCCESS) {
            final_return_status = 1;
        } else {
            fprintf(stderr, "find_tp_event_time_with_spline: Spline root solver did not converge (status %d: %s).\n", status_spline_root_iter, gsl_strerror(status_spline_root_iter));
        }
    } 
    gsl_root_fsolver_free(s_spline_root); s_spline_root = NULL;

    if (final_return_status == 1 && is_target_ray_debug_c_from_caller) {
         printf("C_TP_FOUND_SPLINE K %.17e (R_from_spline_at_K %.3e)\n", *K_event_found_spline, gsl_spline_eval(spline_R_on_K, *K_event_found_spline, accel_R_on_K));
         fflush(stdout);
    }

cleanup_spline_find: // Label for centralized cleanup
    if(d_spline_sampler_driver) gsl_odeiv2_driver_free(d_spline_sampler_driver);
    if(K_spline_data) gsl_vector_free(K_spline_data);
    if(R_spline_data) gsl_vector_free(R_spline_data);
    if(spline_R_on_K) gsl_spline_free(spline_R_on_K);
    if(accel_R_on_K) gsl_interp_accel_free(accel_R_on_K);
    
    return final_return_status;
}
// +++ New Code End (Complete find_tp_event_time_with_spline function) ++++++

/**
 * @brief Defines the system of first-order Ordinary Differential Equations (ODEs) for photon
 *        geodesics in Schwarzschild spacetime.
 *
 * This function provides the right-hand side `f_derivs` for the system of two coupled ODEs:
 *   1. `dr/d\kappa` (change in radial coordinate with affine parameter)
 *   2. `d\phi/d\kappa` (change in azimuthal angle with affine parameter)
 * These equations are derived from the Schwarzschild metric and are given by:
 *   `d\phi/d\kappa = b / r^2` (Schwarzschild_Lens_Paper.pdf, Eq. (7), page 9)
 *   `dr/d\kappa = \sigma \sqrt{R(r)}` (Schwarzschild_Lens_Paper.pdf, Eq. (8), page 9)
 * where `R(r) = 1 - (1 - 2M/r) * (b^2/r^2)` is the radial potential function (Eq. (5), page 8).
 * `\sigma` (`sign_val`) is a sign factor (+1 for outward, -1 for inward radial motion).
 * The system is autonomous (does not explicitly depend on `\kappa` itself), meaning its derivatives
 * depend only on the current state variables (`r`, `phi`) and parameters (`M`, `b`).
 *
 * @param K The current affine parameter `\kappa` (unused in these autonomous ODEs, but required by GSL's `gsl_odeiv2_system` signature).
 * @param y_state An array `[r, phi]` representing the current state of the photon:
 *                `y_state[0]` is `r` (radial coordinate), `y_state[1]` is `phi` (azimuthal angle).
 * @param f_derivs An array `[dr/dK, dphi/dK]` where the calculated derivatives will be stored.
 *                `f_derivs[0]` is `dr/d\kappa`, `f_derivs[1]` is `d\phi/d\kappa`.
 * @param params_ptr A `void` pointer to an `ODEParams` struct containing `M` (black hole mass),
 *                   `b` (impact parameter), and a pointer to `sign_dr_dk` (the current sign of radial motion).
 * @return `int` `GSL_SUCCESS` (0) always, as numerical issues are handled internally (e.g., by clamping
 *             values or setting derivatives to 0) rather than returning a GSL error code. This allows the
 *             GSL solver to continue gracefully even near singularities.
 * @note **Numerical Stability:**
 *       - If `r` is at or inside the event horizon (`2M` + `tolerance`), derivatives are set to 0 to halt
 *         integration, preventing numerical instability and modeling photon capture.
 *       - The metric term `(1 - 2M/r)` is clamped to be non-negative if numerically slightly negative
 *         when `r` is just outside `2M`. This prevents `sqrt` of negative numbers when calculating the impact parameter.
 *       - The radial potential `R(r)` (computed as `fr_val`) is clamped to be non-negative before `sqrt`
 *         due to potential floating-point precision issues when very close to a radial turning point.
 *         This prevents `sqrt` of small negative numbers that might arise from numerical error.
 */
static int schwarzschild_geodesic_eqs(double K, const double y_state[], double f_derivs[], void *params_ptr) {
    (void)K; // `K` is not explicitly used in these autonomous ODEs.
    ODEParams *params = (ODEParams *)params_ptr;
    double M = params->M;           // Black hole mass.
    double b = params->b;           // Photon's impact parameter.
    int sign_val = *(params->sign_dr_dk); // Current sign of `dr/dK` (+1 for outward, -1 for inward).
    double r = y_state[0];          // Current radial coordinate of the photon.

    // If the photon reaches or crosses the event horizon (`2M`), plus a small tolerance,
    // set derivatives to zero to effectively stop its motion and prevent numerical issues.
    // This models photon capture.
    if (r <= (2.0 * M + EVENT_DETECTION_TOLERANCE * 0.01)) { 
        f_derivs[0] = 0.0; // `dr/dK = 0` (no more radial motion).
        f_derivs[1] = 0.0; // `dphi/dK = 0` (no more angular motion if captured).
        return GSL_SUCCESS;
    }
    // Calculate the metric term `(1 - 2M/r)`, which becomes zero at the event horizon.
    double metric_term = (1.0 - 2.0 * M / r);
    // Clamp `metric_term` to `0.0` if it's slightly negative due to floating-point precision
    // when `r` is very close to `2M` from the outside (where it should be `0`).
    if (metric_term < 0 && r > 2.0 * M) { metric_term = 0.0; }

    // Calculate the `(b/r)^2` term.
    double term_b_r_sq = (b / r) * (b / r) ;
    // Calculate `fr_val`, which is `R(r)` or `(dr/dK)^2`, according to Eq. (5) of Schwarzschild_Lens_Paper.pdf.
    // `R(r) = 1 - (1 - 2M/r) * (b^2/r^2)`.
    double fr_val = 1.0 - metric_term * term_b_r_sq;

    // Clamp `fr_val` to `0.0` if it's slightly negative due to floating-point precision when
    // `r` is very close to a radial turning point (`R(r) = 0`). This prevents `sqrt` of negative.
    if (fr_val < 0) { fr_val = 0.0; }

    // Calculate `dr/dK = \sigma * \sqrt{R(r)}`, where `\sigma` is `sign_val`.
    f_derivs[0] = sign_val * sqrt(fr_val); 

    // Calculate `dphi/dK = b / r^2` (Eq. (7) of Schwarzschild_Lens_Paper.pdf).
    if (r < EPSILON_GENERAL) { // Defensive check to avoid division by zero if `r` is extremely small or zero.
        f_derivs[1] = 0.0; 
    }
    else { 
        f_derivs[1] = b / (r * r); 
    }
    return GSL_SUCCESS;
}



static double cubic_hermite_interp_component(double t, double t0, double y0, double m0, double t1, double y1, double m1) {
    double h = t1 - t0;
    if (fabs(h) < DBL_EPSILON * (fabs(t0) + fabs(t1)) * 0.5 + DBL_MIN * 10.0) { // Robust tiny interval check
        if (t <= t0 + DBL_EPSILON) return y0;
        if (t >= t1 - DBL_EPSILON) return y1;
        if (fabs(h) < DBL_MIN) return y0; // t0 is effectively t1
        double s_lin = (t - t0) / h;
        return y0 + s_lin * (y1 - y0);
    }

    double s = (t - t0) / h;
    s = fmax(0.0, fmin(1.0, s)); // Clamp s

    double s_sq = s * s;
    double s_cb = s_sq * s;
    
    double h00 =  2.0 * s_cb - 3.0 * s_sq + 1.0;
    double h10 = (s_cb - 2.0 * s_sq + s) * h; 
    double h01 = -2.0 * s_cb + 3.0 * s_sq;
    double h11 = (s_cb - s_sq) * h;       

    return h00 * y0 + h10 * m0 + h01 * y1 + h11 * m1;
}

/**
 * @brief Event function: Calculates the value of the radial potential `R(r)`.
 *
 * This function evaluates `R(r) = 1 - (1 - 2M/r) * (b^2/r^2)`, as defined in
 * Schwarzschild_Lens_Paper.pdf, Eq. (5), page 8. A radial turning point occurs when `R(r)=0`.
 * The GSL root solver will search for the zero-crossing of this function to find the precise
 * location of a turning point, where the photon's radial velocity momentarily becomes zero.
 *
 * @param K Current affine parameter (unused, but required by GSL event function signature).
 * @param y_state Current state array: `y_state[0] = r` (radial coordinate), `y_state[1] = phi` (azimuthal angle).
 * @param params Pointer to `EventFunctionParams` struct, containing `M` and `b` (accessed via `ode_p_event`).
 * @return `double` The value of `R(r)`. Returns `0.0` if `r` is at or inside the event horizon to signify a capture,
 *                  as the photon cannot escape from that region.
 * @note If `r` is very close to or inside the event horizon (`r \le 2M + \text{tolerance}`),
 *       it is considered to be at a turning point (returns `0.0`) to prevent numerical issues
 *       and ensure a stopping condition related to capture. This prevents the ODE solver from
 *       stepping into a singularity.
 */
// In trajectory_module.c

static double get_event_val_fr_zero(double K, const double y_state[], EventFunctionParams *params) {
    (void)K; // K is unused.
    double r = y_state[0];
    double M = params->ode_p_event->M; // Access M from the associated ODE parameters.
    double b = params->ode_p_event->b; // Access b from the associated ODE parameters.
    double metric_term_val = (1.0 - 2.0 * M / r);

    // Defensive clamp for r > 2M if metric_term_val numerically becomes small negative.
    // This matches behavior in schwarzschild_geodesic_eqs.
    if (metric_term_val < 0.0 && r > (2.0 * M + DBL_EPSILON)) { // Ensure r is definitively outside 2M for this clamp
        metric_term_val = 0.0;
    }

    // Defensive check for r being extremely small.
    // R(r) approaches 1 + 2Mb^2/r^3 for r -> 0.
    if (r < EPSILON_GENERAL) { // EPSILON_GENERAL is 1e-9

        return DBL_MAX;
    }

    double term_b_r_sq_val = (b / r) * (b / r);
    return 1.0 - metric_term_val * term_b_r_sq_val;
}

/**
 * @brief Event function: Detects when the photon reaches or crosses near the event horizon.
 *
 * This function evaluates `r - (2M + \epsilon)`, where `\epsilon` is a small tolerance.
 * A zero-crossing of this function, specifically from positive to negative, indicates
 * that the photon has reached the region of the event horizon, marking its capture. This
 * serves as a critical termination condition for inward-bound trajectories.
 *
 * @param K Current affine parameter (unused, but required by GSL event function signature).
 * @param y_state Current state array: `y_state[0] = r` (radial coordinate).
 * @param params Pointer to `EventFunctionParams` struct, containing `M` (black hole mass).
 * @return `double` The value of `r - (2M + \text{small_offset})`. A positive value means the photon is outside,
 *                  a negative value means it is inside or at the horizon.
 * @note The `EVENT_DETECTION_TOLERANCE * 0.1` provides a small offset to ensure robust detection
 *       slightly *outside* `2M`, preventing undershoot issues where the solver might step directly
 *       past the horizon without detection.
 */
static double get_event_val_r_leq_2M(double K, const double y_state[], EventFunctionParams *params) {
    (void)K; // `K` is unused.
    // Evaluates `r - (2M + small_offset)`. The `EVENT_DETECTION_TOLERANCE * 0.1` provides a small offset
    // to ensure robust detection slightly *outside* `2M`, preventing undershoot issues.
    return y_state[0] - (2.0 * params->M + 1e-11); 
}

/**
 * @brief Event function: Detects when the photon escapes to a predefined maximum radius (`r_{max}`).
 *
 * This function evaluates `r - r_{max_event}`. A zero-crossing of this function,
 * specifically from negative to positive, indicates that the photon has reached
 * or exceeded the outer boundary defined by `r_max_event`, marking its escape from the
 * region of interest. This is a common termination condition for outward-bound trajectories.
 *
 * @param K Current affine parameter (unused, but required by GSL event function signature).
 * @param y_state Current state array: `y_state[0] = r` (radial coordinate).
 * @param params Pointer to `EventFunctionParams` struct, containing `r_max_event`.
 * @return `double` The value of `r - r_{max_event}`. A positive value means the photon is beyond `r_max_event`,
 *                  a negative value means it is inside.
 */
static double get_event_val_r_max(double K, const double y_state[], EventFunctionParams *params) {
    (void)K; // `K` is unused.
    return y_state[0] - params->r_max_event; 
}

/**
 * @brief Event function: Detects when the photon crosses a specific `x`-coordinate (`x_{stop}`).
 *
 * This function evaluates `r*cos(phi) - x_{stop_event}`. The `x`-coordinate in Cartesian
 * coordinates (in the 2D integration plane) is `r * cos(\phi)`. A zero-crossing of this function,
 * typically from positive to negative (i.e., `x` decreasing through `x_{stop}`), signals that
 * the photon has reached the `x_{stop_event}` plane. This serves as a general termination
 * condition for the ray tracer, preventing integration from extending unnecessarily far.
 *
 * @param K Current affine parameter (unused, but required by GSL event function signature).
 * @param y_state Current state array: `y_state[0] = r` (radial coordinate), `y_state[1] = phi` (azimuthal angle).
 * @param params Pointer to `EventFunctionParams` struct, containing `x_stop_event`.
 * @return `double` The value of `r*cos(phi) - x_{stop_event}`. Returns `1.0` if `r` is too small
 *                (near zero) to avoid numerical issues (e.g., division by zero if r is used in calculations),
 *                ensuring the event is not triggered in the strong-field region or near the origin.
 */
static double get_event_val_x_stop(double K, const double y_state[], EventFunctionParams *params) {
    (void)K; // `K` is unused.
    double r = y_state[0]; 
    double phi = y_state[1];
    if (r < EPSILON_GENERAL) { return 1.0; } // Return a non-zero value to prevent event triggering if `r` is effectively zero.
    return r * cos(phi) - params->x_stop_event; 
}

/**
 * @brief Event function: Detects when the photon crosses a specific `x`-coordinate target plane (`x_{target}`).
 *
 * This function evaluates `r*cos(phi) - x_{target_event}`. It is used to record the
 * y-coordinates of photon crossings at predefined `x`-planes, which is essential for
 * image mapping (e.g., determining intersection with source and window planes). This event
 * typically does not terminate the integration but triggers data collection. Multiple such
 * events can be active simultaneously.
 *
 * @param K Current affine parameter (unused, but required by GSL event function signature).
 * @param y_state Current state array: `y_state[0] = r` (radial coordinate), `y_state[1] = phi` (azimuthal angle).
 * @param params Pointer to `EventFunctionParams` struct, containing `x_target_event`.
 * @return `double` The value of `r*cos(phi) - x_{target_event}`. Returns `1.0` if `r` is too small
 *                (near zero) to avoid numerical issues, preventing false triggers near the origin.
 */
static double get_event_val_x_target(double K, const double y_state[], EventFunctionParams *params) {
    (void)K; // `K` is unused.
    double r = y_state[0]; 
    double phi = y_state[1];
    if (r < EPSILON_GENERAL) { return 1.0; } // Return a non-zero value to prevent event triggering if `r` is effectively zero.
    return r * cos(phi) - params->x_target_event; 
}

/**
 * @brief Wrapper function for GSL root solvers to evaluate an event function.
 *
 * The GSL root solver (`gsl_root_fsolver_brent`) expects a function of the form `double func(double x, void *params)`.
 * This wrapper adapts our internal event functions (which take `K`, `y_state`, `EventFunctionParams*`) to this signature.
 * It linearly interpolates the photon's state `y_state` (`[r, phi]`) to the trial `K_test` value provided by the GSL
 * solver, using the states from the beginning (`K_prev_step`) and end (`K_curr_step`) of the current
 * ODE integration step. This allows the root solver to find the precise `K` at which an event occurs within a step,
 * even if the event point falls between the discrete steps taken by the ODE integrator.
 *
 * @param K_test The trial value of affine parameter `\kappa` at which to evaluate the event function.
 *               This is the independent variable that GSL's root solver varies to find a zero-crossing.
 * @param params_ptr `void` pointer to a `GslRootEventParams` struct, which contains context for the wrapper,
 *                   including the actual event function and the states at the start and end of the ODE step.
 * @return `double` The value of the specific event function (e.g., `R(r)`) at `K_test` and its interpolated state.
 */
// In trajectory_module.c, gsl_root_event_wrapper:
static double gsl_root_event_wrapper(double K_test, void *params_ptr) {
    GslRootEventParams *root_p = (GslRootEventParams *)params_ptr;
    double y_interp_at_K_test[2]; // To store interpolated [r, phi]

    // Clamp K_test to be within the valid interval of the super-step
    double K_test_clamped = K_test;
    if (K_test < root_p->K_prev_super_step) {
        K_test_clamped = root_p->K_prev_super_step;
    } else if (K_test > root_p->K_curr_super_step) {
        K_test_clamped = root_p->K_curr_super_step;
    }

    // Perform cubic Hermite interpolation for r (y_state[0])
    y_interp_at_K_test[0] = cubic_hermite_interp_component(
        K_test_clamped,
        root_p->K_prev_super_step, root_p->y_state_at_K_prev_super_step[0], root_p->f_derivs_at_K_prev_super_step[0],
        root_p->K_curr_super_step, root_p->y_state_at_K_curr_super_step[0], root_p->f_derivs_at_K_curr_super_step[0]
    );

    // Perform cubic Hermite interpolation for phi (y_state[1])
    y_interp_at_K_test[1] = cubic_hermite_interp_component(
        K_test_clamped,
        root_p->K_prev_super_step, root_p->y_state_at_K_prev_super_step[1], root_p->f_derivs_at_K_prev_super_step[1],
        root_p->K_curr_super_step, root_p->y_state_at_K_curr_super_step[1], root_p->f_derivs_at_K_curr_super_step[1]
    );

    // Robustness check for interpolated r value (Modification #1 from Master Plan)
    if (y_interp_at_K_test[0] <= 0.0) {
        fprintf(stderr, "Warning: gsl_root_event_wrapper interpolated r=%.3e (<=0) at K_test_clamped=%.17e. Event func: %p. ",
                y_interp_at_K_test[0], K_test_clamped, (void*)root_p->get_event_val_func_root);
        
        if (root_p->get_event_val_func_root == get_event_val_fr_zero) {
             fprintf(stderr, "Returning DBL_MAX for fr_zero event with non-physical r.\n");
             return DBL_MAX; 
        } else if (root_p->get_event_val_func_root == get_event_val_x_stop || 
                   root_p->get_event_val_func_root == get_event_val_x_target) {
            fprintf(stderr, "Returning DBL_MAX for x-plane event with non-physical r.\n");
            return DBL_MAX; 
        } else if (root_p->get_event_val_func_root == get_event_val_r_leq_2M) {
            fprintf(stderr, "Returning -DBL_MAX for r_leq_2M event with non-physical r (treat as definitely captured).\n");
            return -DBL_MAX; 
        } else if (root_p->get_event_val_func_root == get_event_val_r_max) {
            fprintf(stderr, "Returning -DBL_MAX for r_max event with non-physical r (treat as definitely not escaped).\n");
            return -DBL_MAX; 
        } else {
             fprintf(stderr, "Returning GSL_ERANGE for unknown event type with non-physical r to signal error to GSL.\n");
             return GSL_ERANGE; 
        }
    }

    return root_p->get_event_val_func_root(K_test_clamped,
                                         y_interp_at_K_test,
                                         root_p->event_params_root);
}
/**
 * @brief Finds the precise affine parameter K where an event occurs within an integration step.
 *
 * This function uses GSL's Brent root-finding method (`gsl_root_fsolver_brent`), a robust and
 * efficient 1D root-finding algorithm, to accurately locate the `K` value where the specified
 * event function (`get_event_val_func_gsl`) crosses zero. The search is performed within the
 * interval `[K_start_interval, K_end_interval]`, which typically corresponds to a single
 * "super-step" of the ODE integration (i.e., the interval covered by `gsl_odeiv2_driver_apply`).
 *
 * @param K_start_interval Affine parameter `K` at the beginning of the ODE integration step.
 * @param y_start_interval Photon state `[r, phi]` at `K_start_interval`.
 * @param K_end_interval Affine parameter `K` at the end of the ODE integration step.
 * @param y_end_interval Photon state `[r, phi]` at `K_end_interval`.
 * @param get_event_val_func_gsl Pointer to the specific event function to evaluate (e.g., `get_event_val_fr_zero`, `get_event_val_r_max`).
 * @param event_p_gsl Pointer to `EventFunctionParams` struct, containing parameters relevant to the event function.
 * @param crossing_direction Specifies the desired direction of the zero-crossing:
 *                           - `0`: Detect any zero-crossing (i.e., `val_start * val_end` is near 0).
 *                           - `<0`: Detect a negative-going zero-crossing (value changes from positive to negative).
 *                           - `>0`: Detect a positive-going zero-crossing (value changes from negative to positive).
 * @param K_event_found_gsl Output: Pointer to a `double` where the precise `K` value where the event is found will be stored.
 * @param y_event_found_gsl Output: Array (`double[2]`) where the interpolated photon state `[r, phi]` at `K_event_found_gsl` will be stored.
 * @return `int` 1 if an event root is successfully found within the specified tolerance.
 *             0 otherwise (e.g., root not bracketed, solver failed to converge, or allocation error).
 * @note `EVENT_DETECTION_TOLERANCE` is used for checking interval convergence and values near zero.
 *       The `find_event_time_gsl` function handles cases where the event is already at the interval boundaries.
 */



static int find_event_time_gsl(
    double K_start_interval, double y_start_interval[], // y_start_interval is state at K_start_interval
    double K_end_interval, double y_end_interval[],     // y_end_interval is state at K_end_interval
    GslRootEventParams *the_root_params, // Contains K_prev/curr_super_step and states/derivs for Hermite
    int crossing_direction,
    double *K_event_found_gsl, double y_event_found_gsl[]) {

    int iter = 0, max_iter = 100;
    const gsl_root_fsolver_type *T_solver = gsl_root_fsolver_brent;
    gsl_root_fsolver *s_solver = NULL;

    s_solver = gsl_root_fsolver_alloc(T_solver);
    if (!s_solver) {
        fprintf(stderr, "find_event_time_gsl: Failed to allocate GSL root fsolver.\n");
        return 0; 
    }

    gsl_function F_gsl_root;
    F_gsl_root.function = &gsl_root_event_wrapper; 
    F_gsl_root.params = the_root_params;          

    // Evaluate event function at interval boundaries using the consistent wrapper
    double val_start = F_gsl_root.function(K_start_interval, F_gsl_root.params);
    double val_end = F_gsl_root.function(K_end_interval, F_gsl_root.params);

    // Modification #1: NaN/Inf check for boundary values
    if (gsl_isnan(val_start) || gsl_isinf(val_start) || gsl_isnan(val_end) || gsl_isinf(val_end)) {
        fprintf(stderr, "find_event_time_gsl: Invalid function value (NaN/Inf) at K_interval bounds [%.17e (val=%.3e), %.17e (val=%.3e)]. Root solver cannot be set.\n", 
                K_start_interval, val_start, K_end_interval, val_end);
        gsl_root_fsolver_free(s_solver);
        return 0; 
    }
    
    // Modification #1: Robust bracketing and boundary event handling
    bool bracketed = false;
    if (fabs(val_start) < EVENT_DETECTION_TOLERANCE) { // Event at start
        *K_event_found_gsl = K_start_interval;
        // Interpolate state to K_start_interval using the_root_params for Hermite
        y_event_found_gsl[0] = cubic_hermite_interp_component(K_start_interval, 
            the_root_params->K_prev_super_step, the_root_params->y_state_at_K_prev_super_step[0], the_root_params->f_derivs_at_K_prev_super_step[0], 
            the_root_params->K_curr_super_step, the_root_params->y_state_at_K_curr_super_step[0], the_root_params->f_derivs_at_K_curr_super_step[0]);
        y_event_found_gsl[1] = cubic_hermite_interp_component(K_start_interval,
            the_root_params->K_prev_super_step, the_root_params->y_state_at_K_prev_super_step[1], the_root_params->f_derivs_at_K_prev_super_step[1],
            the_root_params->K_curr_super_step, the_root_params->y_state_at_K_curr_super_step[1], the_root_params->f_derivs_at_K_curr_super_step[1]);

        if (the_root_params->get_event_val_func_root == get_event_val_fr_zero) {
            printf("C_TP_FOUND_PRECISE_K K %.17e R_at_K %.17e PHI_at_K %.17e (Event at K_start_interval, boundary check)\n",
                   *K_event_found_gsl, y_event_found_gsl[0], y_event_found_gsl[1]);
            fflush(stdout);
        }
        gsl_root_fsolver_free(s_solver);
        return 1;
    }
    
    // Check K_end_interval, only if distinct from K_start_interval
    if (fabs(K_end_interval - K_start_interval) > DBL_EPSILON * (fabs(K_start_interval) + fabs(K_end_interval)) * 0.5 + DBL_MIN) {
        if (fabs(val_end) < EVENT_DETECTION_TOLERANCE) { // Event at end
            *K_event_found_gsl = K_end_interval;
            y_event_found_gsl[0] = cubic_hermite_interp_component(K_end_interval, 
                the_root_params->K_prev_super_step, the_root_params->y_state_at_K_prev_super_step[0], the_root_params->f_derivs_at_K_prev_super_step[0], 
                the_root_params->K_curr_super_step, the_root_params->y_state_at_K_curr_super_step[0], the_root_params->f_derivs_at_K_curr_super_step[0]);
            y_event_found_gsl[1] = cubic_hermite_interp_component(K_end_interval,
                the_root_params->K_prev_super_step, the_root_params->y_state_at_K_prev_super_step[1], the_root_params->f_derivs_at_K_prev_super_step[1],
                the_root_params->K_curr_super_step, the_root_params->y_state_at_K_curr_super_step[1], the_root_params->f_derivs_at_K_curr_super_step[1]);

            if (the_root_params->get_event_val_func_root == get_event_val_fr_zero) {
                 printf("C_TP_FOUND_PRECISE_K K %.17e R_at_K %.17e PHI_at_K %.17e (Event at K_end_interval, boundary check)\n",
                       *K_event_found_gsl, y_event_found_gsl[0], y_event_found_gsl[1]);
                 fflush(stdout);
            }
            gsl_root_fsolver_free(s_solver);
            return 1;
        }
    }

    // Standard bracketing condition (sign change)
    if (val_start * val_end < 0.0) {
        bracketed = true;
    } 

    // Check if a crossing happened according to `crossing_direction`
    if (!bracketed) {
        if (crossing_direction == 0) { 
            // Original loose check for "any crossing" if strict f(a)f(b)<0 wasn't met
            // This could be removed if explicit direction checks are preferred and sufficient.
            // if (val_start * val_end <= EVENT_DETECTION_TOLERANCE * EVENT_DETECTION_TOLERANCE) { bracketed = true; }
        } else if (crossing_direction < 0) { // Detect positive to negative (val_start >= 0, val_end <= 0)
            // Ensure not both are effectively zero (which boundary checks should have caught)
            if (val_start >= -EVENT_DETECTION_TOLERANCE && val_end <= EVENT_DETECTION_TOLERANCE && 
                !(fabs(val_start) < EVENT_DETECTION_TOLERANCE && fabs(val_end) < EVENT_DETECTION_TOLERANCE)) {
                bracketed = true;
            }
        } else { // Detect negative to positive (val_start <= 0, val_end >= 0)
            if (val_start <= EVENT_DETECTION_TOLERANCE && val_end >= -EVENT_DETECTION_TOLERANCE &&
                !(fabs(val_start) < EVENT_DETECTION_TOLERANCE && fabs(val_end) < EVENT_DETECTION_TOLERANCE)) {
                bracketed = true;
            }
        }
    }

    if (!bracketed) {
        gsl_root_fsolver_free(s_solver);
        return 0; // No usable bracket and not at boundaries.
    }
    // End of Modification #1 for bracketing

    int status_set = gsl_root_fsolver_set(s_solver, &F_gsl_root, K_start_interval, K_end_interval);
    if (status_set != GSL_SUCCESS) {
        fprintf(stderr, "find_event_time_gsl: gsl_root_fsolver_set failed (status %s, GSL code %d) for K_interval [%.17e, %.17e] vals[%.3e, %.3e]\n", 
                gsl_strerror(status_set), status_set, K_start_interval, K_end_interval, val_start, val_end);
        gsl_root_fsolver_free(s_solver);
        return 0;
    }

    int status_iterate;
    const double K_EVENT_PRECISION_TARGET = 1e-14; 

    do {
        iter++;
        status_iterate = gsl_root_fsolver_iterate(s_solver);
        if (status_iterate != GSL_SUCCESS && status_iterate != GSL_CONTINUE) {
             fprintf(stderr, "find_event_time_gsl: gsl_root_fsolver_iterate failed (status %s, GSL code %d) on iter %d\n", gsl_strerror(status_iterate), status_iterate, iter);
             gsl_root_fsolver_free(s_solver);
             return 0; 
        }
        
        *K_event_found_gsl = gsl_root_fsolver_root(s_solver); 
        double K_low = gsl_root_fsolver_x_lower(s_solver);   
        double K_high = gsl_root_fsolver_x_upper(s_solver);  
        
        if (the_root_params->get_event_val_func_root == get_event_val_fr_zero) {
            if (iter <= 5 || iter >= max_iter - 5 || iter == (max_iter -1) || (iter > 5 && iter < max_iter - 5 && iter % 50 == 0) ) { 
                double F_at_current_root_estimate = F_gsl_root.function(*K_event_found_gsl, F_gsl_root.params);
                printf("C_TP_FIND_ITER %d K_low %.17e K_high %.17e K_root_trial %.17e F_at_root_trial %.17e\n",
                       iter, K_low, K_high, *K_event_found_gsl, 
                       F_at_current_root_estimate); 
                fflush(stdout);
            }
        }
        status_iterate = gsl_root_test_interval(K_low, K_high, 0, K_EVENT_PRECISION_TARGET);

    } while (status_iterate == GSL_CONTINUE && iter < max_iter);

    if (status_iterate != GSL_SUCCESS) { 
        fprintf(stderr, "find_event_time_gsl: GSL root solver did not converge after %d iterations (status %s, GSL code %d). K bracket [%.17e, %.17e]\n",
                iter, gsl_strerror(status_iterate), status_iterate, gsl_root_fsolver_x_lower(s_solver), gsl_root_fsolver_x_upper(s_solver));
        gsl_root_fsolver_free(s_solver);
        return 0; 
    }
    
    double K_for_interp = *K_event_found_gsl; 
    
    y_event_found_gsl[0] = cubic_hermite_interp_component( K_for_interp, 
        the_root_params->K_prev_super_step, the_root_params->y_state_at_K_prev_super_step[0], the_root_params->f_derivs_at_K_prev_super_step[0], 
        the_root_params->K_curr_super_step, the_root_params->y_state_at_K_curr_super_step[0], the_root_params->f_derivs_at_K_curr_super_step[0]);
    y_event_found_gsl[1] = cubic_hermite_interp_component( K_for_interp, 
        the_root_params->K_prev_super_step, the_root_params->y_state_at_K_prev_super_step[1], the_root_params->f_derivs_at_K_prev_super_step[1], 
        the_root_params->K_curr_super_step, the_root_params->y_state_at_K_curr_super_step[1], the_root_params->f_derivs_at_K_curr_super_step[1]);

    if (y_event_found_gsl[0] <= 0.0) { 
        fprintf(stderr, "Warning: find_event_time_gsl final state r=%.3e (<=0) at K_event=%.17e (after Hermite interp). Setting r=DBL_EPSILON.\n", y_event_found_gsl[0], *K_event_found_gsl);
        y_event_found_gsl[0] = DBL_EPSILON; 
    }
    
    if (the_root_params->get_event_val_func_root == get_event_val_fr_zero) {
        printf("C_TP_FOUND_PRECISE_K K %.17e R_at_K %.17e PHI_at_K %.17e (Converged)\n",
               *K_event_found_gsl, y_event_found_gsl[0], y_event_found_gsl[1]);
        fflush(stdout);
    }

    gsl_root_fsolver_free(s_solver); 
    return 1; 
}

/**
 * @brief Reallocates a GSL vector if its current logical element count reaches its physical capacity.
 *
 * This function provides dynamic memory management for GSL vectors, similar to `realloc` for C arrays.
 * If the number of elements intended to be stored (`current_logical_element_count`)
 * equals or exceeds the vector's current physical allocated capacity (`*current_physical_capacity_ptr`),
 * a new, larger GSL vector is allocated (typically with doubled capacity). The existing data
 * from the old vector is copied to the new one, and the old vector is freed. This approach
 * balances memory efficiency with performance for growing data structures.
 *
 * @param vec_ptr Pointer to the `gsl_vector` pointer (`gsl_vector**`). This allows the function
 *                to modify the caller's `gsl_vector` pointer if reallocation occurs (i.e., point
 *                to the new, larger vector). Must not be NULL.
 * @param current_logical_element_count The number of elements currently logically present or
 *                                      intended to be present in the vector *before* the current
 *                                      append operation that might trigger reallocation. This is
 *                                      typically `(*vec_ptr)->size`.
 * @param current_physical_capacity_ptr Pointer to a `size_t` variable that tracks the current
 *                                      allocated physical capacity of the GSL vector's underlying data block.
 *                                      This value will be updated if reallocation occurs. Must not be NULL.
 * @param initial_capacity_val The initial capacity to use if the vector is being allocated for the
 *                             first time (i.e., if `*current_physical_capacity_ptr` is 0) or as a
 *                             minimum growth increment.
 * @return `int` 0 on success or if no reallocation was needed.
 *             -1 on error (e.g., invalid input pointers, memory allocation failure for the new vector).
 * @note This function manages the raw allocation (`gsl_vector_alloc`/`gsl_vector_free`) and data copying
 *       (`gsl_vector_memcpy`). The `gsl_vector`'s own `size` member should be managed by the calling
 *       dynamic append function (`gsl_vector_dynamic_append`) to reflect the number of used elements.
 */
static int reallocate_gsl_vector_if_needed(
    gsl_vector **vec_ptr,                   // Pointer to your GSL vector (e.g., ¤t_segment_K_temp)
    size_t current_logical_element_count,   // How many data points you've actually stored so far (this is your current_segment_point_count)
    size_t *current_physical_capacity_ptr,  // Pointer to your capacity variable (e.g., ¤t_segment_K_capacity)
    size_t initial_capacity_val) {          // Initial capacity if the vector was empty before

    if (!vec_ptr || !current_physical_capacity_ptr) {
        //fprintf(stderr, "Error: Null pointer passed to reallocate_gsl_vector_if_needed.\n");
        return -1; // Indicate an error
    }

    // We want to write to the index 'current_logical_element_count'.
    // This means the vector needs to have space for at least 'current_logical_element_count + 1' elements.
    // The GSL vector's 'size' field (set by gsl_vector_alloc) tells GSL its physical allocated size.
    if (current_logical_element_count >= *current_physical_capacity_ptr) {
        // Time to make the vector bigger!

        size_t new_physical_capacity;
        if (*current_physical_capacity_ptr > 0) {
            new_physical_capacity = *current_physical_capacity_ptr * 2; // Double the current capacity
        } else {
            new_physical_capacity = initial_capacity_val; // If it was 0, use the initial capacity you defined
        }

        // Make sure the new capacity is definitely large enough for the next element we want to add,
        // and preferably gives us some more room too.
        if (new_physical_capacity <= current_logical_element_count) {
            new_physical_capacity = current_logical_element_count + initial_capacity_val;
            if (new_physical_capacity <= current_logical_element_count) { // Still not enough
                new_physical_capacity = current_logical_element_count + 1; // Absolute minimum
            }
        }

        // Ask GSL to allocate a new, bigger vector.
        // IMPORTANT: gsl_vector_alloc sets new_v->size to new_physical_capacity.
        gsl_vector *new_v = gsl_vector_alloc(new_physical_capacity);
        if (!new_v) {
            //fprintf(stderr, "reallocate_gsl_vector_if_needed: GSL vector allocation failed for new capacity %zu\n", new_physical_capacity);
            return -1; // Allocation failed.
        }

        gsl_vector *old_v = *vec_ptr; // Get the pointer to the old, smaller vector

        if (old_v) { // If there was an old vector
            // Copy data from the old vector to the new, bigger vector.
            // current_logical_element_count is how many actual data points were in old_v that we care about.
            size_t num_elements_to_copy = current_logical_element_count;

            // Safety check: ensure we don't try to copy more than GSL thought the old vector held.
            if (num_elements_to_copy > old_v->size) { 
                //fprintf(stderr, "Warning: reallocate_gsl_vector_if_needed: trying to copy more elements (%zu) than old vector's GSL size (%zu). Truncating.\n", num_elements_to_copy, old_v->size);
                num_elements_to_copy = old_v->size;
            }

            if (num_elements_to_copy > 0) {
                 gsl_vector_const_view old_subvector_to_copy = gsl_vector_const_subvector(old_v, 0, num_elements_to_copy);
                 gsl_vector_view new_subvector_to_paste_into = gsl_vector_subvector(new_v, 0, num_elements_to_copy);
                 gsl_vector_memcpy(&new_subvector_to_paste_into.vector, &old_subvector_to_copy.vector);
            }
            gsl_vector_free(old_v); // Free the memory of the old, smaller vector.
        }

        // *** DO NOT CHANGE new_v->size here! ***
        // `gsl_vector_alloc` correctly set `new_v->size` to `new_physical_capacity`.

        *vec_ptr = new_v; // Make your original pointer point to the new, bigger vector.
        *current_physical_capacity_ptr = new_physical_capacity; // Update your own variable that tracks the GSL vector's physical size.
    }
    return 0; // Success! The vector is now big enough (or was already big enough).
}

/**
 * @brief Appends a double value to a dynamically managed GSL vector.
 *
 * This function serves as a wrapper for adding elements to a GSL vector that
 * automatically handles memory reallocation when the vector's current capacity
 * is exceeded. If the vector pointed to by `vec_ptr` is initially `NULL`,
 * it performs an initial allocation. It then calls `reallocate_gsl_vector_if_needed`
 * to ensure enough space before adding `value_param` at the end of the vector.
 * The vector's `size` member is correctly incremented after adding the element.
 *
 * @param vec_ptr Pointer to the `gsl_vector` pointer (`gsl_vector**`). This allows
 *                the function to allocate (`gsl_vector_alloc`) or reallocate the
 *                vector and update the caller's pointer. Must not be NULL.
 * @param value_param The `double` value to append to the vector.
 * @param current_capacity_ptr Pointer to a `size_t` variable that tracks the
 *                             current allocated physical capacity of `*vec_ptr`'s
 *                             underlying data array. This value is updated by
 *                             `reallocate_gsl_vector_if_needed`. Must not be NULL.
 * @return `int` 0 on success.
 *             -1 on failure (e.g., initial allocation error, reallocation failure,
 *                or invalid input pointers).
 *             -2 if an internal state inconsistency is detected during direct write
 *                (e.g., `vec_ptr->data` is `NULL` or index is out of bounds after checks).
 *                This typically indicates a logic error within the reallocation helper.
 */
int gsl_vector_dynamic_append(gsl_vector **vec_ptr, double value_param, size_t *current_capacity_ptr) {
    if (!vec_ptr || !current_capacity_ptr) { return -1; } // Validate input pointers.

    // If the vector is currently `NULL`, perform an initial allocation.
    if (!(*vec_ptr)) { 
        *current_capacity_ptr = INITIAL_CROSSING_POINTS_CAPACITY; // Set initial capacity for new vector.
        *vec_ptr = gsl_vector_alloc(*current_capacity_ptr); 
        if (!(*vec_ptr)) { 
            fprintf(stderr, "gsl_vector_dynamic_append: Initial allocation failed for GSL vector. Out of memory?\n");
            return -1; 
        }
        (*vec_ptr)->size = 0; // Initialize the logical size of the new vector to 0.
    }
    
    // Check if reallocation is needed before adding the new element.
    // `reallocate_gsl_vector_if_needed` is called with the current logical size of the vector.
    // It will expand the vector if `(*vec_ptr)->size` (current elements) equals or exceeds `*current_capacity_ptr`.
    if (reallocate_gsl_vector_if_needed(vec_ptr, (*vec_ptr)->size, current_capacity_ptr, INITIAL_CROSSING_POINTS_CAPACITY) != 0) {
        return -1; // Reallocation failed.
    }
    
    // At this point, `*vec_ptr` is guaranteed to be non-`NULL` and have enough allocated physical capacity.
    size_t index_to_set = (*vec_ptr)->size; // The index where the new element will be placed.

    // Directly write the `value_param` to the underlying data array.
    // Check against `(*vec_ptr)->block->size` (GSL's true internal allocated size) for safety.
    // This is the correct way to assign a value to a GSL vector's data directly if the internal structure is understood.
    if ((*vec_ptr)->data && index_to_set < (*vec_ptr)->block->size) { 
        (*vec_ptr)->data[index_to_set] = value_param; 
    } else {
        // This indicates a critical internal state inconsistency, where `index_to_set` is out of bounds
        // even after reallocation checks. This should theoretically not happen with correct logic.
        fprintf(stderr, "DYNAMIC_APPEND_ERROR: Invalid state for direct write. Index: %zu, Tracked Capacity: %zu, GSL Block Size: %zu, Data Ptr: %p.\n",
                index_to_set, *current_capacity_ptr, 
                ((*vec_ptr) && (*vec_ptr)->block) ? (*vec_ptr)->block->size : 0, // GSL's true internal block size
                (void*)((*vec_ptr) ? (*vec_ptr)->data : NULL) ); 
        return -2; 
    }

    (*vec_ptr)->size++; // Increment the logical size of the GSL vector (number of used elements).
    return 0; // Success.
}

/**
 * @brief Normalizes an angle to the standard range `[0, 2\pi)`.
 *
 * This function takes an angle in radians and maps it to its equivalent value
 * within the interval `[0, 2\pi)`. For example, `3\pi` becomes `\pi`, and `-pi/2` becomes `3pi/2`.
 * This is useful for consistent angular representation, especially after calculations
 * that might produce angles outside this range (e.g., from `atan2` or long integrations).
 * The `fmod` function handles the primary reduction, and the subsequent `if` statement
 * adjusts negative results to be within the positive range.
 *
 * @param phi The input angle in radians.
 * @return `double` The normalized angle in radians, within the `[0, 2\pi)` range.
 */
double normalize_phi(double phi) {
    phi = fmod(phi, 2.0 * M_PI); // Reduces phi to the range `(-2\pi, 2\pi)`.
    if (phi < 0.0) {
        phi += 2.0 * M_PI; // Shifts negative results to be positive in the `[0, 2\pi)` range.
    }
    return phi;
}

/**
 * @brief Unwraps a sequence of phi (azimuthal angle) values to make them continuous.
 *
 * This function processes a sequence of raw `phi` values that might contain `2\pi` jumps
 * (e.g., transitioning from `6.2` radians to `0.1` radians, which is effectively a jump
 * over the `2\pi` boundary). It adjusts subsequent `phi` values by adding or subtracting
 * multiples of `2\pi` to create a monotonically increasing or decreasing sequence,
 * effectively "unwrapping" the angle. This continuous representation is crucial for
 * accurate spline interpolation of angular trajectories, as splines assume continuity.
 *
 * @param K_raw A constant GSL vector of affine parameter `K` values. While its values are
 *              not directly used in the unwrapping logic itself, its `size` and correspondence
 *              to `phi_raw` are used to iterate through the sequence.
 * @param phi_raw A constant GSL vector of raw, potentially wrapped, `phi` values corresponding to `K_raw`.
 * @param phi_unwrapped An output GSL vector where the unwrapped `phi` values will be stored.
 *                      This vector must be pre-allocated to the same size as `K_raw` and `phi_raw`.
 * @note If input vectors are invalid (`NULL`), have mismatched sizes, or are empty,
 *       the function returns without performing any action.
 * @note The first `phi` value in `phi_raw` is taken as is. Subsequent values are adjusted
 *       by adding/subtracting `2\pi` to minimize the absolute difference from the previous
 *       unwrapped value, effectively finding the shortest angular distance and resolving `2\pi` ambiguities.
 *       This is achieved by mapping the difference into the `(-PI, PI]` range.
 */
static void unwrap_phi_values(const gsl_vector* K_raw, const gsl_vector* phi_raw, gsl_vector* phi_unwrapped) {
    if (!K_raw || !phi_raw || !phi_unwrapped || K_raw->size != phi_raw->size || K_raw->size != phi_unwrapped->size || K_raw->size == 0) {
        return; // Invalid inputs or empty vectors, do nothing.
    }
    gsl_vector_set(phi_unwrapped, 0, gsl_vector_get(phi_raw, 0)); // Initialize the first unwrapped value.
    double prev_unwrapped_val = gsl_vector_get(phi_unwrapped, 0);

    for (size_t i = 1; i < K_raw->size; ++i) {
        double current_raw_val = gsl_vector_get(phi_raw, i);
        double diff_from_prev_unwrapped = current_raw_val - prev_unwrapped_val;
        
        // Calculate the `adjusted_delta` to be in the range `(-PI, PI]`.
        // This is the standard way to resolve `2*PI` ambiguities: find the shortest angular distance.
        double adjusted_delta = fmod(diff_from_prev_unwrapped + M_PI, 2.0 * M_PI) - M_PI;
        // Handle the edge case where `adjusted_delta` is exactly `-M_PI`. If the original `diff_from_prev_unwrapped`
        // was positive (implying an increase), we should prefer `+M_PI` instead of `-M_PI`. This prevents issues
        // like unwrapping `0` to `2PI` then back to `0` instead of just `0` if `current_raw_val - prev_unwrapped_val`
        // was very close to `2PI`.
        if (adjusted_delta == -M_PI && diff_from_prev_unwrapped > 0) { 
             adjusted_delta = M_PI;
        }

        double new_unwrapped_val = prev_unwrapped_val + adjusted_delta; // Calculate the new unwrapped value.
        gsl_vector_set(phi_unwrapped, i, new_unwrapped_val); // Store the unwrapped value.
        prev_unwrapped_val = new_unwrapped_val; // Update the reference for the next iteration.
    }
}

/** @brief File-scope static variable to count calls to `integrate_photon_trajectory_core`.
 *         Used primarily for debugging and profiling to identify specific instances of calls,
 *         especially when the function is invoked many times (e.g., from `image_map` in a loop).
 *         This helps in tracking the execution flow during complex simulations. */
/**
 * @brief Core internal function for integrating a single photon geodesic trajectory in Schwarzschild spacetime.
 *
 * This is the primary workhorse function for computing photon paths. It utilizes the GSL ODE solver
 * (`gsl_odeiv2_step_rkf45` is often chosen for its adaptive step-size Runge-Kutta 4(5) method)
 * to numerically integrate the rescaled geodesic equations for `r(K)` and `phi(K)`.
 * The function implements advanced features crucial for robust and accurate ray tracing:
 * -   **Adaptive Step-Size Integration:** The GSL solver dynamically adjusts its step size
 *     to maintain specified relative (`rtol`) and absolute (`atol`) tolerances. This is essential
 *     for accuracy in regions of strong spacetime curvature where derivatives change rapidly.
 * -   **Event Detection and Root Finding:** It continuously monitors for various physical and
 *     numerical events along the trajectory. GSL's 1D root-finding (Brent's method, `gsl_root_fsolver_brent`)
 *     is used to precisely locate these events (e.g., zero-crossings of `R(r)`).
 * -   **Trajectory Segmentation and Turning Point Handling:** As described in
 *     Schwarzschild_Lens_Paper.pdf, §3.1.3, if a radial turning point (`R(r)=0`) is detected,
 *     the integration for the current segment is stopped. The sign of `dr/dK` (`current_sign_dr_dk`) is
 *     flipped, and the photon's state (`r`, `K`) is slightly nudged away from the turning point
 *     (by `1e-7`) to allow the integration to restart stably for the next segment. Raw trajectory
 *     data is collected in `TrajectorySegmentDataInternal` structures for each continuous segment.
 * -   **Termination Conditions:** Integration terminates if the photon is captured (`r <= 2M`),
 *     escapes (`r >= r_max_val`), crosses an `x_stop_val` plane, or exceeds `t_end_max_overall`.
 * -   **Data Collection & Output Options:**
 *     -   If `full_traj_output` is provided, all raw `(K, r, phi)` points from the GSL solver's
 *         internal steps across all continuous segments are collected. These segments are then
 *         concatenated, `phi` values are unwrapped for continuity, and the entire trajectory is
 *         finally interpolated onto a uniformly spaced grid of `num_interp_points_for_full_traj` points.
 *         Cartesian `(x, y)` coordinates are also computed for the interpolated points.
 *     -   If `crossings_output` is provided (and/or `x_targets_vec` is specified for `full_traj_output`),
 *         it precisely records the `y`-coordinates where the trajectory intersects any provided `x_target` planes.
 *
 * @param r_0 Initial radial coordinate of the photon, in Schwarzschild radii (geometric units).
 * @param phi_0 Initial azimuthal angle of the photon, in radians.
 * @param M_val Black hole mass (in geometric units).
 * @param psi Initial angle of the photon's 3-velocity relative to the local radial direction, in radians. Used to determine the impact parameter `b`.
 * @param r_max_val Maximum radial distance. If the photon reaches or exceeds this radius, the integration terminates (photon escapes).
 * @param x_stop_val Cartesian x-coordinate for a general termination plane. If `x_stop_active_flag` is true and the photon crosses this plane, integration terminates.
 * @param x_stop_active_flag Boolean flag indicating whether the `x_stop_val` termination condition is active (`true`) or ignored (`false`).
 * @param x_targets_vec A constant GSL vector of `double` values, specifying Cartesian x-coordinates of planes where y-crossings should be recorded. Can be `NULL`.
 * @param t_end_max_overall Maximum affine parameter (`\kappa`) value for the integration. This serves as an upper limit on integration time.
 * @param rtol Relative tolerance for the GSL ODE solver.
 * @param atol Absolute tolerance for the GSL ODE solver.
 * @param full_traj_output Pointer to a `PhotonTrajectory` struct to be filled with the interpolated trajectory data. Can be `NULL` if only crossings are needed.
 * @param crossings_output Pointer to a `TrajectoryCrossings` struct to be filled with y-crossing data for specified `x_targets`. Can be `NULL`.
 * @param num_interp_points_for_full_traj Desired number of interpolated points if `full_traj_output` is active. If 0, a default is used.
 * @return `int` 0 on successful integration. -1 if a non-critical integration failure occurred (e.g., stalled). Other negative values for critical allocation failures (`core_error_code`).
 * @note This function is the primary computational engine for ray tracing. Its robust event detection and turning point handling are essential for accurate lensing simulations.
 */
// In trajectory_module.c

// ASSUMPTION: All static helper functions like schwarzschild_geodesic_eqs, 
// cubic_hermite_interp_component, get_event_val_*, gsl_root_event_wrapper, 
// find_event_time_gsl, reallocate_gsl_vector_if_needed, 
// gsl_vector_dynamic_append, normalize_phi, unwrap_phi_values
// are present above this function in trajectory_module.c and are correct 
// (especially gsl_root_event_wrapper with Cubic Hermite, and event functions 
// with aligned epsilons like 1e-11 for r_leq_2M).

static int integrate_photon_trajectory_core_call_count = 0; 

static int integrate_photon_trajectory_core(
    double r_0, double phi_0, double M_val, double psi, double r_max_val,
    double x_stop_val, bool x_stop_active_flag,
    const gsl_vector *x_targets_vec,
    double t_end_max_overall, 
    double rtol, double atol, 
    PhotonTrajectory *full_traj_output,   
    TrajectoryCrossings *crossings_output, 
    int num_interp_points_for_full_traj,
    bool force_detailed_log_this_ray // <<<< NEW PARAMETER >>>>
) {
    integrate_photon_trajectory_core_call_count++;
    int current_call_instance = integrate_photon_trajectory_core_call_count;

    // ++++ NEW LOGIC BLOCK START ++++
    // Use the passed flag to control detailed logging for this specific ray instance
    bool is_target_ray_debug_c = force_detailed_log_this_ray; 
        if (fabs(psi - (-1.27933953231702957e+00)) < 1e-12 && 
        fabs(r_0 - 20.0) < 1e-5 && 
        fabs(M_val - 1.0) < 1e-5) {
        is_target_ray_debug_c = true; 
        // Optional: A print to stderr here confirms the override is active,
        // but this print itself should ideally also be guarded by a separate, more global debug flag if needed.
        // For now, just setting is_target_ray_debug_c = true is the goal.
        // fprintf(stderr, "C_DIAGNOSTIC_OVERRIDE: Detailed logging FORCED for target BasePsiPhoton values.\n"); 
        // fflush(stderr);
    }


    int core_error_code = 0; 
    double K_final_reached_integration = 0.0; 

    gsl_odeiv2_driver *d_core_driver = NULL; 
    const gsl_odeiv2_step_type *T_stepper_main_loop = gsl_odeiv2_step_rkf45;


    
    TrajectorySegmentDataInternal *segments_collected_list = NULL;
    size_t num_segments_collected = 0;
    size_t segments_collected_capacity = 0;
    gsl_vector *current_segment_K_temp = NULL, *current_segment_r_temp = NULL, *current_segment_phi_temp = NULL;
    size_t current_segment_point_count = 0; 
    size_t current_segment_K_capacity = 0, current_segment_r_capacity = 0, current_segment_phi_capacity = 0;    
    gsl_vector **crossings_collector_ptr = NULL;
    size_t *crossings_collector_capacities = NULL;
    size_t num_x_targets_val = 0;
    gsl_vector *K_all_raw = NULL, *r_all_raw = NULL, *phi_all_raw_temp = NULL, *phi_unwrapped_all = NULL;
    gsl_spline *spline_r_interp = NULL, *spline_phi_interp = NULL;
    gsl_interp_accel *acc_r_interp = NULL, *acc_phi_interp = NULL;

    // >>> BEGIN VERBATIM BLOCK 1: Initial State & Trivial Case Checks <<<
    if (r_0 <= (2.0 * M_val + EPSILON_GENERAL) || r_0 >= r_max_val) {


        K_final_reached_integration = 0.0; 
        if (full_traj_output) {
            int n_pts_trivial = (num_interp_points_for_full_traj > 0) ? num_interp_points_for_full_traj : 1;
            if (n_pts_trivial <=0) n_pts_trivial = 1; 
            full_traj_output->K = gsl_vector_calloc(n_pts_trivial); CHECK_GSL_ALLOC_VEC_CORE(full_traj_output->K, "core (trivial K)", "K", core_error_code, -1, cleanup_core);
            full_traj_output->r = gsl_vector_calloc(n_pts_trivial); CHECK_GSL_ALLOC_VEC_CORE(full_traj_output->r, "core (trivial r)", "r", core_error_code, -1, cleanup_core);
            full_traj_output->phi = gsl_vector_calloc(n_pts_trivial); CHECK_GSL_ALLOC_VEC_CORE(full_traj_output->phi, "core (trivial phi)", "phi", core_error_code, -1, cleanup_core);
            full_traj_output->x = gsl_vector_calloc(n_pts_trivial); CHECK_GSL_ALLOC_VEC_CORE(full_traj_output->x, "core (trivial x)", "x", core_error_code, -1, cleanup_core);
            full_traj_output->y = gsl_vector_calloc(n_pts_trivial); CHECK_GSL_ALLOC_VEC_CORE(full_traj_output->y, "core (trivial y)", "y", core_error_code, -1, cleanup_core);

            double phi_norm_init = normalize_phi(phi_0); 
            for (int i = 0; i < n_pts_trivial; ++i) {
                gsl_vector_set(full_traj_output->K, i, 0.0);
                gsl_vector_set(full_traj_output->r, i, r_0);
                gsl_vector_set(full_traj_output->phi, i, phi_norm_init);
                gsl_vector_set(full_traj_output->x, i, r_0 * cos(phi_norm_init));
                gsl_vector_set(full_traj_output->y, i, r_0 * sin(phi_norm_init));
            }
            full_traj_output->num_x_targets = x_targets_vec ? x_targets_vec->size : 0;
            if (full_traj_output->num_x_targets > 0) {
                full_traj_output->crossings_y_at_x_targets = calloc(full_traj_output->num_x_targets, sizeof(gsl_vector*));
                CHECK_ALLOC_GEN_CORE(full_traj_output->crossings_y_at_x_targets, "core (trivial cr_y)", "gsl_vec**", core_error_code, -1, cleanup_core);
                for (size_t i = 0; i < full_traj_output->num_x_targets; ++i) {
                    full_traj_output->crossings_y_at_x_targets[i] = gsl_vector_alloc(0); 
                    CHECK_GSL_ALLOC_VEC_CORE(full_traj_output->crossings_y_at_x_targets[i], "core (trivial cr[i])", "cr_y[i]", core_error_code, -1, cleanup_core);
                }
            } else { full_traj_output->crossings_y_at_x_targets = NULL; }
             full_traj_output->error_code = 0; 
        }
        if (crossings_output) {
            crossings_output->num_x_targets = x_targets_vec ? x_targets_vec->size : 0;
            if (crossings_output->num_x_targets > 0) {
                crossings_output->crossings_y_at_x_targets = calloc(crossings_output->num_x_targets, sizeof(gsl_vector*));
                CHECK_ALLOC_GEN_CORE(crossings_output->crossings_y_at_x_targets, "core (trivial cr_out_arr)", "gsl_vec**", core_error_code, -1, cleanup_core);
                for (size_t i = 0; i < crossings_output->num_x_targets; ++i) {
                    crossings_output->crossings_y_at_x_targets[i] = gsl_vector_alloc(0); 
                    CHECK_GSL_ALLOC_VEC_CORE(crossings_output->crossings_y_at_x_targets[i], "core (trivial cr_out[i])", "cr_out[i]", core_error_code, -1, cleanup_core);
                }
            } else { crossings_output->crossings_y_at_x_targets = NULL; }
            crossings_output->error_code = 0; 
        }
        goto cleanup_core; 
    }
    double metric_r0_term = (1.0 - 2.0 * M_val / r_0);
    if (metric_r0_term <= 0.0) { 

        K_final_reached_integration = 0.0; 
        if (full_traj_output) { 
            int n_pts_trivial = (num_interp_points_for_full_traj > 0) ? num_interp_points_for_full_traj : 1;
            if (n_pts_trivial <=0) n_pts_trivial = 1;
            full_traj_output->K = gsl_vector_calloc(n_pts_trivial); CHECK_GSL_ALLOC_VEC_CORE(full_traj_output->K, "core (metric0 K)", "K", core_error_code, -1, cleanup_core);
            full_traj_output->r = gsl_vector_calloc(n_pts_trivial); CHECK_GSL_ALLOC_VEC_CORE(full_traj_output->r, "core (metric0 r)", "r", core_error_code, -1, cleanup_core);
            full_traj_output->phi = gsl_vector_calloc(n_pts_trivial); CHECK_GSL_ALLOC_VEC_CORE(full_traj_output->phi, "core (metric0 phi)", "phi", core_error_code, -1, cleanup_core);
            full_traj_output->x = gsl_vector_calloc(n_pts_trivial); CHECK_GSL_ALLOC_VEC_CORE(full_traj_output->x, "core (metric0 x)", "x", core_error_code, -1, cleanup_core);
            full_traj_output->y = gsl_vector_calloc(n_pts_trivial); CHECK_GSL_ALLOC_VEC_CORE(full_traj_output->y, "core (metric0 y)", "y", core_error_code, -1, cleanup_core);
            double phi_norm_init = normalize_phi(phi_0);
            for (int i = 0; i < n_pts_trivial; ++i) {
                gsl_vector_set(full_traj_output->K, i, 0.0); gsl_vector_set(full_traj_output->r, i, r_0);
                gsl_vector_set(full_traj_output->phi, i, phi_norm_init);
                gsl_vector_set(full_traj_output->x, i, r_0 * cos(phi_norm_init)); gsl_vector_set(full_traj_output->y, i, r_0 * sin(phi_norm_init));
            }
            full_traj_output->num_x_targets = x_targets_vec ? x_targets_vec->size : 0;
            if (full_traj_output->num_x_targets > 0) {
                full_traj_output->crossings_y_at_x_targets = calloc(full_traj_output->num_x_targets, sizeof(gsl_vector*));
                CHECK_ALLOC_GEN_CORE(full_traj_output->crossings_y_at_x_targets, "core (metric0 cr_y)", "gsl_vec**", core_error_code, -1, cleanup_core);
                for (size_t i = 0; i < full_traj_output->num_x_targets; ++i) {
                    full_traj_output->crossings_y_at_x_targets[i] = gsl_vector_alloc(0);
                    CHECK_GSL_ALLOC_VEC_CORE(full_traj_output->crossings_y_at_x_targets[i], "core (metric0 cr[i])", "cr_y[i]", core_error_code, -1, cleanup_core);
                }
            } else { full_traj_output->crossings_y_at_x_targets = NULL; }
            full_traj_output->error_code = 0;
        }
        if (crossings_output) { 
            crossings_output->num_x_targets = x_targets_vec ? x_targets_vec->size : 0;
            if (crossings_output->num_x_targets > 0) {
                crossings_output->crossings_y_at_x_targets = calloc(crossings_output->num_x_targets, sizeof(gsl_vector*));
                CHECK_ALLOC_GEN_CORE(crossings_output->crossings_y_at_x_targets, "core (metric0 cr_out_arr)", "gsl_vec**", core_error_code, -1, cleanup_core);
                for (size_t i = 0; i < crossings_output->num_x_targets; ++i) {
                    crossings_output->crossings_y_at_x_targets[i] = gsl_vector_alloc(0);
                    CHECK_GSL_ALLOC_VEC_CORE(crossings_output->crossings_y_at_x_targets[i], "core (metric0 cr_out[i])", "cr_out[i]", core_error_code, -1, cleanup_core);
                }
            } else { crossings_output->crossings_y_at_x_targets = NULL; }
            crossings_output->error_code = 0;
        }
        goto cleanup_core;
    }
    // >>> END VERBATIM BLOCK 1 <<<
    double b_val = cos(psi) * r_0 / sqrt(metric_r0_term); 
    
    int current_sign_dr_dk;
    // >>> BEGIN VERBATIM BLOCK 2 <<< (Initial sign_dr_dk logic - ALIGNED VERSION)
    if (sin(psi) > EPSILON_GENERAL) { 
        current_sign_dr_dk = 1; 
    } else if (sin(psi) < -EPSILON_GENERAL) { 
        current_sign_dr_dk = -1; 
    } else { 
        current_sign_dr_dk = 1; 
    }
    // >>> END VERBATIM BLOCK 2 <<<

    // ADD THIS:
printf("INIT_PARAMS_C B %.17e SIGN_DRDK_INIT %d\n", b_val, current_sign_dr_dk);
fflush(stdout); // Ensure it's printed immediately



    // ++++ NEW LOGIC BLOCK START ++++
    // (This log was previously present but now uses the new prefix and psi variable for clarity)
    if (is_target_ray_debug_c) {
        fprintf(stderr, "  C_DEBUG_TRAJ_DETAIL (LOG_FORCED psi=%.17e): Calculated b_val=%.17e, initial_sign_dr_dk=%d\n", 
                psi, b_val, current_sign_dr_dk);
    }
    // ++++ NEW LOGIC BLOCK END ++++
    ODEParams ode_params_instance;
    ode_params_instance.M = M_val; ode_params_instance.b = b_val; ode_params_instance.sign_dr_dk = &current_sign_dr_dk;
    gsl_odeiv2_system sys = {schwarzschild_geodesic_eqs, NULL, 2, &ode_params_instance};
    
       // +++++++  New Code Start (Allocate GSL Driver for main loop) ++++++
    // h_gsl_step is your initial step size parameter passed to or defined in this function
    double h_gsl_step = 1e-6; 

    d_core_driver = gsl_odeiv2_driver_alloc_y_new(&sys, T_stepper_main_loop,h_gsl_step,1e-12, 1e-12); 
    if (!d_core_driver) {
        fprintf(stderr, "integrate_photon_trajectory_core: Failed to allocate GSL driver d_core_driver.\n");
        core_error_code = -2; // Allocation error
        goto cleanup_core; // Assuming cleanup_core handles freeing other resources
    }
    // Optional: Set hmin for the main driver if needed
    // int status_hmin = gsl_odeiv2_driver_set_hmin(d_core_driver, 1e-12); // Example hmin
    // if (status_hmin != GSL_SUCCESS) { 
    //     fprintf(stderr, "Warning: Failed to set hmin for d_core_driver.\n"); 
    // }
    // +++ New Code End (Allocate GSL Driver for main loop) ++++++


    double K_loop_variable = 0.0; 
    double y_current_state[2] = {r_0, phi_0}; 
    
    if (full_traj_output) {
        // >>> BEGIN VERBATIM BLOCK 3 <<< (Setup for full_traj_output (Segment Buffers & Initial Point))
        segments_collected_capacity = INITIAL_SEGMENTS_CAPACITY; 
        segments_collected_list = malloc(segments_collected_capacity * sizeof(TrajectorySegmentDataInternal));
        CHECK_ALLOC_GEN_CORE(segments_collected_list, "core (segments_list)", "SegList", core_error_code, -1, cleanup_core);
        for(size_t i=0; i<segments_collected_capacity; ++i) {
            segments_collected_list[i].K_pts = NULL; segments_collected_list[i].r_pts = NULL; segments_collected_list[i].phi_pts = NULL;
        }
        current_segment_K_capacity = INITIAL_RAW_POINTS_CAPACITY;
        current_segment_r_capacity = INITIAL_RAW_POINTS_CAPACITY;
        current_segment_phi_capacity = INITIAL_RAW_POINTS_CAPACITY;
        current_segment_K_temp = gsl_vector_alloc(current_segment_K_capacity); 
        CHECK_GSL_ALLOC_VEC_CORE(current_segment_K_temp, "core (K_temp init)", "K_temp", core_error_code, -1, cleanup_core);
        current_segment_r_temp = gsl_vector_alloc(current_segment_r_capacity); 
        CHECK_GSL_ALLOC_VEC_CORE(current_segment_r_temp, "core (r_temp init)", "r_temp", core_error_code, -1, cleanup_core);
        current_segment_phi_temp = gsl_vector_alloc(current_segment_phi_capacity); 
        CHECK_GSL_ALLOC_VEC_CORE(current_segment_phi_temp, "core (phi_temp init)", "phi_temp", core_error_code, -1, cleanup_core);
        
        gsl_vector_set(current_segment_K_temp, 0, K_loop_variable); 
        gsl_vector_set(current_segment_r_temp, 0, y_current_state[0]);
        gsl_vector_set(current_segment_phi_temp, 0, y_current_state[1]);
        current_segment_point_count = 1;
        // >>> END VERBATIM BLOCK 3 <<<
    }
    if (x_targets_vec && (full_traj_output || crossings_output)) {
        num_x_targets_val = x_targets_vec->size;
        if (num_x_targets_val > 0) {
            // >>> BEGIN VERBATIM BLOCK 4 <<< (Setup for crossings_collector_ptr)
            crossings_collector_ptr = calloc(num_x_targets_val, sizeof(gsl_vector*)); 
            CHECK_ALLOC_GEN_CORE(crossings_collector_ptr, "core (cr_coll_ptr)","gsl_vec**", core_error_code, -1, cleanup_core);
            crossings_collector_capacities = calloc(num_x_targets_val, sizeof(size_t)); 
            CHECK_ALLOC_GEN_CORE(crossings_collector_capacities, "core (cr_coll_cap)","size_t*", core_error_code, -1, cleanup_core);
            for (size_t i = 0; i < num_x_targets_val; ++i) {
                crossings_collector_capacities[i] = INITIAL_CROSSING_POINTS_CAPACITY;
                crossings_collector_ptr[i] = gsl_vector_alloc(crossings_collector_capacities[i]); 
                CHECK_GSL_ALLOC_VEC_CORE(crossings_collector_ptr[i], "core (cr_coll[i])","coll[i]", core_error_code, -1, cleanup_core);
                crossings_collector_ptr[i]->size = 0; 
            }
            // >>> END VERBATIM BLOCK 4 <<<
        }
    }
    GslRootEventParams root_params_instance_for_solver; 
    EventFunctionParams event_params_instances[MAX_EVENT_TYPES_CORE];
    double (*event_get_val_func_ptrs[MAX_EVENT_TYPES_CORE])(double, const double[], EventFunctionParams*);
    bool event_is_terminal[MAX_EVENT_TYPES_CORE];
    int event_crossing_dir[MAX_EVENT_TYPES_CORE];
    int event_is_x_target_idx_map[MAX_EVENT_TYPES_CORE];
    size_t num_active_event_funcs = 0; 
    // >>> BEGIN VERBATIM BLOCK 5 <<< (Event Function Setup)
    event_params_instances[num_active_event_funcs].ode_p_event = &ode_params_instance; 
    event_get_val_func_ptrs[num_active_event_funcs] = get_event_val_fr_zero; 
    event_is_terminal[num_active_event_funcs] = true; event_crossing_dir[num_active_event_funcs] = 0; 
    event_is_x_target_idx_map[num_active_event_funcs] = -1; num_active_event_funcs++; 

    event_params_instances[num_active_event_funcs].M = M_val; 
    event_get_val_func_ptrs[num_active_event_funcs] = get_event_val_r_leq_2M; 
    event_is_terminal[num_active_event_funcs] = true; event_crossing_dir[num_active_event_funcs] = -1; 
    event_is_x_target_idx_map[num_active_event_funcs] = -1; num_active_event_funcs++;

    event_params_instances[num_active_event_funcs].r_max_event = r_max_val; 
    event_get_val_func_ptrs[num_active_event_funcs] = get_event_val_r_max; 
    event_is_terminal[num_active_event_funcs] = true; event_crossing_dir[num_active_event_funcs] = 1; 
    event_is_x_target_idx_map[num_active_event_funcs] = -1; num_active_event_funcs++;
    
    if (x_stop_active_flag) {
        event_params_instances[num_active_event_funcs].x_stop_event = x_stop_val; 
        event_get_val_func_ptrs[num_active_event_funcs] = get_event_val_x_stop; 
        event_is_terminal[num_active_event_funcs] = true; event_crossing_dir[num_active_event_funcs] = -1; 
        event_is_x_target_idx_map[num_active_event_funcs] = -1; num_active_event_funcs++;
    }

    if (x_targets_vec && num_x_targets_val > 0) {
        for (size_t i = 0; i < num_x_targets_val; ++i) {
            if (num_active_event_funcs >= MAX_EVENT_TYPES_CORE) { 
                fprintf(stderr, "integrate_photon_trajectory_core: Too many event types defined. MAX_EVENT_TYPES_CORE (%d) exceeded.\n", MAX_EVENT_TYPES_CORE); 
                core_error_code = -2; goto cleanup_core; 
            }
            event_params_instances[num_active_event_funcs].x_target_event = gsl_vector_get(x_targets_vec, i); 
            event_get_val_func_ptrs[num_active_event_funcs] = get_event_val_x_target; 
            event_is_terminal[num_active_event_funcs] = false; 
            event_crossing_dir[num_active_event_funcs] = -1;   
            event_is_x_target_idx_map[num_active_event_funcs] = (int)i; 
            num_active_event_funcs++;
        }
    }
    // >>> END VERBATIM BLOCK 5 <<<

    int integration_stop_code = 0; 
    int safety_break_counter = 0;
    const int MAX_SAFETY_BREAK_CORE_EVOLVE = 5e7; 
    const double MIN_K_PROGRESS_PER_ITER_EVOLVE = 1e-14;

     // ++++ NEW LOGIC BLOCK START ++++
    if (is_target_ray_debug_c) { 
        fprintf(stderr, "  C_DEBUG_TRAJ_DETAIL (LOG_FORCED psi=%.17e): Setup complete. Entering main integration while loop.\n", psi); 
    }
    // ++++ NEW LOGIC BLOCK END ++++


        // New line: Add this log *before* the main while loop
    if (is_target_ray_debug_c) { // New line
        fprintf(stderr, "  C_DEBUG_TRAJ_DETAIL (PSI_MATCH=%.17e): Setup complete. Entering main integration while loop.\n", psi); // New line
    } // New line

    // --- Main Integration Loop using GSL Evolver ---
       // --- Main Integration Loop using GSL Evolver ---
while (K_loop_variable < t_end_max_overall && integration_stop_code == 0 && safety_break_counter < MAX_SAFETY_BREAK_CORE_EVOLVE) {
        safety_break_counter++;

        // 1. CAPTURE STATE AT THE START OF THE SUPER-STEP
        // These variables hold the state *before* gsl_odeiv2_evolve_apply is called for this iteration.
        double K_step_start = K_loop_variable; // Current K is the start of this super-step
        double y_step_start[2];
        memcpy(y_step_start, y_current_state, 2 * sizeof(double)); // Current state is the start state

        // Calculate derivatives at the start of the super-step. These are needed for Hermite interpolation.
        double f_derivs_step_start[2];
        if (schwarzschild_geodesic_eqs(K_step_start, y_step_start, f_derivs_step_start, &ode_params_instance) != GSL_SUCCESS) {
            fprintf(stderr, "integrate_photon_trajectory_core: Error calculating derivatives at K_step_start=%.15e for state (r=%.15e, phi=%.15e).\n", K_step_start, y_step_start[0], y_step_start[1]);
            integration_stop_code = 3; // Indicate GSL/ODE system error
            K_final_reached_integration = K_step_start;
            break; // Exit the while loop
        }

         double K_before_driver_apply = K_loop_variable;

           // +++++++  New Code Start (Two-Tier delta_K_for_this_step determination) ++++++
        const double delta_K_application_step_normal = 1e-3;
        const double delta_K_application_step_fine_TP = 1e-6; 
        double current_delta_K_for_this_step = delta_K_application_step_normal; // Default to normal

        size_t idx_fr_zero_event_params = 0; 
        for (size_t i_ev_param = 0; i_ev_param < num_active_event_funcs; ++i_ev_param) {
            if (event_get_val_func_ptrs[i_ev_param] == get_event_val_fr_zero) {
                idx_fr_zero_event_params = i_ev_param;
                break;
            }
        }
        double R_current_estimate = get_event_val_fr_zero(K_loop_variable, y_current_state, &event_params_instances[idx_fr_zero_event_params]);

        const double R_proximity_threshold = 0.01; 
        const double K_min_for_TP_fine_step = 15.0; 
        const double K_max_for_TP_fine_step = 25.0; 

        if (fabs(R_current_estimate) < R_proximity_threshold && 
            K_loop_variable > K_min_for_TP_fine_step && K_loop_variable < K_max_for_TP_fine_step &&
            *ode_params_instance.sign_dr_dk == -1 ) { 
            
            current_delta_K_for_this_step = delta_K_application_step_fine_TP;
            if (is_target_ray_debug_c) {
                fprintf(stderr, "C_DEBUG_TRAJ_DETAIL: TP suspected (R(r)=%.3e, K=%.3e). Using FINE delta_K = %.1e for next application step.\n", 
                        R_current_estimate, K_loop_variable, current_delta_K_for_this_step);
                fflush(stderr);
            }
        }
        // +++ New Code End (Two-Tier delta_K_for_this_step determination) ++++++

         double K_target_for_this_application_step = K_loop_variable + current_delta_K_for_this_step;

        


        if (K_target_for_this_application_step > t_end_max_overall) {
            K_target_for_this_application_step = t_end_max_overall;
        }

        // Logic to shrink K_target_for_this_application_step if approaching x_stop_val
        // This is from LLM2's Mod #1, adapted here.
        if (x_stop_active_flag) {
            double current_x_coord_for_step_logic = y_current_state[0] * cos(y_current_state[1]);
            // Assuming x decreases towards x_stop_val. Adjust if x increases.
            // Check if we are close AND moving towards x_stop_val.
            // The condition (current_x_coord_for_step_logic > x_stop_val) assumes x_stop_val is to the "left".
            // The (current_x_coord_for_step_logic < x_stop_val + 2.0) defines "close".
            // A more robust check might also consider the sign of dx/dK if available.
            const double approach_threshold_delta_x = 1.2; // Start adaptive stepping 1.2 X-units before x_stop_val
                                                            // To trigger around -9.9 for x_stop = -11, this should be -11 + 1.1 = -9.9
                                                            // So, current_x_coord < x_stop_val + approach_threshold_delta_x

            if ((current_x_coord_for_step_logic > x_stop_val) && // Still to the "right" of x_stop_val
                (current_x_coord_for_step_logic < x_stop_val + approach_threshold_delta_x) ) { // e.g. within 10% + 0.5 units
                
                 double adaptive_shrink_factor = 0.1; // How much to shrink by
                double min_shrunk_k_step = 1e-7;     // Absolute minimum K step when shrunk
                 double potentially_shrunk_application_step = fmax(current_delta_K_for_this_step * adaptive_shrink_factor, min_shrunk_k_step);
                
                // Ensure the new target doesn't overshoot t_end_max_overall
                double new_target_K = K_loop_variable + potentially_shrunk_application_step;
                if (new_target_K > t_end_max_overall) {
                    new_target_K = t_end_max_overall;
                }
                
                // Only update if the new target is meaningfully different and still ahead
                if (new_target_K > K_loop_variable + DBL_EPSILON && new_target_K < K_target_for_this_application_step) {
                     K_target_for_this_application_step = new_target_K;
                     if (is_target_ray_debug_c) { // Log this important adaptation
                        fprintf(stderr, "C_DEBUG_TRAJ_DETAIL: Approaching x_stop_val (x_current=%.3e, x_stop=%.3e, threshold_x=%.3e). Reduced K_target_for_application_step to %.17e\n",
                                current_x_coord_for_step_logic, x_stop_val, x_stop_val + approach_threshold_delta_x, K_target_for_this_application_step);
                        fflush(stderr);
                     }
                }
            }
        }
        // +++ New Code End++++++
        

        int status_driver = gsl_odeiv2_driver_apply(d_core_driver, &K_loop_variable, 
                                                 K_target_for_this_application_step, y_current_state);

        // +++++++  New Code Start (Error check for status_driver) ++++++
        if (status_driver != GSL_SUCCESS) {
            fprintf(stderr, "GSL ODE driver_apply error: %s (GSL Code %d) (K_start_iter=%.17e, K_target_application_step=%.17e, r_start=%.2e, phi_start=%.2e)\n",
                    gsl_strerror(status_driver), status_driver, K_step_start, K_target_for_this_application_step, 
                    y_step_start[0], y_step_start[1]);
            integration_stop_code = 3; 
            K_final_reached_integration = K_before_driver_apply; // K before this failed driver call
            break; 
        }
        // +++ New Code End (Error check for status_driver) ++++++

        // 3. CAPTURE STATE AT THE END OF THE SUPER-STEP
        double K_step_end = K_loop_variable; // K_loop_variable is now the K at the end of the super-step
        // y_current_state already holds the [r, phi] at K_step_end

        // Calculate derivatives at the end of the super-step. Needed for Hermite interpolation.
        double f_derivs_step_end[2];
        if (schwarzschild_geodesic_eqs(K_step_end, y_current_state, f_derivs_step_end, &ode_params_instance) != GSL_SUCCESS) {
             fprintf(stderr, "integrate_photon_trajectory_core: Error calculating derivatives at K_step_end=%.15e for state (r=%.15e, phi=%.15e).\n", K_step_end, y_current_state[0], y_current_state[1]);
             integration_stop_code = 3; // Indicate GSL/ODE system error
             K_final_reached_integration = K_step_end;
             break; // Exit the while loop
        }

        K_final_reached_integration = K_step_end; // Update overall final K reached


        if (full_traj_output) {
            // VERBATIM BLOCK 6 (Storing Point in current_segment_X_temp) - This block looks correct
            if (reallocate_gsl_vector_if_needed(&current_segment_K_temp, current_segment_point_count, &current_segment_K_capacity, INITIAL_RAW_POINTS_CAPACITY) != 0 ||
                reallocate_gsl_vector_if_needed(&current_segment_r_temp, current_segment_point_count, &current_segment_r_capacity, INITIAL_RAW_POINTS_CAPACITY) != 0 ||
                reallocate_gsl_vector_if_needed(&current_segment_phi_temp, current_segment_point_count, &current_segment_phi_capacity, INITIAL_RAW_POINTS_CAPACITY) != 0) {
                integration_stop_code = 3; K_final_reached_integration = K_step_start; core_error_code = -1; break; 
            }
            gsl_vector_set(current_segment_K_temp, current_segment_point_count, K_step_end);
            gsl_vector_set(current_segment_r_temp, current_segment_point_count, y_current_state[0]); 
            gsl_vector_set(current_segment_phi_temp, current_segment_point_count, y_current_state[1]);
            current_segment_point_count++;
        }
//vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
        // START OF MODIFIED "SegEnd" LOGGING BLOCK
        //vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
        if (is_target_ray_debug_c) {
            const int LOG_SEG_END_EVERY_N_STEPS = 100; // Log every 100 super-steps
            bool should_log_this_seg_end = (safety_break_counter == 1) || // Always log the first super-step's end
                                           (safety_break_counter % LOG_SEG_END_EVERY_N_STEPS == 0);



            if (should_log_this_seg_end) {
                fprintf(stderr, "  C_DEBUG_TRAJ_DETAIL (LOG_FORCED psi=%.17e) SegEnd %d: K=%.17e, r=%.17e, phi=%.17e, x_cart=%.17e, dr/dK=%.6e, dphi/dK=%.6e, cur_sign=%d\n",
                        psi, 
                        (int)safety_break_counter, // safety_break_counter is an int
                        K_step_end, y_current_state[0], y_current_state[1],
                        y_current_state[0] * cos(y_current_state[1]),
                        f_derivs_step_end[0], 
                        f_derivs_step_end[1],
                        ode_params_instance.sign_dr_dk ? *ode_params_instance.sign_dr_dk : 0);
            }
        }
        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        // END OF MODIFIED "SegEnd" LOGGING BLOCK
        //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

        if (K_step_end <= K_before_driver_apply + MIN_K_PROGRESS_PER_ITER_EVOLVE) { 
             if (K_loop_variable >= t_end_max_overall - EPSILON_GENERAL * 10.0) { 
                 integration_stop_code = 1; K_final_reached_integration = t_end_max_overall; K_loop_variable = t_end_max_overall; break;
             } else if (safety_break_counter > 5000) { 
                fprintf(stderr, "Warning: GSL ODE driver stalled at K=%.15e (K_before_driver_apply=%.15e). Driver internal h=%.3e. Terminating.\n", 
        K_loop_variable, K_before_driver_apply, d_core_driver ? d_core_driver->h : NAN);
                integration_stop_code = 4; K_final_reached_integration = K_loop_variable; break;
            }
        }
        
        // +++++++  New Code Start (Update root_params_instance_for_solver) ++++++
        // 4. PREPARE GslRootEventParams FOR EVENT DETECTION WITHIN THIS *SMALLER* APPLICATION-LEVEL STEP
        //    This populates root_params_instance_for_solver with the data from the interval
        //    [K_step_start, K_step_end] which was just computed.
        
        root_params_instance_for_solver.K_prev_super_step = K_step_start;
        memcpy(root_params_instance_for_solver.y_state_at_K_prev_super_step, y_step_start, 2 * sizeof(double));
        memcpy(root_params_instance_for_solver.f_derivs_at_K_prev_super_step, f_derivs_step_start, 2 * sizeof(double));
        
        root_params_instance_for_solver.K_curr_super_step = K_step_end; // This is the new K_loop_variable
        memcpy(root_params_instance_for_solver.y_state_at_K_curr_super_step, y_current_state, 2 * sizeof(double));
        memcpy(root_params_instance_for_solver.f_derivs_at_K_curr_super_step, f_derivs_step_end, 2 * sizeof(double));
        // +++ New Code End++++++


        // 5. EVENT DETECTION LOOP (Two-Pass: Non-Terminal, then Terminal)

        // --- Pass 1: Record all non-terminal x_target events ---
        for (size_t ev_idx = 0; ev_idx < num_active_event_funcs; ++ev_idx) {
            if (event_is_terminal[ev_idx]) continue; // Skip terminal events in this pass

            double K_event_found_xtarget;
            double y_state_at_xtarget[2];

            // Populate the parts of root_params_instance_for_solver specific to this event type
            root_params_instance_for_solver.event_params_root = &event_params_instances[ev_idx];
            root_params_instance_for_solver.get_event_val_func_root = event_get_val_func_ptrs[ev_idx];



            int event_found_flag_xtarget = find_event_time_gsl(
                K_step_start, y_step_start,   // For initial bracketing value check
                K_step_end, y_current_state,  // For initial bracketing value check
                &root_params_instance_for_solver, // Pass the fully populated struct
                event_crossing_dir[ev_idx],
                &K_event_found_xtarget,
                y_state_at_xtarget
            );

            if (event_found_flag_xtarget) {
                // This is your VERBATIM BLOCK 7 logic
                if (K_event_found_xtarget > K_step_start + (EVENT_DETECTION_TOLERANCE * 0.1) &&
                    K_event_found_xtarget <= K_step_end + EVENT_DETECTION_TOLERANCE) {
                    int x_target_list_idx_local = event_is_x_target_idx_map[ev_idx];
                    if (x_target_list_idx_local >= 0 && (size_t)x_target_list_idx_local < num_x_targets_val) {
                        double y_val_to_add_crossing = y_state_at_xtarget[0] * sin(y_state_at_xtarget[1]);

                                                // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                        // START MODIFICATION FOR STEP 1
                        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                        // Check if this x_target is our source plane (e.g., x = -10.0)
                        // Assuming x_targets_vec contains the x-values of target planes
                        // and x_target_list_idx_local is the index into x_targets_vec
                        if (x_targets_vec && (size_t)x_target_list_idx_local < x_targets_vec->size) {
                            double current_target_x_value = gsl_vector_get(x_targets_vec, (size_t)x_target_list_idx_local);
                            // Define your source plane x-coordinate (e.g., -10.0)
                            const double SOURCE_PLANE_X_COORD_TARGET = -10.0; 
                                                        
                            if (fabs(current_target_x_value - SOURCE_PLANE_X_COORD_TARGET) < EPSILON_GENERAL * 0.1) {
                                if (is_target_ray_debug_c) { // Use your existing flag for targeted logging
                                    fprintf(stderr, "    C_DEBUG_TRAJ_DETAIL (LOG_FORCED psi=%.17e) PreciseSourceCrossing: K=%.17e, r=%.17e, phi=%.17e, y_image=%.17e, x_plane_target=%.1f\n",
                                            psi, // Assuming 'psi' is available in this scope from function parameters
                                            K_event_found_xtarget,
                                            y_state_at_xtarget[0], // Interpolated r
                                            y_state_at_xtarget[1], // Interpolated phi
                                            y_val_to_add_crossing, // Calculated y_image
                                            current_target_x_value);
                                }
                            }
                        }
                        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                        // END MODIFICATION FOR STEP 1
                        // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


                        if (gsl_vector_dynamic_append(&crossings_collector_ptr[x_target_list_idx_local], y_val_to_add_crossing, &crossings_collector_capacities[x_target_list_idx_local]) != 0) {
                            integration_stop_code = 3; core_error_code = -1; goto end_event_processing_loop;
                        }
                    }
                }
            }
        } 
        end_event_processing_loop:; 
        if (integration_stop_code == 3 && core_error_code == -1) { K_final_reached_integration = K_step_start; break; }


       // --- Pass 2: Find the earliest *terminal* event ---
// --- Pass 2: Find the earliest *terminal* event ---
        double K_earliest_terminal_event = K_step_end + 1.0; 
        int idx_earliest_terminal_event = -1;
        double y_at_earliest_terminal_event[2]; 
        y_at_earliest_terminal_event[0] = GSL_NAN; 
        y_at_earliest_terminal_event[1] = GSL_NAN;

        for (size_t ev_idx = 0; ev_idx < num_active_event_funcs; ++ev_idx) {
            if (!event_is_terminal[ev_idx]) continue;

            double K_event_found_this_type;
            // This array will store the state found by find_event_time_gsl (Hermite-based)
            // or will remain NAN if find_tp_event_time_with_spline is called (as it doesn't output state).
            double y_state_at_this_event_type[2]; 
            y_state_at_this_event_type[0] = GSL_NAN; 
            y_state_at_this_event_type[1] = GSL_NAN;
            int event_found_flag = 0;

            if (event_get_val_func_ptrs[ev_idx] == get_event_val_fr_zero) {
                // For TP (fr_zero), use the new spline-based root finder
                event_found_flag = find_tp_event_time_with_spline(
                    K_step_start, y_step_start,         
                    K_step_end,                         
                    &sys,                               
                    &event_params_instances[ev_idx],    
                    is_target_ray_debug_c,              
                    &K_event_found_this_type            
                );
            } else {
                // For other terminal events, use the existing Hermite-based find_event_time_gsl
                root_params_instance_for_solver.event_params_root = &event_params_instances[ev_idx];
                root_params_instance_for_solver.get_event_val_func_root = event_get_val_func_ptrs[ev_idx];
                
                event_found_flag = find_event_time_gsl(
                    root_params_instance_for_solver.K_prev_super_step, 
                    root_params_instance_for_solver.y_state_at_K_prev_super_step, 
                    root_params_instance_for_solver.K_curr_super_step, 
                    root_params_instance_for_solver.y_state_at_K_curr_super_step, 
                    &root_params_instance_for_solver,
                    event_crossing_dir[ev_idx],
                    &K_event_found_this_type,   
                    //------- Remove Code Start---------
                    // y_state_hermite_temp  // This was the error
                    //----------Remove Code End--------
                    // +++++++  New Code Start (Use correct variable) ++++++
                    y_state_at_this_event_type  // This populates y_state_at_this_event_type
                    // +++ New Code End (Use correct variable) ++++++
                );
            }
            
            if (event_found_flag) {
                if (K_event_found_this_type < K_earliest_terminal_event) {
                    K_earliest_terminal_event = K_event_found_this_type;
                    idx_earliest_terminal_event = ev_idx;
                    if (event_get_val_func_ptrs[idx_earliest_terminal_event] != get_event_val_fr_zero) {
                        //------- Remove Code Start---------
                        // memcpy(y_at_earliest_terminal_event, y_state_hermite_temp, 2 * sizeof(double));
                        //----------Remove Code End--------
                        // +++++++  New Code Start (Use correct variable) ++++++
                        memcpy(y_at_earliest_terminal_event, y_state_at_this_event_type, 2 * sizeof(double));
                        // +++ New Code End (Use correct variable) ++++++
                    } else {
                         y_at_earliest_terminal_event[0] = GSL_NAN; 
                         y_at_earliest_terminal_event[1] = GSL_NAN;
                    }
                } else if (fabs(K_event_found_this_type - K_earliest_terminal_event) < EVENT_DETECTION_TOLERANCE * 0.01) {
                    bool update_earliest = false;
                    if (event_get_val_func_ptrs[ev_idx] == get_event_val_fr_zero) { 
                        update_earliest = true;
                    } else if (event_get_val_func_ptrs[ev_idx] == get_event_val_r_leq_2M) { 
                        if (idx_earliest_terminal_event == -1 || 
                            event_get_val_func_ptrs[idx_earliest_terminal_event] != get_event_val_fr_zero) { 
                            update_earliest = true;
                        }
                    } 
                    if (update_earliest) {
                        K_earliest_terminal_event = K_event_found_this_type;
                        idx_earliest_terminal_event = ev_idx;
                        if (event_get_val_func_ptrs[idx_earliest_terminal_event] != get_event_val_fr_zero) {
                            //------- Remove Code Start---------
                            // memcpy(y_at_earliest_terminal_event, y_state_hermite_temp, 2 * sizeof(double));
                            //----------Remove Code End--------
                            // +++++++  New Code Start (Use correct variable) ++++++
                            memcpy(y_at_earliest_terminal_event, y_state_at_this_event_type, 2 * sizeof(double));
                            // +++ New Code End (Use correct variable) ++++++
                        } else {
                             y_at_earliest_terminal_event[0] = GSL_NAN; 
                             y_at_earliest_terminal_event[1] = GSL_NAN;
                        }
                    }
                }
            }
        } // End of loop checking terminal events

        // +++++++  New Code Start (Modified conditional and entire event processing block) ++++++
        if (idx_earliest_terminal_event != -1 && integration_stop_code == 0) {
            
            double K_event_root_found = K_earliest_terminal_event; 


            
            // This new block calculates accurate K_loop_variable and y_current_state at K_event_root_found.
            if (is_target_ray_debug_c) {
                fprintf(stderr, "C_DEBUG_TRAJ_DETAIL (PSI_MATCH=%.17e): Root-finder K_event=%.17e. Hermite state [r,phi]=[%.17e, %.17e]. RE-INTEGRATING from K_seg_start=%.17e.\n",
                        psi, K_event_root_found, 
                        y_at_earliest_terminal_event[0], y_at_earliest_terminal_event[1], 
                        root_params_instance_for_solver.K_prev_super_step);
                fflush(stderr);
            }

            double K_accurate_event_reached_temp_local; 
            double y_state_accurate_at_event_temp_local[2]; 

const gsl_odeiv2_step_type *T_reint_driver_stepper_local = gsl_odeiv2_step_rkf45; 
            double h_reint_initial_driver_local = 1e-8; 
            
            gsl_odeiv2_driver *d_reint_driver_local = gsl_odeiv2_driver_alloc_y_new(&sys, T_reint_driver_stepper_local,
                                                                              h_reint_initial_driver_local,
                                                                              1e-15, 1e-15); // VERY STRICT TOLERANCES

            if (!d_reint_driver_local) {
                fprintf(stderr, "integrate_photon_trajectory_core: Failed to allocate temporary GSL DRIVER for re-integration. Using Hermite state as fallback.\n");
                fflush(stderr);
                K_loop_variable = K_event_root_found; 
                memcpy(y_current_state, y_at_earliest_terminal_event, 2 * sizeof(double)); 
                core_error_code = -4; // Specific error code for this failure
            } else {
                K_accurate_event_reached_temp_local = root_params_instance_for_solver.K_prev_super_step; 
                memcpy(y_state_accurate_at_event_temp_local, root_params_instance_for_solver.y_state_at_K_prev_super_step, 2 * sizeof(double));

                if (is_target_ray_debug_c ) {
                    fprintf(stderr, "C_REINT_DEBUG_DRIVER: Starting re-integration with DRIVER. Initial K_reint = %.17e, Target K_event_root_found = %.17e\n",
                            K_accurate_event_reached_temp_local, K_event_root_found);
                    fflush(stderr);
                }

                int status_reint_driver = gsl_odeiv2_driver_apply(d_reint_driver_local, 
                                                               &K_accurate_event_reached_temp_local, 
                                                               K_event_root_found,                   
                                                               y_state_accurate_at_event_temp_local);

                if (is_target_ray_debug_c) {
                    fprintf(stderr, "C_REINT_DEBUG_DRIVER: Re-integration with DRIVER finished. Status = %d (%s). K reached by reint_driver = %.17e, Driver's h last = %.3e\n",
                            status_reint_driver, gsl_strerror(status_reint_driver), K_accurate_event_reached_temp_local, d_reint_driver_local->h);
                    fflush(stderr);
                }

                if (status_reint_driver != GSL_SUCCESS) {
                    fprintf(stderr, "integrate_photon_trajectory_core: RE-INTEGRATION with DRIVER to K_event FAILED (status %s, GSL code %d) target K=%.17e, K reached=%.17e. Using Hermite state as fallback.\n", 
                            gsl_strerror(status_reint_driver), status_reint_driver, K_event_root_found, K_accurate_event_reached_temp_local);
                    fflush(stderr);
                    K_loop_variable = K_event_root_found; 
                    memcpy(y_current_state, y_at_earliest_terminal_event, 2 * sizeof(double)); 
                } else {
                    if (fabs(K_accurate_event_reached_temp_local - K_event_root_found) > 1e-12 * fabs(K_event_root_found) + 1e-14 ) { // Relative and absolute check
                         fprintf(stderr, "Warning: Re-integration DRIVER K (%.17e) differs significantly from target K_event_root_found (%.17e). Diff: %.3e. Using driver result anyway.\n",
                            K_accurate_event_reached_temp_local, K_event_root_found, K_accurate_event_reached_temp_local - K_event_root_found);
                            fflush(stderr);
                    }
                    K_loop_variable = K_accurate_event_reached_temp_local; 
                    memcpy(y_current_state, y_state_accurate_at_event_temp_local, 2 * sizeof(double)); 
                    
                    // Your existing REINT_STATE_C_... logging block:
                    if (is_target_ray_debug_c) { /* ... same as before ... */ }
                }
                gsl_odeiv2_driver_free(d_reint_driver_local); d_reint_driver_local = NULL;
            } 
            
            // VERBATIM BLOCK 9 (Updating Last Point in current_segment_X_temp with ACCURATE event state)
            if (full_traj_output && current_segment_point_count > 0 && integration_stop_code == 0) {
                size_t last_idx_in_temp = current_segment_point_count - 1; 
                gsl_vector_set(current_segment_K_temp, last_idx_in_temp, K_loop_variable); 
                gsl_vector_set(current_segment_r_temp, last_idx_in_temp, y_current_state[0]); 
                gsl_vector_set(current_segment_phi_temp, last_idx_in_temp, y_current_state[1]); 
            }

            // Event-specific actions using the ACCURATE K_loop_variable and y_current_state
            if (event_get_val_func_ptrs[idx_earliest_terminal_event] == get_event_val_fr_zero) { 
                // This is the fr_zero (turning point) event
                
                printf("TP_PRE_NUDGE_C K %.17e R %.17e PHI %.17e SIGN %d\n", 
                       K_loop_variable, y_current_state[0], y_current_state[1], *ode_params_instance.sign_dr_dk); 
                fflush(stdout); 

                // VERBATIM BLOCK 10: Store the just-completed segment
                if (full_traj_output && current_segment_point_count > 0 && integration_stop_code == 0) {
                    if (num_segments_collected >= segments_collected_capacity) {
                        size_t new_cap = (segments_collected_capacity == 0) ? INITIAL_SEGMENTS_CAPACITY : segments_collected_capacity * 2;
                        TrajectorySegmentDataInternal *temp_realloc_seg_list = 
                            realloc(segments_collected_list, new_cap * sizeof(TrajectorySegmentDataInternal));
                        if (!temp_realloc_seg_list) {
                            fprintf(stderr, "integrate_photon_trajectory_core: Failed to realloc segments_collected_list for TP.\n");
                            integration_stop_code = 3; core_error_code = -1;
                        } else {
                            segments_collected_list = temp_realloc_seg_list;
                            segments_collected_capacity = new_cap;
                            for(size_t i_init_seg = num_segments_collected; i_init_seg < segments_collected_capacity; ++i_init_seg) {
                                segments_collected_list[i_init_seg].K_pts = NULL;
                                segments_collected_list[i_init_seg].r_pts = NULL;
                                segments_collected_list[i_init_seg].phi_pts = NULL;
                            }
                        }
                    }

                    if (integration_stop_code == 0) { 
                        segments_collected_list[num_segments_collected].K_pts = gsl_vector_alloc(current_segment_point_count);
                        segments_collected_list[num_segments_collected].r_pts = gsl_vector_alloc(current_segment_point_count);
                        segments_collected_list[num_segments_collected].phi_pts = gsl_vector_alloc(current_segment_point_count);

                        if (!segments_collected_list[num_segments_collected].K_pts ||
                            !segments_collected_list[num_segments_collected].r_pts ||
                            !segments_collected_list[num_segments_collected].phi_pts) {
                            fprintf(stderr, "integrate_photon_trajectory_core: Failed to alloc GSL vectors for TP segment %zu.\n", num_segments_collected);
                            integration_stop_code = 3; core_error_code = -1;
                            gsl_vector_free(segments_collected_list[num_segments_collected].K_pts); segments_collected_list[num_segments_collected].K_pts = NULL;
                            gsl_vector_free(segments_collected_list[num_segments_collected].r_pts); segments_collected_list[num_segments_collected].r_pts = NULL;
                            gsl_vector_free(segments_collected_list[num_segments_collected].phi_pts); segments_collected_list[num_segments_collected].phi_pts = NULL;
                        } else {
                            for (size_t k_copy = 0; k_copy < current_segment_point_count; ++k_copy) {
                                gsl_vector_set(segments_collected_list[num_segments_collected].K_pts, k_copy, gsl_vector_get(current_segment_K_temp, k_copy));
                                gsl_vector_set(segments_collected_list[num_segments_collected].r_pts, k_copy, gsl_vector_get(current_segment_r_temp, k_copy));
                                gsl_vector_set(segments_collected_list[num_segments_collected].phi_pts, k_copy, gsl_vector_get(current_segment_phi_temp, k_copy));
                            }
                            num_segments_collected++;
                        }
                    }
                    current_segment_point_count = 0; 
                }
                // End of VERBATIM BLOCK 10

                if (integration_stop_code == 0) { 
                    current_sign_dr_dk *= -1; 
                    y_current_state[0] += (1e-7) * current_sign_dr_dk; 
                    K_loop_variable += 1e-7;                           
                    
                    printf("TP_POST_NUDGE_C K %.17e R %.17e PHI %.17e SIGN %d\n",
                           K_loop_variable, y_current_state[0], y_current_state[1], *ode_params_instance.sign_dr_dk);
                    fflush(stdout);
                    
                     // +++++++  New Code Start (Reset Driver after TP nudge) ++++++
            int status_driver_reset = gsl_odeiv2_driver_reset(d_core_driver);
            if (status_driver_reset != GSL_SUCCESS) {
                fprintf(stderr, "Warning: Failed to reset d_core_driver after TP. Status: %s\n", gsl_strerror(status_driver_reset));
            }
            // Optionally, reset the driver's internal step size, though it should adapt.
            // If d_core_driver->h is accessible and settable (depends on GSL version/struct visibility)
            // d_core_driver->h = 1e-8; // Or let driver find its own new h
            // Forcing a very small h on the driver might not be necessary as it's adaptive.
            // GSL recommends just reset for state changes.
            // +++ New Code End (Reset Driver after TP nudge) ++++++               

                    // VERBATIM BLOCK 11: Start New Segment in temp buffers with NUDGED state
                    if (full_traj_output) { 
                        current_segment_point_count = 0; 
                        if (reallocate_gsl_vector_if_needed(&current_segment_K_temp, current_segment_point_count, &current_segment_K_capacity, INITIAL_RAW_POINTS_CAPACITY) != 0 ||
                            reallocate_gsl_vector_if_needed(&current_segment_r_temp, current_segment_point_count, &current_segment_r_capacity, INITIAL_RAW_POINTS_CAPACITY) != 0 ||
                            reallocate_gsl_vector_if_needed(&current_segment_phi_temp, current_segment_point_count, &current_segment_phi_capacity, INITIAL_RAW_POINTS_CAPACITY) != 0) {
                            integration_stop_code = 3; core_error_code = -1;
                        } else if (integration_stop_code == 0) { 
                            gsl_vector_set(current_segment_K_temp, current_segment_point_count, K_loop_variable);
                            gsl_vector_set(current_segment_r_temp, current_segment_point_count, y_current_state[0]);
                            gsl_vector_set(current_segment_phi_temp, current_segment_point_count, y_current_state[1]);
                            current_segment_point_count = 1;
                        }
                    }
                    // End of VERBATIM BLOCK 11

                    // VERBATIM BLOCK 12: Post-nudge termination checks
                    if (integration_stop_code == 0) { 
                        if (y_current_state[0] <= (2*M_val + EPSILON_GENERAL) || y_current_state[0] >= r_max_val ||
                            (x_stop_active_flag && (y_current_state[0]*cos(y_current_state[1]) <= x_stop_val + EPSILON_GENERAL))) {
                            integration_stop_code = 2; 
                            K_final_reached_integration = K_loop_variable; 
                        } else {
                            K_final_reached_integration = K_loop_variable; // If continuing, this K is the most advanced point so far
                        }
                    }
                    // End of VERBATIM BLOCK 12
                } 
            } else { // Other terminal event 
                integration_stop_code = 2; 
                K_final_reached_integration = K_loop_variable; 
            }
        } // End of `if (idx_earliest_terminal_event != -1 && integration_stop_code == 0)`
        // +++ New Code End++++++
        
        if (integration_stop_code != 0) { K_final_reached_integration = K_loop_variable; break; } 

        if (K_loop_variable >= t_end_max_overall - EPSILON_GENERAL * 10.0) {
            // +++++++  New Code Start (Refined t_end_max_overall handling) ++++++
            double K_before_tend_clamp = K_loop_variable; // K actually reached by solver step
            
            // Set K_loop_variable precisely to t_end_max_overall for loop termination and reporting
            K_loop_variable = t_end_max_overall; 
            
            // If the solver overshot t_end_max_overall, the y_current_state is for K_before_tend_clamp.
            // Ideally, we would interpolate y_current_state back to t_end_max_overall.
            // For now, if an overshoot occurred, we log it and use the state at K_before_tend_clamp
            // but associate it with K_loop_variable = t_end_max_overall.
            // This is a known simplification if not using a driver that precisely hits t_end.
            // Modification #3 (driver) will improve this.
            if (K_before_tend_clamp > t_end_max_overall + EPSILON_GENERAL) {
                 if (is_target_ray_debug_c || 1) { 
                    fprintf(stderr, "C_DEBUG_TRAJ_DETAIL: K_loop_variable=%.17e overshot t_end_max_overall=%.17e. State y_current_state is for overshot K. Clamping K to t_end for reporting.\n", K_before_tend_clamp, t_end_max_overall);
                    fflush(stderr);
                    // To be fully correct, y_current_state should be interpolated back here from the segment
                    // [K_step_start_driver, K_before_tend_clamp] to t_end_max_overall.
                    // This requires K_step_start_driver, y_step_start_driver, f_derivs_step_start_driver,
                    // and f_derivs at K_before_tend_clamp (which is f_derivs_step_end_driver).
                    // For simplicity in this iteration, we are not adding that complex interpolation here.
                    // We accept y_current_state is for K_before_tend_clamp.
                 }
            } // else K_loop_variable was already at or before t_end, y_current_state is consistent.
            
            integration_stop_code = 1; 
            K_final_reached_integration = t_end_max_overall; // Report exactly t_end_max_overall
            
            if (full_traj_output && current_segment_point_count > 0 && integration_stop_code == 0) { // This integration_stop_code==0 check is now always false here
                 // This block should be entered if integration_stop_code was previously 0 and became 1 here.
            }
            // The following logic was inside the 'if (full_traj_output...)' block in your VERBATIM 13.
            // It should apply regardless of full_traj_output if we are terminating at t_end.
            // We update the last point of the *current* segment if it exists.
            if (full_traj_output && current_segment_point_count > 0) { // Check if a segment is active
                size_t last_idx_final_seg = current_segment_point_count -1;
                // Set K to exactly t_end_max_overall
                gsl_vector_set(current_segment_K_temp, last_idx_final_seg, K_loop_variable); 
                // y_current_state is the state at K_before_tend_clamp (if overshot) or at K_loop_variable (if not overshot)
                gsl_vector_set(current_segment_r_temp, last_idx_final_seg, y_current_state[0]);
                gsl_vector_set(current_segment_phi_temp, last_idx_final_seg, y_current_state[1]);
            }
            // +++ New Code End++++++
            // No break needed, outer while loop condition K_loop_variable < t_end_max_overall will handle it.
            // Actually, a break IS needed here if integration_stop_code = 1 is set, to prevent
            // an unnecessary next iteration check if K_loop_variable is exactly t_end_max_overall.
            break; // ++++ Add Single Line+++
        }
    } // End main while loop

    // ++++ THIS IS A GOOD PLACE FOR THE FINAL_STATE_C PRINTF ++++
    // K_final_reached_integration has its final value.
    // y_current_state has the state corresponding to K_final_reached_integration 
    // (or the state just before an error if integration_stop_code indicates a problem).
    // integration_stop_code is set.
    
    // Calculate final_x_cart and final_y_cart based on y_current_state
    double final_x_cart_output = GSL_NAN; // Initialize to NaN
    double final_y_cart_output = GSL_NAN;
    // Only calculate if y_current_state is valid (not NaN, and integration didn't stop with a critical error that makes y_current_state unreliable)
    if (integration_stop_code != 3 && integration_stop_code != 4 && integration_stop_code != 5 && 
        !gsl_isnan(y_current_state[0]) && !gsl_isnan(y_current_state[1])) {
        final_x_cart_output = y_current_state[0] * cos(y_current_state[1]);
        final_y_cart_output = y_current_state[0] * sin(y_current_state[1]);
    }

    printf("FINAL_STATE_C K %.17e R %.17e PHI %.17e X %.17e Y %.17e STOP_CODE %d\n",
           K_final_reached_integration,
           gsl_isnan(y_current_state[0]) ? GSL_NAN : y_current_state[0],
           gsl_isnan(y_current_state[1]) ? GSL_NAN : y_current_state[1],
           final_x_cart_output,
           final_y_cart_output,
           integration_stop_code);
    fflush(stdout);
    // ++++ END OF FINAL_STATE_C PRINTF PLACEMENT ++++



    if (safety_break_counter >= MAX_SAFETY_BREAK_CORE_EVOLVE && integration_stop_code == 0) {
        fprintf(stderr, "Warning C%d: Max safety break counter (%d) reached with EVOLVE. K_final=%.15e. Forcing termination.\n", current_call_instance, MAX_SAFETY_BREAK_CORE_EVOLVE, K_final_reached_integration);
        integration_stop_code = 2; 
        // K_final_reached_integration already holds the last K value
    }
    
    // >>> BEGIN VERBATIM BLOCK 14 <<< (Final Segment Storage, Interpolation, Crossing Transfer, Error Propagation from all_commented_C_code.txt)
    // This includes the `cleanup_core_post_loop_evolve:` label if it was used.
    if (full_traj_output && current_segment_point_count > 0 && integration_stop_code != 3) { 
        if (num_segments_collected >= segments_collected_capacity) {
            segments_collected_capacity = (segments_collected_capacity == 0) ? INITIAL_SEGMENTS_CAPACITY : segments_collected_capacity * 2;
            TrajectorySegmentDataInternal *temp_realloc = realloc(segments_collected_list, segments_collected_capacity * sizeof(TrajectorySegmentDataInternal));
            CHECK_ALLOC_GEN_CORE(temp_realloc, "core (realloc final seg_list ev)", "SegList", integration_stop_code, 3, cleanup_core_post_loop_evolve); 
             segments_collected_list = temp_realloc;
            for(size_t i_init=num_segments_collected; i_init<segments_collected_capacity; ++i_init) { 
                segments_collected_list[i_init].K_pts = NULL; segments_collected_list[i_init].r_pts = NULL; segments_collected_list[i_init].phi_pts = NULL;
            }
        }
        segments_collected_list[num_segments_collected].K_pts = gsl_vector_alloc(current_segment_point_count); CHECK_GSL_ALLOC_VEC_CORE(segments_collected_list[num_segments_collected].K_pts, "core (final K_seg ev)", "K_seg", integration_stop_code, 3, cleanup_core_post_loop_evolve);
        segments_collected_list[num_segments_collected].r_pts = gsl_vector_alloc(current_segment_point_count); CHECK_GSL_ALLOC_VEC_CORE(segments_collected_list[num_segments_collected].r_pts, "core (final r_seg ev)", "r_seg", integration_stop_code, 3, cleanup_core_post_loop_evolve);
        segments_collected_list[num_segments_collected].phi_pts = gsl_vector_alloc(current_segment_point_count); CHECK_GSL_ALLOC_VEC_CORE(segments_collected_list[num_segments_collected].phi_pts, "core (final phi_seg ev)", "phi_seg", integration_stop_code, 3, cleanup_core_post_loop_evolve);
        for(size_t k=0; k<current_segment_point_count; ++k) {
            gsl_vector_set(segments_collected_list[num_segments_collected].K_pts, k, gsl_vector_get(current_segment_K_temp, k));
            gsl_vector_set(segments_collected_list[num_segments_collected].r_pts, k, gsl_vector_get(current_segment_r_temp, k));
            gsl_vector_set(segments_collected_list[num_segments_collected].phi_pts, k, gsl_vector_get(current_segment_phi_temp, k));
        }
        num_segments_collected++;
    }
cleanup_core_post_loop_evolve: {} 
    if (integration_stop_code == 3 && core_error_code ==0) { // If GSL error but no prior core_error
         core_error_code = -1; // Mark as GSL error for later specific handling if needed
    }


    if (full_traj_output && !(core_error_code < 0 && integration_stop_code == 3) && integration_stop_code != 4 && integration_stop_code != 5) {
        if (num_segments_collected == 0 && 
            fabs(K_final_reached_integration - 0.0) < DBL_EPSILON &&
            (full_traj_output->K && full_traj_output->K->size >= 1 && fabs(gsl_vector_get(full_traj_output->K,0) - 0.0) < DBL_EPSILON)) {
            // Trivial case already handled, or no integration happened.
        } 
        else if (num_segments_collected > 0 && K_final_reached_integration >= -EPSILON_GENERAL) {
            size_t total_raw_points = 0;
            for (size_t s = 0; s < num_segments_collected; ++s) {
                if (segments_collected_list[s].K_pts) { 
                     total_raw_points += segments_collected_list[s].K_pts->size;
                } else {
                    fprintf(stderr, "Warning C%d: Null K_pts in segment %zu during interpolation prep (evolve).\n", current_call_instance, s);
                }
            }

            if (total_raw_points >= 1) { 
                int n_pts_interp_actual = (num_interp_points_for_full_traj > 0) ? num_interp_points_for_full_traj : ((total_raw_points > 1) ? DEFAULT_NUM_INTERP_POINTS : 1) ;
                if (n_pts_interp_actual <= 0) n_pts_interp_actual = 1;

                if (full_traj_output->K == NULL || full_traj_output->K->size != (size_t)n_pts_interp_actual) {
                    gsl_vector_free(full_traj_output->K); full_traj_output->K = NULL;
                    gsl_vector_free(full_traj_output->r); full_traj_output->r = NULL;
                    gsl_vector_free(full_traj_output->phi); full_traj_output->phi = NULL;
                    gsl_vector_free(full_traj_output->x); full_traj_output->x = NULL;
                    gsl_vector_free(full_traj_output->y); full_traj_output->y = NULL;
                    full_traj_output->K = gsl_vector_calloc(n_pts_interp_actual); CHECK_GSL_ALLOC_VEC_CORE(full_traj_output->K, "core (interp K ev)", "K", core_error_code, -1, cleanup_core_interp_evolve);
                    full_traj_output->r = gsl_vector_calloc(n_pts_interp_actual); CHECK_GSL_ALLOC_VEC_CORE(full_traj_output->r, "core (interp r ev)", "r", core_error_code, -1, cleanup_core_interp_evolve);
                    full_traj_output->phi = gsl_vector_calloc(n_pts_interp_actual); CHECK_GSL_ALLOC_VEC_CORE(full_traj_output->phi, "core (interp phi ev)", "phi", core_error_code, -1, cleanup_core_interp_evolve);
                    full_traj_output->x = gsl_vector_calloc(n_pts_interp_actual); CHECK_GSL_ALLOC_VEC_CORE(full_traj_output->x, "core (interp x ev)", "x", core_error_code, -1, cleanup_core_interp_evolve);
                    full_traj_output->y = gsl_vector_calloc(n_pts_interp_actual); CHECK_GSL_ALLOC_VEC_CORE(full_traj_output->y, "core (interp y ev)", "y", core_error_code, -1, cleanup_core_interp_evolve); 
                }
                K_all_raw = gsl_vector_alloc(total_raw_points); CHECK_GSL_ALLOC_VEC_CORE(K_all_raw, "core (K_all_raw ev)", "K_all_raw", core_error_code, -1, cleanup_core_interp_arrays_evolve);
                r_all_raw = gsl_vector_alloc(total_raw_points); CHECK_GSL_ALLOC_VEC_CORE(r_all_raw, "core (r_all_raw ev)", "r_all_raw", core_error_code, -1, cleanup_core_interp_arrays_evolve);
                phi_all_raw_temp = gsl_vector_alloc(total_raw_points); CHECK_GSL_ALLOC_VEC_CORE(phi_all_raw_temp, "core (phi_all_raw_temp ev)", "phi_all_raw_temp", core_error_code, -1, cleanup_core_interp_arrays_evolve);

                size_t current_concat_idx = 0;
                for (size_t s = 0; s < num_segments_collected; ++s) {
                     if (!segments_collected_list[s].K_pts || segments_collected_list[s].K_pts->size == 0) continue; 
                    for (size_t i = 0; i < segments_collected_list[s].K_pts->size; ++i) {
                        if (current_concat_idx < total_raw_points) { 
                            gsl_vector_set(K_all_raw, current_concat_idx, gsl_vector_get(segments_collected_list[s].K_pts, i));
                            gsl_vector_set(r_all_raw, current_concat_idx, gsl_vector_get(segments_collected_list[s].r_pts, i));
                            gsl_vector_set(phi_all_raw_temp, current_concat_idx, gsl_vector_get(segments_collected_list[s].phi_pts, i));
                            current_concat_idx++;
                        } else {
                            fprintf(stderr, "Warning C%d: Concatenation index %zu exceeded total_raw_points %zu (evolve).\n", current_call_instance, current_concat_idx, total_raw_points);
                            goto end_concat_loop_final_evolve; 
                        }
                    }
                }
                end_concat_loop_final_evolve:;
                if (current_concat_idx < total_raw_points) {
                    total_raw_points = current_concat_idx;
                     if (total_raw_points == 0) { 
                        fprintf(stderr, "Error C%d: No valid raw points after concat (evolve).\n", current_call_instance);
                        if (full_traj_output->K) { gsl_vector_free(full_traj_output->K); full_traj_output->K = NULL; /* Free r,phi,x,y too */ }
                        goto cleanup_core_interp_arrays_evolve; 
                     }
                }
                phi_unwrapped_all = gsl_vector_alloc(total_raw_points); CHECK_GSL_ALLOC_VEC_CORE(phi_unwrapped_all, "core (phi_unwrapped ev)", "phi_unwrapped", core_error_code, -1, cleanup_core_interp_arrays_evolve);
                gsl_vector_const_view K_all_raw_v_final = gsl_vector_const_subvector(K_all_raw, 0, total_raw_points);
                gsl_vector_const_view phi_all_raw_temp_v_final = gsl_vector_const_subvector(phi_all_raw_temp, 0, total_raw_points);
                unwrap_phi_values(&K_all_raw_v_final.vector, &phi_all_raw_temp_v_final.vector, phi_unwrapped_all);
                if (total_raw_points == 1) { 
                    for (size_t i = 0; i < full_traj_output->K->size; ++i) { 
                        gsl_vector_set(full_traj_output->K, i, gsl_vector_get(K_all_raw, 0));
                        double r_val = gsl_vector_get(r_all_raw, 0);
                        double phi_val_norm = normalize_phi(gsl_vector_get(phi_unwrapped_all, 0));
                        gsl_vector_set(full_traj_output->r, i, r_val);
                        gsl_vector_set(full_traj_output->phi, i, phi_val_norm);
                        gsl_vector_set(full_traj_output->x, i, r_val * cos(phi_val_norm));
                        gsl_vector_set(full_traj_output->y, i, r_val * sin(phi_val_norm));
                    }
                } else { 
                    const gsl_interp_type *spline_type_final = (total_raw_points >= gsl_interp_type_min_size(gsl_interp_cspline)) ? gsl_interp_cspline : gsl_interp_linear;
                    spline_r_interp = gsl_spline_alloc(spline_type_final, total_raw_points); CHECK_ALLOC_GEN_CORE(spline_r_interp, "core (spline_r ev final)", "gsl_spline", core_error_code, -1, cleanup_core_interp_splines_evolve);
                    spline_phi_interp = gsl_spline_alloc(spline_type_final, total_raw_points); CHECK_ALLOC_GEN_CORE(spline_phi_interp, "core (spline_phi ev final)", "gsl_spline", core_error_code, -1, cleanup_core_interp_splines_evolve);
                    acc_r_interp = gsl_interp_accel_alloc(); CHECK_ALLOC_GEN_CORE(acc_r_interp, "core (acc_r ev final)", "gsl_interp_accel", core_error_code, -1, cleanup_core_interp_splines_evolve);
                    acc_phi_interp = gsl_interp_accel_alloc(); CHECK_ALLOC_GEN_CORE(acc_phi_interp, "core (acc_phi ev final)", "gsl_interp_accel", core_error_code, -1, cleanup_core_interp_splines_evolve);
                    gsl_vector_const_view r_all_raw_v_final = gsl_vector_const_subvector(r_all_raw, 0, total_raw_points);
                    gsl_spline_init(spline_r_interp, K_all_raw_v_final.vector.data, r_all_raw_v_final.vector.data, total_raw_points);
                    gsl_spline_init(spline_phi_interp, K_all_raw_v_final.vector.data, phi_unwrapped_all->data, total_raw_points);
                    double K_interp_start_final = gsl_vector_get(&K_all_raw_v_final.vector, 0); 
                    double K_interp_end_final = K_final_reached_integration; 
                    if (K_interp_end_final < K_interp_start_final - EPSILON_GENERAL) { K_interp_end_final = K_interp_start_final; }
                    for (size_t i = 0; i < full_traj_output->K->size; ++i) { 
                        double K_val_to_eval_evolve = (full_traj_output->K->size > 1) ?
                            (K_interp_start_final + (double)i * (K_interp_end_final - K_interp_start_final) / (double)(full_traj_output->K->size - 1)) : K_interp_end_final;
                        double K_spline_data_start_evolve = gsl_vector_get(K_all_raw, 0); 
                        double K_spline_data_end_evolve = gsl_vector_get(K_all_raw, total_raw_points - 1);
                        K_val_to_eval_evolve = fmax(K_spline_data_start_evolve, fmin(K_spline_data_end_evolve, K_val_to_eval_evolve)); 
                        double r_val_evolve = gsl_spline_eval(spline_r_interp, K_val_to_eval_evolve, acc_r_interp);
                        double phi_unwrapped_val_evolve = gsl_spline_eval(spline_phi_interp, K_val_to_eval_evolve, acc_phi_interp);
                        double phi_val_norm_evolve = normalize_phi(phi_unwrapped_val_evolve);
                        gsl_vector_set(full_traj_output->K, i, K_val_to_eval_evolve);
                        gsl_vector_set(full_traj_output->r, i, r_val_evolve);
                        gsl_vector_set(full_traj_output->phi, i, phi_val_norm_evolve);
                        gsl_vector_set(full_traj_output->x, i, r_val_evolve * cos(phi_val_norm_evolve));
                        gsl_vector_set(full_traj_output->y, i, r_val_evolve * sin(phi_val_norm_evolve));
                    }
                cleanup_core_interp_splines_evolve: 
                    if(spline_r_interp) { gsl_spline_free(spline_r_interp); spline_r_interp = NULL; }
                    if(spline_phi_interp) { gsl_spline_free(spline_phi_interp); spline_phi_interp = NULL; }
                    if(acc_r_interp) { gsl_interp_accel_free(acc_r_interp); acc_r_interp = NULL; }
                    if(acc_phi_interp) { gsl_interp_accel_free(acc_phi_interp); acc_phi_interp = NULL; }
                } 
            cleanup_core_interp_arrays_evolve: 
                if(K_all_raw) { gsl_vector_free(K_all_raw); K_all_raw = NULL; }
                if(r_all_raw) { gsl_vector_free(r_all_raw); r_all_raw = NULL; }
                if(phi_all_raw_temp) { gsl_vector_free(phi_all_raw_temp); phi_all_raw_temp = NULL; }
                if(phi_unwrapped_all) { gsl_vector_free(phi_unwrapped_all); phi_unwrapped_all = NULL; }
            }  else { 
                fprintf(stderr, "Warning C%d: No raw points for interpolation (evolve). Output K NULL.\n", current_call_instance);
                if (full_traj_output && full_traj_output->K) { gsl_vector_free(full_traj_output->K); full_traj_output->K = NULL; /* free others */ }
            }
        cleanup_core_interp_evolve:; // Label was defined in the placeholder block
        } else if (!(core_error_code < 0 && integration_stop_code == 3) && integration_stop_code != 4 && integration_stop_code != 5) { 
            fprintf(stderr, "Warning C%d: No segments/invalid K_final for interp (evolve). K_final=%.3e. Output K NULL.\n", current_call_instance, K_final_reached_integration);
            if (full_traj_output && full_traj_output->K) { gsl_vector_free(full_traj_output->K); full_traj_output->K = NULL; /* free others */ }
        }
        
        if (full_traj_output) { 
            if (full_traj_output->crossings_y_at_x_targets && full_traj_output->num_x_targets > 0 && crossings_collector_ptr != full_traj_output->crossings_y_at_x_targets ) { 
                for (size_t i = 0; i < full_traj_output->num_x_targets; ++i) if(full_traj_output->crossings_y_at_x_targets[i]) gsl_vector_free(full_traj_output->crossings_y_at_x_targets[i]);
                free(full_traj_output->crossings_y_at_x_targets);
            }
            full_traj_output->crossings_y_at_x_targets = crossings_collector_ptr; 
            full_traj_output->num_x_targets = num_x_targets_val;
            crossings_collector_ptr = NULL; 
            if(crossings_collector_capacities) { free(crossings_collector_capacities); crossings_collector_capacities = NULL; }
        }
    } 
    if (crossings_output) {
        if (crossings_collector_ptr) { 
            if (crossings_output->crossings_y_at_x_targets && crossings_output->num_x_targets > 0 && crossings_collector_ptr != crossings_output->crossings_y_at_x_targets) { 
                for (size_t i = 0; i < crossings_output->num_x_targets; ++i) if(crossings_output->crossings_y_at_x_targets[i]) gsl_vector_free(crossings_output->crossings_y_at_x_targets[i]);
                free(crossings_output->crossings_y_at_x_targets);
            }
            crossings_output->crossings_y_at_x_targets = crossings_collector_ptr; 
            crossings_output->num_x_targets = num_x_targets_val;
            crossings_collector_ptr = NULL; 
            if(crossings_collector_capacities) { free(crossings_collector_capacities); crossings_collector_capacities = NULL; }
        }
    }
    // >>> END VERBATIM BLOCK 14 <<<

cleanup_core: 
     if(d_core_driver) gsl_odeiv2_driver_free(d_core_driver); d_core_driver = NULL;


    // >>> BEGIN VERBATIM BLOCK 15 <<< (Rest of cleanup_core block from all_commented_C_code.txt)
    if(current_segment_K_temp) gsl_vector_free(current_segment_K_temp);
    if(current_segment_r_temp) gsl_vector_free(current_segment_r_temp);
    if(current_segment_phi_temp) gsl_vector_free(current_segment_phi_temp);
    if(segments_collected_list){
        for(size_t i=0; i<num_segments_collected; ++i){ 
            if(segments_collected_list[i].K_pts) gsl_vector_free(segments_collected_list[i].K_pts);
            if(segments_collected_list[i].r_pts) gsl_vector_free(segments_collected_list[i].r_pts);
            if(segments_collected_list[i].phi_pts) gsl_vector_free(segments_collected_list[i].phi_pts);
        }
        free(segments_collected_list);
    }
    if(crossings_collector_ptr){ 
        for(size_t i=0; i<num_x_targets_val; ++i) {
            if(crossings_collector_ptr[i]) gsl_vector_free(crossings_collector_ptr[i]);
        }
        free(crossings_collector_ptr);
    }
    if(crossings_collector_capacities) free(crossings_collector_capacities); 

    if(K_all_raw) gsl_vector_free(K_all_raw);
    if(r_all_raw) gsl_vector_free(r_all_raw);
    if(phi_all_raw_temp) gsl_vector_free(phi_all_raw_temp);
    if(phi_unwrapped_all) gsl_vector_free(phi_unwrapped_all);

    if(spline_r_interp) gsl_spline_free(spline_r_interp);
    if(spline_phi_interp) gsl_spline_free(spline_phi_interp);
    if(acc_r_interp) gsl_interp_accel_free(acc_r_interp);
    if(acc_phi_interp) gsl_interp_accel_free(acc_phi_interp);

    if (full_traj_output && full_traj_output->error_code == 0 && core_error_code != 0) full_traj_output->error_code = core_error_code;
    if (crossings_output && crossings_output->error_code == 0 && core_error_code != 0) crossings_output->error_code = core_error_code;
    
    if (full_traj_output && full_traj_output->error_code == 0 && (integration_stop_code >= 3 && integration_stop_code <= 5)) full_traj_output->error_code = -2;
    if (crossings_output && crossings_output->error_code == 0 && (integration_stop_code >= 3 && integration_stop_code <= 5)) crossings_output->error_code = -2;
    // >>> END VERBATIM BLOCK 15 <<<

    return (core_error_code != 0) ? core_error_code : 
           ((integration_stop_code >= 3 && integration_stop_code <= 5) ? -1 : 0);
}


// --- Public API Functions ---

/**
 * @brief Computes a full photon trajectory in Schwarzschild spacetime.
 *
 * This function initiates a light ray from an observer's position (`r_0`, `phi_0`)
 * with a specified initial direction (`psi`) and traces its path through the curved
 * Schwarzschild spacetime. It numerically integrates the geodesic equations using
 * an adaptive ODE solver and returns the interpolated trajectory (K, r, phi, x, y)
 * over a specified number of points. It can also detect and record crossings at
 * arbitrary target x-planes.
 *
 * @param r_0 Initial radial coordinate of the photon (observer's position), in Schwarzschild radii (geometric units).
 * @param phi_0 Initial azimuthal angle of the photon (observer's initial angle), in radians.
 * @param M Black hole mass, used in the Schwarzschild metric (in geometric units).
 * @param psi Initial angle of the photon's 3-velocity relative to the radial direction at `r_0`, in radians. This defines the impact parameter `b` (Schwarzschild_Lens_Paper.pdf, Eq. (4)).
 * @param r_max Maximum radial distance the photon can reach before integration terminates (photon escapes).
 * @param x_stop_val Cartesian x-coordinate for an early termination plane.
 * @param x_stop_active Flag indicating if the `x_stop_val` termination condition is active (`true`) or ignored (`false`).
 * @param x_targets A GSL vector of `double` values, specifying Cartesian x-coordinates of planes where y-crossings should be recorded. Can be `NULL` if no specific crossings are needed.
 * @param t_end Maximum affine parameter (`\kappa`) value for integration. Serves as a fallback termination condition.
 * @param num_interp_points Desired number of interpolated points in the output trajectory. If 0, a default value (`DEFAULT_NUM_INTERP_POINTS`) is used. If negative, an error is implicit.
 * @return `PhotonTrajectory*` A pointer to a dynamically allocated `PhotonTrajectory` struct containing the computed path and crossings. Returns `NULL` on critical allocation failure. The caller is responsible for freeing this struct using `free_photon_trajectory`.
 * @note The integration uses an adaptive step-size GSL ODE solver (`rkf45`) for accuracy and robustness.
 * @note This function handles radial turning points and various termination conditions (capture, escape, `x_stop`, `t_end`).
 */
PhotonTrajectory* compute_trajectory( // <<<< Potentially modified signature if you added the flag here too
    double r_0, double phi_0, double M, double psi, double r_max,
    double x_stop_val, bool x_stop_active,
    const gsl_vector *x_targets,
    double t_end, int num_interp_points
    // , bool force_log_this_ray_in_core // If you chose to add it here
) {
    // Allocate the main output struct and initialize its members.
    PhotonTrajectory *result = calloc(1, sizeof(PhotonTrajectory));
    if (!result) { 
        perror("compute_trajectory: calloc PhotonTrajectory failed"); 
        return NULL; 
    }
    result->error_code = 0;
    result->K = NULL; result->r = NULL; result->phi = NULL; 
    result->x = NULL; result->y = NULL;
    result->crossings_y_at_x_targets = NULL; 
    result->num_x_targets = 0;

    // Determine the actual number of interpolation points to use (handle 0 or negative input).
    int n_interp = (num_interp_points > 0) ? num_interp_points : DEFAULT_NUM_INTERP_POINTS;
    if (num_interp_points == 0) n_interp = 1; // Ensure at least 1 point for a minimal trajectory.

   // <<<< MODIFIED call >>>>
    int core_status = integrate_photon_trajectory_core(
        r_0, phi_0, M, psi, r_max, x_stop_val, x_stop_active, x_targets, t_end,
        1e-12, 1e-12, 
        result, NULL, 
        n_interp,
        false // <<<< MODIFIED: Pass false for general calls
    );
    // Propagate any non-zero status from the core function to `result->error_code`.
    if (core_status != 0 && result->error_code == 0) {
        result->error_code = core_status; 
    }
    // Additional check: if K vector is NULL after integration but no error was reported by core,
    // indicate a warning/error (implies trajectory could not be generated).
    if (result->K == NULL && result->error_code == 0 && n_interp > 0) {
        fprintf(stderr, "compute_trajectory: Warning - K is NULL post-integration despite no error_code set by core. Trajectory might be empty.\n");
        result->error_code = -10; // Custom error code for this scenario.
    }
    return result;
}

/**
 * @brief Frees all dynamically allocated memory within a `PhotonTrajectory` struct.
 *
 * This function is the designated cleanup routine for `PhotonTrajectory` objects.
 * It systematically deallocates all GSL vectors (`K`, `r`, `phi`, `x`, `y`)
 * and then iterates through the array of `crossings_y_at_x_targets` to free each
 * individual GSL vector before freeing the array itself. Finally, it frees the
 * `PhotonTrajectory` struct itself.
 *
 * @param traj Pointer to the `PhotonTrajectory` struct to be freed. If `NULL`, the function performs no action, preventing crashes.
 * @sideeffects Deallocates memory pointed to by `traj->K`, `traj->r`, `traj->phi`, `traj->x`, `traj->y`,
 *              and all vectors within `traj->crossings_y_at_x_targets`, and `traj->crossings_y_at_x_targets` array.
 */
void free_photon_trajectory(PhotonTrajectory *traj) {
    if (!traj) { return; } // Safe to call with `NULL` pointer.
    // Free individual GSL vectors.
    if(traj->K) { gsl_vector_free(traj->K); traj->K = NULL; }
    if(traj->r) { gsl_vector_free(traj->r); traj->r = NULL; }
    if(traj->phi) { gsl_vector_free(traj->phi); traj->phi = NULL; }
    if(traj->x) { gsl_vector_free(traj->x); traj->x = NULL; }
    if(traj->y) { gsl_vector_free(traj->y); traj->y = NULL; }
    // Free array of crossing vectors.
    if (traj->crossings_y_at_x_targets) {
        for (size_t i = 0; i < traj->num_x_targets; ++i) {
            if(traj->crossings_y_at_x_targets[i]) { // Check if individual crossing vector is not NULL.
                gsl_vector_free(traj->crossings_y_at_x_targets[i]);
            }
        }
        free(traj->crossings_y_at_x_targets); // Free the array of pointers itself.
        traj->crossings_y_at_x_targets = NULL;
    }
    free(traj); // Free the `PhotonTrajectory` struct itself.
}

/**
 * @brief Computes photon trajectory crossings at specified target x-planes without returning the full path.
 *
 * This is a specialized version of the trajectory computation function, optimized for
 * scenarios where only the intersection points (y-coordinates) with specific target
 * x-planes are required (e.g., for image mapping, where a full trajectory history
 * is not needed). It avoids the computational and memory overhead of interpolating
 * and returning the entire trajectory, making it more efficient for batch processing
 * of rays.
 *
 * @param r_0 Initial radial coordinate of the photon (observer's position).
 * @param phi_0 Initial azimuthal angle of the photon.
 * @param M Black hole mass.
 * @param psi Initial angle of the photon's 3-velocity relative to the radial direction.
 * @param r_max Maximum radial distance before termination.
 * @param x_stop_val Cartesian x-coordinate for an early termination plane.
 * @param x_stop_active Flag to activate the `x_stop_val` termination condition.
 * @param x_targets A GSL vector of `double` values, specifying Cartesian x-coordinates of planes where y-crossings should be recorded. This parameter is mandatory (must not be `NULL`).
 * @param t_end Maximum affine parameter value for integration.
 * @return `TrajectoryCrossings*` A pointer to a dynamically allocated `TrajectoryCrossings` struct containing only the recorded y-crossings. Returns `NULL` on critical allocation failure or if `x_targets` is `NULL`. The caller is responsible for freeing this struct using `free_trajectory_crossings`.
 * @pre `x_targets` must not be `NULL`.
 * @note This function is particularly efficient for reverse ray tracing applications that only need the final lensed image coordinates.
 */
TrajectoryCrossings* compute_trajectory_crossings_only(
    double r_0, double phi_0, double M, double psi, double r_max,
    double x_stop_val, bool x_stop_active,
    const gsl_vector *x_targets, double t_end,
    bool force_log_this_ray_in_core // <<<< NEW PARAMETER ADDED HERE
) {
    if (!x_targets) { 
        fprintf(stderr, "compute_trajectory_crossings_only: x_targets cannot be NULL. A vector of target planes is required.\n");
        return NULL;
    }
    TrajectoryCrossings *result = calloc(1, sizeof(TrajectoryCrossings));
    if (!result) { 
        perror("compute_trajectory_crossings_only: calloc TrajectoryCrossings failed"); 
        return NULL; 
    }
    result->error_code = 0;
    result->crossings_y_at_x_targets = NULL; 
    result->num_x_targets = 0; 

    // <<<< MODIFIED call >>>>
    int core_status = integrate_photon_trajectory_core(
        r_0, phi_0, M, psi, r_max, x_stop_val, x_stop_active, x_targets, t_end,
        1e-12, 1e-12, 
        NULL, result, 
        0,
        force_log_this_ray_in_core // <<<< MODIFIED: Pass the flag
    ); 

    if (core_status != 0 && result->error_code == 0) {
        result->error_code = core_status;
    }
    if (result->crossings_y_at_x_targets == NULL && result->error_code == 0 && x_targets->size > 0) {
        // This warning is fine, just means no crossings were found for this ray.
        // fprintf(stderr, "compute_trajectory_crossings_only: Warning - crossings_y_at_x_targets is NULL post-integration despite no error_code set by core. No crossings found.\n");
    }
    return result;
}

/**
 * @brief Frees all dynamically allocated memory within a `TrajectoryCrossings` struct.
 *
 * This function is the designated cleanup routine for `TrajectoryCrossings` objects.
 * It iterates through the array of `crossings_y_at_x_targets` to free each
 * individual GSL vector before freeing the array itself. Finally, it frees the
 * `TrajectoryCrossings` struct itself.
 *
 * @param crossings Pointer to the `TrajectoryCrossings` struct to be freed. If `NULL`, the function performs no action, preventing crashes.
 * @sideeffects Deallocates all vectors within `crossings->crossings_y_at_x_targets` and the `crossings->crossings_y_at_x_targets` array.
 */
void free_trajectory_crossings(TrajectoryCrossings *crossings) {
    if (!crossings) { return; } // Safe to call with `NULL` pointer.
    // Free array of crossing vectors.
    if (crossings->crossings_y_at_x_targets) {
        for (size_t i = 0; i < crossings->num_x_targets; ++i) {
            if(crossings->crossings_y_at_x_targets[i]) { // Check if individual crossing vector is not NULL.
                gsl_vector_free(crossings->crossings_y_at_x_targets[i]);
            }
        }
        free(crossings->crossings_y_at_x_targets); // Free the array of pointers itself.
        crossings->crossings_y_at_x_targets = NULL;
    }
    free(crossings); // Free the `TrajectoryCrossings` struct itself.
}


#ifdef UNIT_TEST_TRAJECTORY_MODULE
// Example unit tests for compute_trajectory and compute_trajectory_crossings_only.
// These tests verify basic functionality, error handling, and expected physical behavior
// for a Schwarzschild black hole (M=1.0) in geometric units.
// Ensure M_PI is available (from math.h, typically included via schwarzschild_tracer.h).
int main() {
    printf("--- Unit Test for Trajectory Module (compute_trajectory*, free_*) ---\n");
    // Disable GSL's default error handler to prevent program termination on GSL errors.
    // This allows custom error checking and ensures the entire test suite runs even if
    // an underlying GSL operation encounters a non-fatal error.
    gsl_set_error_handler_off();

    // Test 1: compute_trajectory - scattering trajectory.
    // A photon starting far from the black hole with a specific initial angle (psi) should scatter.
    // We expect its final radial distance to be similar to or greater than its initial distance.
    printf("Test 1: compute_trajectory (scattering)...\n");
    PhotonTrajectory *traj1 = compute_trajectory(20.0, 0.0, 1.0, -1.25, 100.0, 
                                                 gsl_nan(), false, // x_stop_val (not active), x_stop_active (false).
                                                 NULL, // x_targets (no specific crossings requested for full trajectory).
                                                 1000.0, 10); // t_end (max affine param), num_interp_points (for output resolution).
    // Check if trajectory was successfully generated and contains points.
    if (traj1 && traj1->error_code == 0 && traj1->K && traj1->K->size > 0 && traj1->r && traj1->r->size == traj1->K->size) {
        printf("  Scatter test K size: %zu, final r: %g\n", traj1->K->size, gsl_vector_get(traj1->r, traj1->r->size-1));
        // Verify final radial distance (r) is large enough to indicate scattering.
        if (gsl_vector_get(traj1->r, traj1->r->size-1) > 19.0) { // Expected to be > initial r (20.0) or close to r_max (100.0).
            printf("  Scatter test PASSED.\n");
        } else {
            printf("  Scatter test FAILED (final r %.2f too small for scattering).\n", gsl_vector_get(traj1->r, traj1->r->size-1));
        }
    } else {
        printf("  Scatter test FAILED (error_code %d or NULL/mismatched K/r vectors, or K empty).\n", traj1 ? traj1->error_code : -999);
    }
    free_photon_trajectory(traj1); // Clean up allocated memory.

    // Test 2: compute_trajectory_crossings_only - inward radial trajectory.
    // A photon starting at r=5.0 and aimed directly inward (-M_PI/2) should fall into the black hole.
    // We request crossings at x=4.0 and x=3.0, expecting y_cross to be near 0.0 for purely radial motion.
    printf("Test 2: compute_trajectory_crossings_only (inward radial)...\n");
    gsl_vector *xt_test2 = gsl_vector_alloc(2); // Define two target x-planes.
    gsl_vector_set(xt_test2, 0, 4.0); // First target x-plane.
    gsl_vector_set(xt_test2, 1, 3.0); // Second target x-plane.
    TrajectoryCrossings *cross2 = compute_trajectory_crossings_only(5.0, 0.0, 1.0, -M_PI/2, 100.0, 
                                                                    0.0, true, // x_stop_val (set to 0.0), x_stop_active (true, as photon will cross it).
                                                                    xt_test2, 1000.0); // x_targets, t_end.
    // Check if crossings were successfully found for both target planes and no error occurred.
    if (cross2 && cross2->error_code == 0 && cross2->num_x_targets == 2 && 
        cross2->crossings_y_at_x_targets && // Ensure array of GSL vectors is allocated.
        cross2->crossings_y_at_x_targets[0] && cross2->crossings_y_at_x_targets[0]->size > 0 && // Check first target crossing data.
        cross2->crossings_y_at_x_targets[1] && cross2->crossings_y_at_x_targets[1]->size > 0) { // Check second target crossing data.
        printf("  Crossings test: Target x=%.1f, y_cross=%.4f; Target x=%.1f, y_cross=%.4f\n",
                gsl_vector_get(xt_test2, 0), gsl_vector_get(cross2->crossings_y_at_x_targets[0],0),
                gsl_vector_get(xt_test2, 1), gsl_vector_get(cross2->crossings_y_at_x_targets[1],0));
        // For purely radial inward motion, y-crossings should be very close to zero.
        if (fabs(gsl_vector_get(cross2->crossings_y_at_x_targets[0],0)) < 1e-6 &&
            fabs(gsl_vector_get(cross2->crossings_y_at_x_targets[1],0)) < 1e-6) {
             printf("  Crossings test PASSED (y ~ 0 for radial motion).\n");
        } else {
             printf("  Crossings test FAILED (y not close to 0 for radial motion, y_cross_x4=%.4f, y_cross_x3=%.4f).\n", 
                    gsl_vector_get(cross2->crossings_y_at_x_targets[0],0), gsl_vector_get(cross2->crossings_y_at_x_targets[1],0));
        }
    } else {
        printf("  Crossings test FAILED (error_code %d or unexpected structure/counts).\n", cross2 ? cross2->error_code : -999);
         if (cross2) { // Provide more detailed error info if `cross2` is not NULL.
            printf("    Details: num_x_targets=%zu, crossings_ptr=%p\n", cross2->num_x_targets, (void*)cross2->crossings_y_at_x_targets);
            if (cross2->crossings_y_at_x_targets && cross2->num_x_targets >0) {
                 printf("      Target 0: ptr=%p, size=%zu\n", (void*)cross2->crossings_y_at_x_targets[0], cross2->crossings_y_at_x_targets[0] ? cross2->crossings_y_at_x_targets[0]->size : 0);
                 if (cross2->num_x_targets >1) printf("      Target 1: ptr=%p, size=%zu\n", (void*)cross2->crossings_y_at_x_targets[1], cross2->crossings_y_at_x_targets[1] ? cross2->crossings_y_at_x_targets[1]->size : 0);
            }
        }
    }
    free_trajectory_crossings(cross2); // Clean up allocated memory.
    gsl_vector_free(xt_test2); // Free the target vector.

    printf("--- Unit Test for Trajectory Module Finished ---\n");
    return 0;
}
#endif // UNIT_TEST_TRAJECTORY_MODULE

// trajectory_module.c
// Bottom




#Top
# Makefile for Schwarzschild Ray Tracer

# Compiler and Linker
CC = gcc

# --- GSL Configuration ---
# Use gsl-config to get the necessary flags.
# This makes the Makefile more portable across systems where GSL might be installed in different locations.
GSL_CFLAGS = $(shell gsl-config --cflags)
GSL_LIBS = $(shell gsl-config --libs)

# --- CFLAGS: Compiler flags ---
# -Wall -Wextra: Enable many useful warnings.
# -std=c11: Adhere to the C11 standard.
# -g: Include debugging information.
# -O2: Optimization level.
# $(GSL_CFLAGS): Include paths for GSL headers.
CFLAGS = -Wall -Wextra -std=c11 -g -O2 $(GSL_CFLAGS)

# --- LDFLAGS: Linker flags ---
# $(GSL_LIBS): Link against GSL libraries (e.g., -lgsl, -lgslcblas).
# -lm: Link the math library.
LDFLAGS = $(GSL_LIBS) -lm

# --- Adjust GSL paths if not in standard locations (via gsl-config is preferred) ---
# If GSL is installed in a non-standard directory AND gsl-config is not working or not preferred,
# you might uncomment and set these. However, using gsl-config above is generally better.
# Example for Homebrew on ARM Mac (Apple Silicon):
# GSL_INCLUDE_DIR_MANUAL = /opt/homebrew/opt/gsl/include
# GSL_LIB_DIR_MANUAL = /opt/homebrew/opt/gsl/lib
# Example for Homebrew on Intel Mac:
# GSL_INCLUDE_DIR_MANUAL = /usr/local/opt/gsl/include
# GSL_LIB_DIR_MANUAL = /usr/local/opt/gsl/lib
#
# If using manual paths, modify CFLAGS and LDFLAGS:
# CFLAGS := $(filter-out $(GSL_CFLAGS), $(CFLAGS)) # Remove gsl-config part if overriding
# CFLAGS += -I$(GSL_INCLUDE_DIR_MANUAL)
# LDFLAGS := $(filter-out $(GSL_LIBS), $(LDFLAGS)) # Remove gsl-config part if overriding
# LDFLAGS += -L$(GSL_LIB_DIR_MANUAL) -lgsl -lgslcblas # Add manual lib path and libs
# --- End GSL Path Adjustment ---

# Header file (dependency for most .c files)
HEADER = schwarzschild_tracer.h

# Source files for the core library modules
SRCS_LIB = \
    trajectory_module.c \
    image_mapping_utils.c \
    results_generation.c \
    photon_rendering.c \
    photon_chunk_io.c \
    ppm_image_io.c

# Object files derived from the library source files
OBJS_LIB = $(SRCS_LIB:.c=.o)

# Main integration test program executable
MAIN_TEST_EXEC = schwarzschild_test
MAIN_TEST_SRC = main_test.c
MAIN_TEST_OBJ = $(MAIN_TEST_SRC:.c=.o)

# Executable for trajectory debugging
TRAJ_DEBUG_EXEC = schwarzschild_traj_debug
TRAJ_DEBUG_SRC = main_trajectory_debug.c
TRAJ_DEBUG_OBJ = $(TRAJ_DEBUG_SRC:.c=.o)

# Default target
all: $(MAIN_TEST_EXEC) $(TRAJ_DEBUG_EXEC)

# Rule to link the main test executable
$(MAIN_TEST_EXEC): $(OBJS_LIB) $(MAIN_TEST_OBJ)
	@echo "Linking $(MAIN_TEST_EXEC) with LDFLAGS: $(LDFLAGS)..."
	$(CC) $(MAIN_TEST_OBJ) $(OBJS_LIB) -o $@ $(LDFLAGS) # Main obj first, then lib objs
	@echo "$(MAIN_TEST_EXEC) built successfully."

# Rule to link the trajectory debug executable
$(TRAJ_DEBUG_EXEC): $(OBJS_LIB) $(TRAJ_DEBUG_OBJ)
	@echo "Linking $(TRAJ_DEBUG_EXEC) with LDFLAGS: $(LDFLAGS)..."
	$(CC) $(TRAJ_DEBUG_OBJ) $(OBJS_LIB) -o $@ $(LDFLAGS) # Debug obj first, then lib objs
	@echo "$(TRAJ_DEBUG_EXEC) built successfully."

# Generic rule to compile .c files into .o object files
# $(CFLAGS) now includes GSL include paths from $(GSL_CFLAGS)
%.o: %.c $(HEADER)
	@echo "Compiling $< with CFLAGS: $(CFLAGS)..."
	$(CC) $(CFLAGS) -c $< -o $@

# --- Unit Test Targets ---

# Unit test for `trajectory_module.c`
UT_TRAJ_EXEC = test_trajectory_module
UT_TRAJ_SRC = trajectory_module.c
$(UT_TRAJ_EXEC): $(UT_TRAJ_SRC) $(HEADER)
	@echo "Building unit test $(UT_TRAJ_EXEC) with CFLAGS: $(CFLAGS) LDFLAGS: $(LDFLAGS)..."
	$(CC) $(CFLAGS) -DUNIT_TEST_TRAJECTORY_MODULE $(UT_TRAJ_SRC) -o $@ $(LDFLAGS)
	@echo "Running unit test $(UT_TRAJ_EXEC)..."
	./$(UT_TRAJ_EXEC)

# Unit test for `image_mapping_utils.c`
UT_IMGMAP_EXEC = test_image_mapping_utils
UT_IMGMAP_SRC = image_mapping_utils.c
# Needs trajectory_module.o
$(UT_IMGMAP_EXEC): $(UT_IMGMAP_SRC) trajectory_module.o $(HEADER)
	@echo "Building unit test $(UT_IMGMAP_EXEC) with CFLAGS: $(CFLAGS) LDFLAGS: $(LDFLAGS)..."
	$(CC) $(CFLAGS) -DUNIT_TEST_IMAGE_MAPPING_UTILS $(UT_IMGMAP_SRC) trajectory_module.o -o $@ $(LDFLAGS)
	@echo "Running unit test $(UT_IMGMAP_EXEC)..."
	./$(UT_IMGMAP_EXEC)

# Unit test for `results_generation.c`
UT_RESGEN_EXEC = test_results_generation
UT_RESGEN_SRC = results_generation.c
UT_RESGEN_DEPS_OBJS = image_mapping_utils.o trajectory_module.o photon_chunk_io.o
$(UT_RESGEN_EXEC): $(UT_RESGEN_SRC) $(UT_RESGEN_DEPS_OBJS) $(HEADER)
	@echo "Building unit test $(UT_RESGEN_EXEC) with CFLAGS: $(CFLAGS) LDFLAGS: $(LDFLAGS)..."
	$(CC) $(CFLAGS) -DUNIT_TEST_RESULTS_GENERATION $(UT_RESGEN_SRC) $(UT_RESGEN_DEPS_OBJS) -o $@ $(LDFLAGS)
	@echo "Running unit test $(UT_RESGEN_EXEC)..."
	./$(UT_RESGEN_EXEC)

# Unit test for `photon_rendering.c`
UT_PHOTREND_EXEC = test_photon_rendering
UT_PHOTREND_SRC = photon_rendering.c
UT_PHOTREND_DEPS_OBJS = ppm_image_io.o photon_chunk_io.o
$(UT_PHOTREND_EXEC): $(UT_PHOTREND_SRC) $(UT_PHOTREND_DEPS_OBJS) $(HEADER)
	@echo "Building unit test $(UT_PHOTREND_EXEC) with CFLAGS: $(CFLAGS) LDFLAGS: $(LDFLAGS)..."
	$(CC) $(CFLAGS) -DUNIT_TEST_PHOTON_RENDERING $(UT_PHOTREND_SRC) $(UT_PHOTREND_DEPS_OBJS) -o $@ $(LDFLAGS)
	@echo "Running unit test $(UT_PHOTREND_EXEC)..."
	./$(UT_PHOTREND_EXEC)

# Unit test for `photon_chunk_io.c`
UT_CHUNKIO_EXEC = test_photon_chunk_io
UT_CHUNKIO_SRC = photon_chunk_io.c
$(UT_CHUNKIO_EXEC): $(UT_CHUNKIO_SRC) $(HEADER)
	@echo "Building unit test $(UT_CHUNKIO_EXEC) with CFLAGS: $(CFLAGS) LDFLAGS: $(LDFLAGS)..."
	$(CC) $(CFLAGS) -DUNIT_TEST_CHUNK_IO $(UT_CHUNKIO_SRC) -o $@ $(LDFLAGS)
	@echo "Running unit test $(UT_CHUNKIO_EXEC)..."
	./$(UT_CHUNKIO_EXEC)

# Unit test for `ppm_image_io.c`
UT_PPMIO_EXEC = test_ppm_image_io
UT_PPMIO_SRC = ppm_image_io.c
$(UT_PPMIO_EXEC): $(UT_PPMIO_SRC) $(HEADER)
	@echo "Building unit test $(UT_PPMIO_EXEC) with CFLAGS: $(CFLAGS) LDFLAGS: $(LDFLAGS)..."
	$(CC) $(CFLAGS) -DUNIT_TEST_PPM_IO $(UT_PPMIO_SRC) -o $@ $(LDFLAGS)
	@echo "Running unit test $(UT_PPMIO_EXEC)..."
	./$(UT_PPMIO_EXEC)

# Target to run all defined unit tests
run_unit_tests: $(UT_TRAJ_EXEC) $(UT_IMGMAP_EXEC) $(UT_RESGEN_EXEC) $(UT_PHOTREND_EXEC) $(UT_CHUNKIO_EXEC) $(UT_PPMIO_EXEC)
	@echo "\nAll specified unit tests have been run."

# Clean target
clean:
	@echo "Cleaning up..."
	rm -f $(OBJS_LIB) $(MAIN_TEST_OBJ) $(TRAJ_DEBUG_OBJ)
	rm -f $(MAIN_TEST_EXEC) $(TRAJ_DEBUG_EXEC) \
	      $(UT_TRAJ_EXEC) $(UT_IMGMAP_EXEC) $(UT_RESGEN_EXEC) \
	      $(UT_PHOTREND_EXEC) $(UT_CHUNKIO_EXEC) $(UT_PPMIO_EXEC)
	rm -f *.o # Catch-all for any other .o files
	# Clean up output files from tests and generation
	rm -f test_*.ppm test_*.bin
	rm -f ResCart_*.bin ResRad_*.bin LightRingSeg0thLrg_*.bin
	rm -f main_test_lensed_*.ppm
	@echo "Cleanup complete."

# Phony targets
.PHONY: all clean run_unit_tests $(TRAJ_DEBUG_EXEC) \
        $(UT_TRAJ_EXEC) $(UT_IMGMAP_EXEC) $(UT_RESGEN_EXEC) \
        $(UT_PHOTREND_EXEC) $(UT_CHUNKIO_EXEC) $(UT_PPMIO_EXEC)

# End of Makefile
# Bottom